{"/":{"title":"Digital Garden Home ðŸŒ±","content":"Welcome to my [digital garden](Digital%20Gardens.md) - I'm Diwash. I have been exploring personal knowledge management for a long time and this site is my experiment with doing so in a more public manner that aligns with the idea of [work with the garage door up](Work%20with%20the%20garage%20door%20up.md).  \n\nYou will mainly find notes about software engineering and productivity, however I am just getting started and plan on talking more about AI, PKM systems, mental models and many more.  \n\nThe notes are laid out in a [network](Networked%20Thinking.md) which may be confusing at first, but should allow for easy exploration. For now feel free to use the graph below to dive right in or the map of contents to choose a topic.\n\n[Map of contents](Map%20of%20contents.md)\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Activation-Energy":{"title":"Activation Energy","content":"Reference:  https://www.makeuseof.com/tag/7-mental-models-get-work-done/ | [Atomic Habits](Sources/Atomic%20Habits.md)  \nTopics: [Productivity](Topics/Productivity.md)  \n\n---\nThe more complex a task, the higher the activation energy required to start and sustain it.\n- To counter this, target the energy required to **start** a task.\n- Break down tasks into simpler and smaller steps.","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Anti-marketing":{"title":"Anti-marketing","content":"Reference:  [Anti Marketing - Andy Matuschak](https://notes.andymatuschak.org/About_these_notes?stackedNotes=z21cgR9K3UcQ5a7yPsj2RUim3oM2TzdBByZu\u0026stackedNotes=z4bK6LaSBRetDzuYkeCs3A8mJ8DufTbK4o6FS)  \nTopics: [Mental Models](Topics/Mental%20Models.md)  \n\n---\n\nA model for presenting your work that forces you to engage people more by talking about all the challenges that happened and how you struggled and overcame those challenges. This goes against most content out there where a presenter may want to make themselves or their project look as good as possible but leads to less personal and less genuine presentation.","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Authors/Dr-K":{"title":"Dr. K","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Authors/Fedor-Pikus":{"title":"Fedor Pikus","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Authors/James-Clear":{"title":"James Clear","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Authors/Leon-Hendrix":{"title":"Leon Hendrix","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Authors/Rhiannon-Beaubien":{"title":"Rhiannon Beaubien","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Authors/Scott-Meyers":{"title":"Scott Meyers","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Brain-Dump":{"title":"Brain Dump","content":"\nTopics: [Productivity](Topics/Productivity.md)  \nReference:[Leon Hendrix - Journaled for 1000 days. What I learned.](Sources/Leon%20Hendrix%20-%20Journaled%20for%201000%20days.%20What%20I%20learned..md) | [Getting Things Done](Getting%20Things%20Done.md)  \n\n---\n\nA technique used to offload all of the things that are currently straining you mentally by writing everything you can think of onto a note.\n\nValuable for reducing anxiety and staying productive as the first step of creating a structured plan.","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Design-Documents":{"title":"Design Documents","content":"Reference:  [Design Docs at Google](https://www.industrialempathy.com/posts/design-docs-at-google/) |  [What is a design doc in software engineering?](https://www.youtube.com/watch?v=bgHL41e7vgI)  \nTopics: [Software Engineering](Topics/Software%20Engineering.md)   \n\n---\n## What is a design doc?\nDesign documents are relatively subjective and informal documents that the primary author of a software system or feature may write before beginning implementation of the software system or feature.  \n\nThe main purposes of a design document are the following:\n- Identify design issues early on in the process where changes are still cheap.\n\t- ==Potentially contentious aspects of the design should be listed==\n\t- ==Considerations for alternative designs must be shown==\n- Ensure cross-cutting conerns are considered and addressed. e.g. security, privacy, logging etc.\n- Utilise knowledge of senior engineers as a way to incorporate the organisations combined experience into a design.\n- Achieve consensus around a design. Allows for accurate implementation of a design in a collaborative environment as well as a way to settle possible disputes.\n- Function as technical documentation about software systems and especially about design decisions made that may have been forgotten.\n\n## Structure\n- **Context and scope**\n\t- Summary of the landscape where the system will be built and what system actually is.\n- **Goals and non-goals**\n\t- What is the system trying to achieve and more importantly...\n\t- What is the system not trying to achieve. ==Things that could be reasonable goals but are explicitly chosen to not be goals.==\n- **The actual design**\n\t- System-context-diagram\n\t- APIs\n\t- Data storage\n\t- Code and pseudo-code: Should be used sparingly.\n\t- Degree of constraint: Constraint on the solution space. Greenfield projects allow no restrictions, whereas legacy systems enforce a multitude of constraints.\n- **Alternatives considered**\n\t- List alternative designs that could have reasonably achieved similar outcomes\n\t- Focus on the trade-offs that each design makes.\n\t- It is fine to be succint, but balance that with the fact that ==this is the most important section in showing why the chosen design is the best.==\n- **Cross-cutting concerns**\n\t- Ensure cross-cutting concerns have been considered.\n\n## Length\n- Shorter features or incremental improvements may be 'one-pagers'.\n- Larger projects seem to be 10-20 pages.\n\n## Lifecycle\n- Creation and iteration\n- Review\n- Implementation and iteration\n- Maintenance and learning\n\n\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Digital-Gardens":{"title":"Digital Gardens","content":"References:  [Maggie Appleton - Brief History \u0026 Ethos of Digital Gardens](https://maggieappleton.com/garden-history)  \n[Tom Critchlow - Building digital garden](https://tomcritchlow.com/2019/02/17/building-digital-garden/)  \nTopics:  [Productivity](Topics/Productivity.md)  \n\n---\n\n### Intro\nDigital gardens are an alternative model for thinking about personal sites and blogs that goes against how we have come to think about them. They also support the philosophy of [Work with the garage door up](Work%20with%20the%20garage%20door%20up.md) as you are publishing your notes and thoughts online for all to see.  \n\n### Continuous growth\nDigital gardens treat content not as something that is finalised and published, but something that is in an ever growing state. You are free to make additions to each page when you learn something new or make a new connection.  \n\n### Network of concepts and ideas\nThe content in digital gardens are not laid out in some sort of time based 'stream' but as an [interconnected cluster of nodes](Networked%20Thinking.md). This allows for relationships between different topics/notes to be noticed and linked which can allow for better insights to be gained.  \n\n### Exploration over performance\nDigital gardens have a less performative philosophy. Each page is treated less like polished articles intended to be consumed by an audience, but more like a free form wiki of thought's an ideas that the person may note as they encounter them. You could argue that the primary audience for a digital garden is in fact the 'gardener' themselves. This idea frees the 'gardener' to not have to worry about making every sentence, every page perfect, but to focus on what they're interested in and what would benefit themselves (and perhaps other readers).  \n\n### Playful and experimental\nDigital gardens have a more playful and experimental nature to them. You will find a wide plethora of layouts, templates and languages used to create them. The aim is to find what works for you and to also have some fun so that you continue to maintain the garden. At the end of the day, the battle is to absorb the information that we are bombarded with daily in a way that can be applied in our own lives. For that to happen, we need to find what works for us and we have to stick with it.  \n\n### Summary\n- Digital gardens are continuously evolving and growing. No singular page or note should be considered truly complete as new connections and insights can always be made.\n- Digital gardens are a network of nodes. This allows ideas/concepts to be linked easier and for the value of knowledge growth to be non-linear.\n- Digital gardens value the creators own personal exploration and growth over presenting something as a finished product to an audience which brings with it a more performative mindset.\n- Digital gardens are playful and experimental as they provide more value to us, the more fun we are having and the more personalised the garden is to our own needs.","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Getting-Things-Done":{"title":"Getting Things Done","content":"\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Map-of-contents":{"title":"Map of contents","content":"## Topics\n- [Software Engineering](Topics/Software%20Engineering.md)\n- [Productivity](Topics/Productivity.md)\n- [Mental Models](Topics/Mental%20Models.md)\n- [Journaling](Topics/Journaling.md)\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Molecules/Task-implementation-framework":{"title":"Task implementation framework","content":"Topics: [Productivity](Topics/Productivity.md)  \nReference: [Brain Dump](Brain%20Dump.md) | [Activation Energy](Activation%20Energy.md)    \n\n---\nPersonal productivity created from a combination of insights from various sources with some real life testing to find something that works best for me.\n\n### Method\n- Brain dump\n- Use brain dump to create check list\n- Optional: Time block tasks from check list\n- Review how well the framework worked for that specific project/task.\n\n### Rationale\n- Brain dump - Helps to get the ball rolling when I don't know where to start\n- Creating a check list/plan before starting helps keep me focused in implementation phase. Having to pause to think what comes next or make a decision on what to tackle next can be just enough to get me distracted.\n- Time blocking - prevents me from taking too long on individual tasks. This can happen when due to analysis paralysis or perfectionism.\n\n\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Networked-Thinking":{"title":"Networked thinking","content":"Reference:  [Roam Research White Paper](Sources/Roam%20Research%20White%20Paper.md)  \nTopics:  [Productivity](Topics/Productivity.md)  \n\n---\n\nA new method of managing knowledge that is more suited to the modern information age where we have an unprecedented amount of information available. The idea is to think of each bit of knowledge as a singular node in an interconnected network of nodes instead of a more 'cabinet desk' like hierarchical strucuture for your knowledge.  \n\nBenefits include:\n- Ease of storage - No need to try to categorise a new bit of knowledge perfectly so that it sits in the correct location in your hierarchy.\n- Better recollection - You can remember an idea itself, or any other node that it may be connected to or even a series of links to the idea you want to recall.\n- Effortless cross-referencing - ideas can be cross-referenced easily without duplication.\n- Optimised for serendipity - graphical display of node network can allow unexpected insights and connections to be made.\n- 'Collaborative problem solving' - can help separate signal from the noise as you can consider conflicting opinions on the same topic and develop your own understanding or draw your own conclusions.","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Obsidian-System":{"title":"Obsidian System","content":"\n-   **Core types:**\n    - atom: the base note type for an individual piece of knowledge derived from a source\n    - molecule: bservation/insight drawn from a single or multiple atoms\n    - topic: Category placeholder. Helps find related notes in obsidian\n    - author: the creator of a piece of content\n    - todo: something I need to fill in\n-   **Source types and associated template:**\n    - book -\u003e book\n    - article: e.g blog post, web article -\u003e infomedia\n    - post: social media / forum -\u003e infomedia\n    - academic: textbook, journal article -\u003e academic\n    - video -\u003e infomedia\n    - podcast -\u003e infomedia\n-   **Atom types:**\n    - tool: something that I can use to solve a problem\n    - framework: a way of thinking about the world\n    - school-of-thought: a historical school of thought\n    - person: someone of note\n    - event: a historical event\n    - heuristic: a \"common wisdom\" way of doing something\n- **Workflow:**\n    -  Find interesting/useful info.\n    - Create a source if the media has multiple useful ideas/concepts. Create an atom if only 1.\n    - Atomise each useful concept.\n    - Come back to atoms every now and then.\n    - Create a molecule if a new insight is made.\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Parkinsons-law":{"title":"Parkinson's law","content":"Topics: [Productivity](Topics/Productivity.md)  \nReference: https://en.wikipedia.org/wiki/Parkinson%27s_law  \n\n---\n\n\"Work expands so as to fill the time available for it's completion\"\n\nThink of it as a law of physics to work around instead of as 'human nature'. This forces you to push this law to its limit for your own benefit:\n- Micro deadlines - aka 'Time blocking'\n- Experiment with shorter deadlines\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Sources/AI-revolution-applications":{"title":"AI Revolution Applications","content":"Topics: [[Topics/AI]] \n\n---\n\nAutomated email fee appeal  \nhttps://www.bbc.co.uk/news/uk-england-sussex-64749662\n\nImpartial tone judgement for received emails.  \nTherapy sessions  \nhttps://www.reddit.com/r/ChatGPT/comments/11a1ah9/i_am_getting_obsessed_with_chatgpt_and_its/\n\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Sources/Atomic-Habits":{"title":"Atomic Habits","content":"\nAuthor: [James Clear](Authors/James%20Clear.md)  \nTopics: [Productivity](Topics/Productivity.md)  \n\n---\n\n## Theme. 1\n\n- Key idea 1 \n- Key idea 2\n\n## Theme 2\n\n- Key idea 3\n- Key idea 4\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Sources/Branchless-Programming-in-C++":{"title":"Branchless Programming in C++","content":"Link:  [Branchless programming in C++ CppCon video](https://www.youtube.com/watch?v=g-WPhYREFjk)  \nAuthor:  [Fedor Pikus](Authors/Fedor%20Pikus.md)  \nTopics: [Software Engineering](Topics/Software%20Engineering.md)  \n\n---\n\n## Potential benefits\n\n**Common code example 1:**\n```cpp\nf(bool b, unsigned long x, unsigned long\u0026 s)\n{\n    if (b) s+= x;\n}\n```\n130M calls/sec -\u003e 400M calls/sec optimised  \nOptimised version:  \n```cpp\nf(bool b, unsigned long x, unsigned long\u0026 s)\n{\n    s+= b * x; // use boolean as int to multiply 'x'\n}\n```\n\n**Common code example 2:**\n```cpp\nif (x[i] || y[i])\n{\n    // Do something\n}\n```\n150M evaluations/sec -\u003e 570M evaluations/sec\n(Optimisation show in \u003ca href=\"#2b-bitwise-optimisation\"\u003e2.b. bitwise optimisation\u003c/a\u003e)  \n\n## Philosophy for performance\n\nIn order of priority:\n- Get desired result with ==least work==\n    - Use an _optimal_ algorithm\n- Do not do any ==unnecessary work==\n    - Efficiently use language\n- Use ==all available resources==, ==at the same time==, ==all the time==.\n    - Efficient hardware use.\n\n### CPU compute resources\n**Inefficient use of CPU:**\n```cpp\nunsigned long v1[N], v2[N];\nunsigned long a = 0;\nfor (size_t i = 0; i \u003c N; ++i)\n{\n    a += v1[i] * v2[i];\n}\n```\n\nWhy is it inefficient use of CPU?  \nBecause it does not actually load the CPU very much at all as we are only doing one multiplication per iteration. In fact, more calculations can be thrown in for free.  \n\nThe following code will run at the same speed on modern CPUs.  \n```cpp\nunsigned long v1[N], v2[N];\nunsigned long a1 = 0, a2 = 0;\nfor (size_t i = 0; i \u003c N; ++i)\n{\n    a1 += v1[i] * v2[i];\n    a2 += v1[i] + v2[i];\n    ...\n    // in fact you can insert even more operations for 'free'\n}\n```\n\nSounds great! Not quite. You can almost never do that due to ==data dependencies==. In order to do the next computation, you need the result from the first. Things get even worse if there are ==code dependencies.== There may be branches and conditions which means that the CPU now must wait until it knows which ==instructions== to execute as well.  \n\nHaving so much compute power would be useless however if we didn't have some workarounds!\n\n## Pipelining\n```cpp\na += (v1[i] + v2[i]) * (v1[i] - v2[i]);\n```\n\nIn this example you can do the addition and subtraction in the first cycle, then do the multiplication in the second cycle, whilst also doing the addition and subtraction for the next iteration. This creates two _streams_ of instructions that are interleaved that have no data dependency between them at a given cpu cycle.  \n\nThis results in multiple instruction streams that have\n- Dependencies within each stream\n- No data dependencies between streams\n\nThis is great and increases cpu utilisation. However, the next barrier is... **conditional code.**\n\n## Branches\nPipelining requires a continuous stream of instructions. Conditions/Branches mean that the CPU is unsure of the next instruction to place into the pipeline. So what can we do?\n\n**Branch prediction**. The CPU guesses which branch to take and continues pipelining. The ==performance is now based on accuracy of predictions==. However, the branch can be mispredicted and recovering from a ==branch misprediction== is very costly.  \n\nBut how costly is this branch misprediction?\n\n## Experiments\n\n### 1.a. always true -\u003e same branch taken\n\n```cpp\n\n#include \"benchmark/benchmark.h\"\n\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\nstatic void always_true(benchmark::State\u0026 state) {\n    srand(1);\n    const unsigned int N = state.range(0);\n    std::vector\u003cunsigned long\u003e v1(N), v2(N);\n    std::vector\u003cint\u003e c1(N);\n    for (size_t i = 0; i \u003c N; ++i) {\n       v1[i] = rand();\n       v2[i] = rand();\n       c1[i] = rand() \u003e= 0; // always true\n    }\n    unsigned long* p1 = v1.data();\n    unsigned long* p2 = v2.data();\n    int* b1 = c1.data();\n    for (auto _ : state) {\n        unsigned long a1 = 0, a2 = 0;\n        for (size_t i = 0; i \u003c N; ++i) {\n            if (b1[i]) {\n                a1 += p1[i];\n            } else {\n                a2 *= p2[i];\n            }\n        }\n        benchmark::DoNotOptimize(a1);\n        benchmark::DoNotOptimize(a2);\n        benchmark::ClobberMemory();\n    }\n    state.SetItemsProcessed(N*state.iterations());\n}\n\nBENCHMARK(always_true)-\u003eArg(1\u003c\u003c22);\n\nBENCHMARK_MAIN();\n\n```\n\n**Benchmark result:**\n```shell\nRun on (12 X 4467.28 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x6)\n  L1 Instruction 32 KiB (x6)\n  L2 Unified 512 KiB (x6)\n  L3 Unified 32768 KiB (x1)\nLoad Average: 0.26, 0.35, 0.45\n\n------------------------------------------------------------------------------\nBenchmark                    Time             CPU   Iterations UserCounters...\n------------------------------------------------------------------------------\nalways_true/4194304    1741613 ns      1734898 ns          430 items_per_second=2.41761G/s\n\n```\n\n### 1.b. random -\u003e 50/50 if branch vs else branch\n\n```cpp\n\n#include \"benchmark/benchmark.h\"\n\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\nstatic void random(benchmark::State\u0026 state) {\n    srand(1);\n    const unsigned int N = state.range(0);\n    std::vector\u003cunsigned long\u003e v1(N), v2(N);\n    std::vector\u003cint\u003e c1(N);\n    for (size_t i = 0; i \u003c N; ++i) {\n       v1[i] = rand();\n       v2[i] = rand();\n       c1[i] = rand() \u0026 0x1; // randomly true/false\n    }\n    unsigned long* p1 = v1.data();\n    unsigned long* p2 = v2.data();\n    int* b1 = c1.data();\n    for (auto _ : state) {\n        unsigned long a1 = 0, a2 = 0;\n        for (size_t i = 0; i \u003c N; ++i) {\n            if (b1[i]) {\n                a1 += p1[i];\n            } else {\n                a2 *= p2[i];\n            }\n        }\n        benchmark::DoNotOptimize(a1);\n        benchmark::DoNotOptimize(a2);\n        benchmark::ClobberMemory();\n    }\n    state.SetItemsProcessed(N*state.iterations());\n}\n\nBENCHMARK(random)-\u003eArg(1\u003c\u003c22);\n\nBENCHMARK_MAIN();\n\n```\n\n**Benchmark result:**\n```shell\nRun on (12 X 4467.28 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x6)\n  L1 Instruction 32 KiB (x6)\n  L2 Unified 512 KiB (x6)\n  L3 Unified 32768 KiB (x1)\nLoad Average: 0.26, 0.36, 0.44\n\n-------------------------------------------------------------------------\nBenchmark               Time             CPU   Iterations UserCounters...\n-------------------------------------------------------------------------\nrandom/4194304   12131503 ns     12091002 ns           58 items_per_second=346.895M/s\n```\n\nAs you can see, the mispredicted benchmark is significantly slower. By about 7.7 times. Branch mispredictions are extremely costly.\n\nBut how do we detect when branch misprediction is a problem? By using a cpu profiling tool such as **==perf==**.\n\n### Using perf to detect branch mispredictions.\n\nThe command to run is `perf stat \u003cprogram\u003e`  \nThe result for the 1a the 'always true' program is:  \n```shell\ntask-clock:u                     #    1.000 CPUs utilized\ncontext-switches:u               #    0.000 /sec\ncpu-migrations:u                 #    0.000 /sec\npage-faults:u                    #   58.862 K/sec\ncycles:u                         #    4.217 GHz                      (83.30%)\nstalled-cycles-frontend:u        #    1.63% frontend cycles idle     (83.35%)\nstalled-cycles-backend:u         #    0.17% backend cycles idle      (83.35%)\ninstructions:u                   #    3.68  insn per cycle\n                          #    0.00  stalled cycles per insn  (83.34%)\nbranches:u                       #    4.399 G/sec                    (83.35%)\nbranch-misses:u                  #    0.00% of all branches          (83.31%)\n```\n\n0% (or usually close to that) branch-misses. Compare that to 1b.\n\n```shell\ntask-clock:u                     #    1.000 CPUs utilized\ncontext-switches:u               #    0.000 /sec\ncpu-migrations:u                 #    0.000 /sec\npage-faults:u                    #   52.165 K/sec\ncycles:u                         #    4.258 GHz                      (83.30%)\nstalled-cycles-frontend:u        #    0.87% frontend cycles idle     (83.31%)\nstalled-cycles-backend:u         #    0.00% backend cycles idle      (83.31%)\ninstructions:u                   #    0.88  insn per cycle\n                          #    0.01  stalled cycles per insn  (83.33%)\nbranches:u                       #    1.078 G/sec                    (83.40%)\nbranch-misses:u                  #   12.16% of all branches          (83.35%)\n```\n\n12% branch-misprediction. With the context of the second perf result, you can see that ==instructions per cycle== is also massively down from 3.68 -\u003e 0.88.  \n\n### 1.c. alternating if branch and else branch -\u003e predictable branching\n\n```cpp\n\n#include \"benchmark/benchmark.h\"\n\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\nstatic void alternating(benchmark::State\u0026 state) {\n    srand(1);\n    const unsigned int N = state.range(0);\n    std::vector\u003cunsigned long\u003e v1(N), v2(N);\n    std::vector\u003cint\u003e c1(N);\n    for (size_t i = 0; i \u003c N; ++i) {\n        v1[i] = rand();\n        v2[i] = rand();\n        if (i == 0) c1[i] = rand() \u003e=0;\n        else c1[i] = !c1[i-1]; // alternate true and false\n    }\n    unsigned long* p1 = v1.data();\n    unsigned long* p2 = v2.data();\n    int* b1 = c1.data();\n    for (auto _ : state) {\n        unsigned long a1 = 0, a2 = 0;\n        for (size_t i = 0; i \u003c N; ++i) {\n            if (b1[i]) {\n                a1 += p1[i];\n            } else {\n                a2 *= p2[i];\n            }\n        }\n        benchmark::DoNotOptimize(a1);\n        benchmark::DoNotOptimize(a2);\n        benchmark::ClobberMemory();\n    }\n    state.SetItemsProcessed(N*state.iterations());\n}\n\nBENCHMARK(alternating)-\u003eArg(1\u003c\u003c22);\n\nBENCHMARK_MAIN();\n\n```\n**Benchmark result:**\n```shell\nRun on (12 X 4467.28 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x6)\n  L1 Instruction 32 KiB (x6)\n  L2 Unified 512 KiB (x6)\n  L3 Unified 32768 KiB (x1)\nLoad Average: 0.89, 0.46, 0.42\n------------------------------------------------------------------------------\nBenchmark                    Time             CPU   Iterations UserCounters...\n------------------------------------------------------------------------------\nalternating/4194304    2529638 ns      2523583 ns          280 items_per_second=1.66204G/s\n```\n\n**Perf result:**\n```shell\ntask-clock:u                     #    0.999 CPUs utilized\ncontext-switches:u               #    0.000 /sec\ncpu-migrations:u                 #    0.000 /sec\npage-faults:u                    #   57.934 K/sec\ncycles:u                         #    4.229 GHz                      (83.30%)\nstalled-cycles-frontend:u        #    0.74% frontend cycles idle     (83.32%)\nstalled-cycles-backend:u         #    0.22% backend cycles idle      (83.31%)\ninstructions:u                   #    2.39  insn per cycle\n                          #    0.00  stalled cycles per insn  (83.34%)\nbranches:u                       #    3.029 G/sec                    (83.39%)\nbranch-misses:u                  #    0.00% of all branches          (83.34%)\n```\n\nWith an alternating pattern, you can see that it is slower than the 'alway true' program, but faster than the horribly mispredicted one. 440 vs 58 vs 280.  \n\nThe branch-misses are also at 0%. The CPU figured out the pattern!  \n\n### 2.a. Predictable result, unpredictable branch\n\nThis is a case where you have an || condition.\n```cpp\n\n#include \"benchmark/benchmark.h\"\n\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\nstatic void random_predictable(benchmark::State\u0026 state) {\n    srand(1);\n    const unsigned int N = state.range(0);\n    std::vector\u003cunsigned long\u003e v1(N), v2(N);\n    std::vector\u003cint\u003e c1(N);\n    std::vector\u003cint\u003e c2(N);\n    for (size_t i = 0; i \u003c N; ++i) {\n        v1[i] = rand();\n        v2[i] = rand();\n        c1[i] = rand() \u0026 0x1;\n        c2[i] = !c1[i];\n    }\n    unsigned long* p1 = v1.data();\n    unsigned long* p2 = v2.data();\n    int* b1 = c1.data();\n    int* b2 = c2.data();\n    for (auto _ : state) {\n        unsigned long a1 = 0, a2 = 0;\n        for (size_t i = 0; i \u003c N; ++i) {\n            if (b1[i] || b2[i]) {\n                a1 += p1[i];\n            } else {\n                a2 *= p2[i];\n            }\n        }\n        benchmark::DoNotOptimize(a1);\n        benchmark::DoNotOptimize(a2);\n        benchmark::ClobberMemory();\n    }\n    state.SetItemsProcessed(N*state.iterations());\n}\n\nBENCHMARK(random_predictable)-\u003eArg(1\u003c\u003c22);\n\nBENCHMARK_MAIN();\n\n```\n\nthe 'if' condtion is always true as b1 is true when b2 isn't and viceversa. Although the result is predictable, the branch taken is not. This is because the branch is either through b1 or b2. Here are the benchmark results  \n\n```shell\nRunning ./02-random_predictable\nRun on (12 X 4467.28 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x6)\n  L1 Instruction 32 KiB (x6)\n  L2 Unified 512 KiB (x6)\n  L3 Unified 32768 KiB (x1)\nLoad Average: 0.42, 0.54, 0.54\n-------------------------------------------------------------------------------------\nBenchmark                           Time             CPU   Iterations UserCounters...\n-------------------------------------------------------------------------------------\nrandom_predictable/4194304   12137243 ns     12055659 ns           58 items_per_second=347.912M/s\n\ntask-clock:u                     #    1.000 CPUs utilized\ncontext-switches:u               #    0.000 /sec\ncpu-migrations:u                 #    0.000 /sec\npage-faults:u                    #   65.941 K/sec\ncycles:u                         #    4.206 GHz                      (83.30%)\nstalled-cycles-frontend:u        #    0.85% frontend cycles idle     (83.30%)\nstalled-cycles-backend:u         #    0.45% backend cycles idle      (83.30%)\ninstructions:u                   #    1.01  insn per cycle\n                          #    0.01  stalled cycles per insn  (83.36%)\nbranches:u                       #    1.195 G/sec                    (83.39%)\nbranch-misses:u                  #   10.82% of all branches          (83.35%)\n```\n\nAs you can see the iterations value is down to 58 and branch-misses is up to 10.82%. Even though the result is the same every time.  \n\nHow can we optimise this?\n\n### 2.b. bitwise optimisation\nHere I will use addition. You can also use logical 'or'.\n```cpp\n\n#include \"benchmark/benchmark.h\"\n\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\nstatic void bitwise(benchmark::State\u0026 state) {\n    srand(1);\n    const unsigned int N = state.range(0);\n    std::vector\u003cunsigned long\u003e v1(N), v2(N);\n    std::vector\u003cint\u003e c1(N);\n    std::vector\u003cint\u003e c2(N);\n    for (size_t i = 0; i \u003c N; ++i) {\n        v1[i] = rand();\n        v2[i] = rand();\n        c1[i] = rand() \u0026 0x1;\n        c2[i] = !c1[i];\n    }\n    unsigned long* p1 = v1.data();\n    unsigned long* p2 = v2.data();\n    int* b1 = c1.data();\n    int* b2 = c2.data();\n    for (auto _ : state) {\n        unsigned long a1 = 0, a2 = 0;\n        for (size_t i = 0; i \u003c N; ++i) {\n            if (bool(b1[i]) + bool(b2[i])) {\n                a1 += p1[i];\n            } else {\n                a2 *= p2[i];\n            }\n        }\n        benchmark::DoNotOptimize(a1);\n        benchmark::DoNotOptimize(a2);\n        benchmark::ClobberMemory();\n    }\n    state.SetItemsProcessed(N*state.iterations());\n}\n\nBENCHMARK(bitwise)-\u003eArg(1\u003c\u003c22);\n\nBENCHMARK_MAIN();\n```\n\nThe results:  \n```shell\nRunning ./02-bitwise\nRun on (12 X 4467.28 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x6)\n  L1 Instruction 32 KiB (x6)\n  L2 Unified 512 KiB (x6)\n  L3 Unified 32768 KiB (x1)\nLoad Average: 0.69, 0.50, 0.51\n\n--------------------------------------------------------------------------\nBenchmark                Time             CPU   Iterations UserCounters...\n--------------------------------------------------------------------------\nbitwise/4194304    2113774 ns      2097247 ns          337 items_per_second=1.99991G/s\n\n\ntask-clock:u                     #    1.000 CPUs utilized\ncontext-switches:u               #    0.000 /sec\ncpu-migrations:u                 #    0.000 /sec\npage-faults:u                    #   73.555 K/sec\ncycles:u                         #    4.164 GHz                      (83.33%)\nstalled-cycles-frontend:u        #    1.04% frontend cycles idle     (83.33%)\nstalled-cycles-backend:u         #    0.36% backend cycles idle      (83.33%)\ninstructions:u                   #    4.60  insn per cycle\n                          #    0.00  stalled cycles per insn  (83.33%)\nbranches:u                       #    3.419 G/sec                    (83.33%)\nbranch-misses:u                  #    0.00% of all branches          (83.35%)\n```\n\nHere you can see branch-misses are down to 0% again and iterations are up from 58 to 337.\n\n**Bear in mind,** the optimisation is that instead of evaluating both conditions separately, you calculate both and then check both at the same time. This means you are doing more instructions. ==That is the tradeoff==. This can be important if you, for example, battery life is important to you.  \n\nAdditionally, if the result was not predictable, this would also instead be a performance hit.\n\n### 3.a. Branched unpredictable\nExperiment 3 will consist of taking a loop with 1 branch and showing how we can eliminate the branch completely. The first case is then the branched example.\n\n```cpp\n\n#include \"benchmark/benchmark.h\"\n\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\nstatic void branched_unpredictable(benchmark::State\u0026 state) {\n    srand(1);\n    const unsigned int N = state.range(0);\n    std::vector\u003cunsigned long\u003e v1(N), v2(N);\n    std::vector\u003cint\u003e c1(N);\n    for (size_t i = 0; i \u003c N; ++i) {\n       v1[i] = rand();\n       v2[i] = rand();\n       c1[i] = rand() \u0026 0x1;\n    }\n    unsigned long* p1 = v1.data();\n    unsigned long* p2 = v2.data();\n    int* b1 = c1.data();\n    for (auto _ : state) {\n        unsigned long a1 = 0, a2 = 0;\n        for (size_t i = 0; i \u003c N; ++i) {\n            if (b1[i]) {\n                a1 += p1[i] - p2[i];\n            } else {\n                a2 *= p2[i] * p2[i];\n            }\n        }\n        benchmark::DoNotOptimize(a1);\n        benchmark::DoNotOptimize(a2);\n        benchmark::ClobberMemory();\n    }\n    state.SetItemsProcessed(N*state.iterations());\n}\n\nBENCHMARK(branched_unpredictable)-\u003eArg(1\u003c\u003c22);\n\nBENCHMARK_MAIN();\n\n```\n\n**Result:**\n```shell\nRunning ./03-branched-unpredictable\nRun on (12 X 4467.28 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x6)\n  L1 Instruction 32 KiB (x6)\n  L2 Unified 512 KiB (x6)\n  L3 Unified 32768 KiB (x1)\nLoad Average: 0.76, 0.75, 0.63\n\n-----------------------------------------------------------------------------------------\nBenchmark                               Time             CPU   Iterations UserCounters...\n-----------------------------------------------------------------------------------------\nbranched_unpredictable/4194304   13162172 ns     13070350 ns           54 items_per_second=320.902M/s\n\ntask-clock:u                     #    0.999 CPUs utilized\ncontext-switches:u               #    0.000 /sec\ncpu-migrations:u                 #    0.000 /sec\npage-faults:u                    #   51.062 K/sec\ncycles:u                         #    4.230 GHz                      (83.31%)\nstalled-cycles-frontend:u        #    0.87% frontend cycles idle     (83.32%)\nstalled-cycles-backend:u         #    0.20% backend cycles idle      (83.20%)\ninstructions:u                   #    0.88  insn per cycle\n                          #    0.01  stalled cycles per insn  (83.41%)\nbranches:u                       #    1.029 G/sec                    (83.40%)\nbranch-misses:u                  #   11.79% of all branches          (83.36%)\n```\n\n54 iterations, 11.79% branch-misses.\n\n### 3.b. branchless unpredictable\nThis example now shows how we can eliminate the branch completely.\n\n```cpp\n\n#include \"benchmark/benchmark.h\"\n\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\nstatic void branchless_unpredictable(benchmark::State\u0026 state) {\n    srand(1);\n    const unsigned int N = state.range(0);\n    std::vector\u003cunsigned long\u003e v1(N), v2(N);\n    std::vector\u003cint\u003e c1(N);\n    for (size_t i = 0; i \u003c N; ++i) {\n       v1[i] = rand();\n       v2[i] = rand();\n       c1[i] = rand() \u0026 0x1;\n    }\n    unsigned long* p1 = v1.data();\n    unsigned long* p2 = v2.data();\n    int* b1 = c1.data();\n    for (auto _ : state) {\n        unsigned long a1 = 0, a2 = 0;\n        for (size_t i = 0; i \u003c N; ++i) {\n            unsigned long s1[2] = {0, p1[i] - p2[i]};\n            unsigned long s2[2] = {p1[i] * p2[i], 0};\n            a1 += s1[bool(b1[i])];\n            a2 += s2[bool(b1[i])];\n        }\n        benchmark::DoNotOptimize(a1);\n        benchmark::DoNotOptimize(a2);\n        benchmark::ClobberMemory();\n    }\n    state.SetItemsProcessed(N*state.iterations());\n}\n\nBENCHMARK(branchless_unpredictable)-\u003eArg(1\u003c\u003c22);\n\nBENCHMARK_MAIN();\n\n```\n\nWhat we are doing is essentially calculating both branches and storing them in an array. Then using the bool 'b1' as an integer to add both branch results to 'a1' and 'a2'. The key being that s1 and s2 store a '0' value in position 0 and 1 respectively. So how effective is this?\n\n```shell\nRunning ./03-branchless-unpredictable.cpp\nRun on (12 X 4467.28 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x6)\n  L1 Instruction 32 KiB (x6)\n  L2 Unified 512 KiB (x6)\n  L3 Unified 32768 KiB (x1)\nLoad Average: 0.30, 0.40, 0.51\n\n-------------------------------------------------------------------------------------------\nBenchmark                                 Time             CPU   Iterations UserCounters...\n-------------------------------------------------------------------------------------------\nbranchless_unpredictable/4194304    4246080 ns      4207040 ns          166 items_per_second=996.973M/s\n\ntask-clock:u                     #    0.998 CPUs utilized\ncontext-switches:u               #    0.000 /sec\ncpu-migrations:u                 #    0.000 /sec\npage-faults:u                    #   48.458 K/sec\ncycles:u                         #    4.253 GHz                      (83.31%)\nstalled-cycles-frontend:u        #    1.16% frontend cycles idle     (83.34%)\nstalled-cycles-backend:u         #    0.17% backend cycles idle      (83.37%)\ninstructions:u                   #    3.69  insn per cycle\n                          #    0.00  stalled cycles per insn  (83.36%)\nbranches:u                       #    1.301 G/sec                    (83.29%)\nbranch-misses:u                  #    0.00% of all branches          (83.32%)\n```\n\nThe iterations have increased from 54 to 166 and branch-misses are now 0% again.  \n\nNote that the iterations has not increased as drastically as we are actually doing a lot more work, but there is still a significant performance boost.\n\nThis optimisation is effective under two circumstances:\n1. Extra computations are small\n2. Branch is poorly predicted\n\n## Closing thoughts\n\n- Predicted branches are cheap\n- Mispredictions are **very** expensive\n- **ALWAYS** use a profiler to detect optimisation locations.\n- Don't fight the compiler as it can often do the optimisations for you.","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Sources/Effective-C++":{"title":"Effective C++","content":"\nAuthor: [Scott Meyers](Authors/Scott%20Meyers.md)  \nTopics: [Software Engineering](Topics/Software%20Engineering.md)  \n\n---\n\n## Ch1: Accustoming yourself to C++  \n\n### **Item 1:** View C++ as a federation of languages  \nC++ is better understood as a group of related sub-languages. These are:\n- C\n- Object-oriented C++\n- Template C++\n- The STL\n\nThis is important to keep in mind as different sublanguages have different effective strategies and different conventions.\n\n\n### **Item 2:** Prefer consts, enums, and inlines to \\#defines  \nRule could also be called \"Prefer the compiler over the preprocessor\".   \n\n```cpp\n// BAD\n#define ASPECT_RATIO 1.653\n\n// GOOD\nconst double AspectRation = 1.653;\nconst char* const authorName = \"Scott Meyers\";\nconst std::string authorName(\"Scott Meyers\");\n```\n\nThe preprocessor will blindly subsitute ASPECT_RATIO for 1.653 resulting in multple copies in the object code.   \n\n```cpp\n// BAD\n#define CALL_WITH_MAX(a,b) f((a) \u003e (b) ? (a) : (b))\n\n// GOOD\ntemplate\u003ctypename T\u003e\ninline void callWithMax(const T\u0026 a, const T\u0026 b)\n{\n    f(a \u003e b ? a: b);\n}\n```\nFunction like macros can be very error prone. Calling `CALL_WITH_MAX(++a, b)` for example results in a being incremented twice.\n\n\n### **Item 3:** Use const whenever possible  \n- Helps detect usage errors.\n- Using `const` in function declaration is extremely powerful so make use of it. It can refer to the function's return value, the individual parameters or even the function as a whole.\n- Compilers enforce 'bitwise constness' but you should program using 'logical constness'.\n\t- Bitwise constness/Physical: does not modify any of object's data members\n\t- Logical constness: Some data members of an object can be modified but should be in ways the client cannot detect. Achieved using `mutable`. Also considers situations where something is bitwise const, but does not behave const. e.g. the altering of data members by returning non-const references.\n- When const and non-const member functions have similar implementations, avoid duplication by calling const version in the non-const function and using `const_cast`.\n\n\n### **Item 4:** Make sure objects are initialised before use\nThe rules about when objects initialisation is guaranteed or not is too complicated to be worth memorising. Avoid the issue by ==always initialising==. \n- For non-member built in types, this needs to be done manually. e.g. `int x = 0;`\n- For the rest, initialisation is the responsibility of the constructors and the use of initialisation list is preferred.\n\n\n## Ch2: Constructors, destructors and assignment operators  \n\n### **Item 5:** Know what functions C++ silently writes and calls\nCompilers will declare the following if you do not do so yourself:\n- Copy constructor\n- Copy assignment operator\n- Destructor\n\nIf no constructors are declared at all, compilers will also declare:\n- Default constructor\n\n### **Item 6:** Explicitly disallow the use of compiler-generated functions you do not want\nAn example of an unwanted generated function is a copy constructor and copy assignment operator for objects that should not be copied.  \n\n```cpp\nHomeForSale h1;\nHomeForSale h2;\nHomeForSale h3(h1); //should not compile\nh1 = h2;            // should not compile\n```\n\nTo achieve this there is a ==well known trick==. Declare the functions private and do not implement them.\n\n```cpp\nclass HomeForSale {\npublic:\n    ...\nprivate:\n    HomeForSale(const HomeForSale\u0026);\n    HomeForSale\u0026 operator=(ocnst HomeForSale\u0026);\n}\n```\n\nThis trick works and generates a link-time error. It is possible to move\nit up to a compile time error by declaring the functions private in a base\nclass designed just to prevent copying.\n\n\u003e[!abstract] Summary\n\u003e- Disallow compiler generated function by declaring the function private and not providing an implementation\n\n### **Item 7:** Declare destructors virtual in polymorphic base classes\nLets say you have a base class `TimeKeeper` and some derivided classes\nthat inherit from it:  \n- AtomicClock\n- WaterClock\n- WristWatch\n\nIf you try to delete a derived class (e.g. WristWatch) with a base class\npointer (TimeKeeper), the results are undefined. Most likely, the derived\nclass parts of the object won't be deleted. This is a good way to leak\nmemory.\n\nSolution is simple: ==give the base class a virtual destructor==.\n\nHowever, when a class is not meant to be used as a base class, making it\nvirtual is usually a bad idea. This is because virtual functions require the\nuse of vptr (\"virtual table pointers\") which increases the size of the type.\nA simple data type that contains two ints, would go from 64bits in size to\n128bits. An increase of 100%. It also makes the object less portable to C.\n\nIf you want to make a class abstract that does not have functions to make\nvirtual, you can just give it a pure virtual destructor. This is because a\nabstract classes are meant to be base classes and base classes should\nhave a virtual destructor.\n\n\u003e [!abstract] Summary\n\u003e - Polymorphic base classes should declare virtual destructors.\n\u003e - Any class with virtual functions should have a virtual destructor.\n\u003e - Classes that aren't base classes should not declare virtual destructors.\n\u003e - Use a pure virtual destructor to make classes abstract that do not have functions\n\n### **Item 8:** Prevent exceptions from leaving destructors  \nC++ allows destructors to emit exceptions but it is heavily discouraged.\nThis is because if an exception is thrown, for example, in a vector\ncontaining 10 widgets, the rest of the widgets still need to be deleted or\nthere will be leak. However, if you then have another exception when\ndeleting the other widgets, now you have two simultaneous exceptions\nwhich results in undefined behaviour.\n\nExample class that closes database connection in destructor:\n```cpp\nclass DBConn {\npublic:\n    ...\n    ~DBConn()\n    {\n        db.close();\n    }\nprivate:\n    DBConnection db;\n}\n```\nThis will cause issues if the call to close results in an exception. The\nexception will be propagated.\n\nThere are two options to fix this:  \n- ==Terminate the program== (e.g. with std::abort()). This is a reasonable solution if the program can no longer run due to the error.\n- ==Swallow the exception==. This is a bad idea as we need to know when something fails.\n\nThe actual ideal solution is to create a function that closes the connection\nin the DBConn interface so the client can react to the exception. Then\nthe backup call to 'close()' can still be placed in the destructor. This may\nseem like it goes against *item 11*, by placing an extra burden on the client,\nhowever it is not as it actually **gives** them a chance to react to the\nexception.\n\n\u003e [!abstract] Summary\n\u003e - Destructors should never emit exceptions.\n\u003e - If a classes clients need to react to exceptions during an operation, offer a regular 'non-destrcutor' function that performs the operation.\n\n### **Item 9:** Never call virtual functions during construction or destruction\nDon't call virtual functions during construction or destruction as they won't\ndo what you expect them to. If they did, it would lead to undefined\nbehaviour.\n\nExample: Say you have a base class `Transaction` that is inherited by a \nclass called `BuyTransaction`. If you have a virtual function in Transaction\nthat is called during construction, it will call the base class version. Not\nthe derived version. This is because the base class is constructed first so\nthe derived members will not have been constructed yet.\n\n\u003e [!abstract] Summary\n\u003e - Don't call virtual functions from constructors or destructors.\n\n### **Item 10:** Have assignment operators return a reference to `this`\nAssignments can be chained together and is right associative.\n```cpp\nint x, y, z;\nx = y = z = 15;\n//equivalent to\nx = (y = (z = 15));\n```\nThis is implemented by assignments returning a reference to it's left hand argument. This is the convention that should be followed.\n\n```cpp\nclass Widget {\npublic:\n    ...\n    Widget\u0026 operator=(const Widget\u0026 rhs)\n    {\n        ...\n        return *this;\n    }\n    ...\n}\n```\n\n\u003e [!abstract] Summary\n\u003e - Have assignment operators return a reference to `*this`\n\n### **Item 11:** Handle assignment to self in operator=.\nThis looks silly but is allowed:\n```cpp\nWidget w;\n...\nw = w;\n```\n``\nIf it's allowed, clients will end up doing it. A less obvious version may look\nlike this:\n```cpp\n// potential assignment to selfs\na[i] = a[j];\n*px = *py;\n```\n\nWhen writing resource managing classes you can fall into the trap of\naccidentally releasing a resource before you're done with it:\n```cpp\nclass Bitmap {...};\nclass Widget{\n    ...\nprivate:\n    Bitmap *pb;\n}\n\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs)\n{\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n}\n```\n\nHere you delete rhs not realising that it is the same as `this`. The\ntraditional fix is this:\n```cpp\n\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs)\n{\n    if (this == \u0026rhs) return *this;\n    \n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n}\n```\nThis is now self-assignment safe but not exception safe. If `new Bitmap`\ncauses an exception, it will still cause issues.\n\nMaking operator= exception-safe also typically also renders it\nself-assignment-safe. It is common to deal with self-assignment issues by\nignoring them and isntead focusing on exception safety. A careful ordering\nof statements can make code exception safe. For example:\n\n```cpp\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs)\n{\n    Bitmap *pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\n    delete pOrig;\n\n    return *this;\n}\n```\n\n\u003e [!tip] Performance Hint  \n\u003e The identity test can still be placed at the top for efficiency, however,\n\u003e consider how often self-assignment occurs. The check is not free. It\n\u003e makes the source code and object bigger and introduces a branch.\n\u003e\n\nAlternative to manual ordering is the \"copy and swap\" technique.\n```cpp\nclass Widget {\n    ...\n    void swap(Widget\u0026 rhs); // exchanges *this and rhs's data\n    ...\n};\n\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs)\n{\n    Widget temp(rhs);\n    swap(temp);\n    return *this;\n}\n```\n\nThe final variation sacrifices some clarity for allowing the compiler to\nsometimes generate more efficient code.\n```cpp\nWidget\u0026 Widget::operator=(Widget rhs) // rhs is a copy of the object\n{\n    swap(rhs);\n\n    return *this;\n}\n```\n\n\u003e [!abstract] Summary  \n\u003e - Make sure operator= can handle self-assignment in a well-behaved\n\u003e manner\n\u003e - Make sure any function operating on more than one object behaves\n\u003e well if two or more of the objects are the same.\n\n### **Item 12:** Copy all parts of an object.\nWell-designed objects contain only two functions that copy objects: the\ncopy constructor and copy assignment operator. Compilers will generate\nthese functions if required and do what you expect them to: copy all the\ndata of the object being copied.\n\nHowever, when you declare your own copy functions, they do not warn you\nwhen your implementation is wrong. You may forget to copy a newly\nadded data member and there will be no warnings.\n\nAnother way that you may run into issues is when using inheritance.\n```cpp\nclass PriorityCustomer:public Customer {\npublic:\n    ...\n    PriorityCustomer(const PriorityCustomer\u0026 rhs);\n    PriorityCustomer\u0026 operator=(const PriorityCustomer\u0026 rhs);\n    ...\nprivate:\n    int priority;\n};\n\nPriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026 rhs)\n: priority(rhs.priority)\n{\n    logCall(\"PriorityCustomer copy constructor\");\n}\n\nPriorityCustomer\u0026\nPriorityCustomer::operator=(const PriorityCustomer\u0026 rhs)\n{\n    logCall(\"PriorityCustomer copy assignment operator\");\n    priority = rhs.priority;\n    return *this;\n}\n```\n\nThis may look fine and appear to be copying everything, however, \ncrucially, they are not copying the data members it inherits from customer.\nThe fix to this would be the following:\n```cpp\n\nPriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026 rhs)\n: Customer(rhs)                 // invoke base class copy ctor\n  priority(rhs.priority)\n{\n    logCall(\"PriorityCustomer copy constructor\");\n}\n\nPriorityCustomer\u0026\nPriorityCustomer::operator=(const PriorityCustomer\u0026 rhs)\n{\n    logCall(\"PriorityCustomer copy assignment operator\");\n    Customer::operator=(rhs);  // assign base class parts\n    priority = rhs.priority;\n    return *this;\n}\n```\n\n\u003e [!warning] Warning  \n\u003e The two copy functions will have similar code but do not call one from\n\u003e the other as it is a non-sensical operation. If you really must, have the\n\u003e two call a third private function such as init().\n\n\u003e [!summary] Summary\n\u003e - Make sure copy functions copy all of an object's data members\n\u003e including the base class parts.\n\u003e - Don't implement one copy function in terms of the other. Put common\n\u003e code in a third function.\n\n## Ch3: Resource management  \n\n### **Item 13:** Use objects to manage resources  \nManaging resources manually is very error prone and should be avoided.\nConsider the following:\n```cpp\nvoid f()\n{\n    Investment * pInv = createInvestment(); // factory function\n    ...                                     // use pInv\n\n    delete pInv;                            // release object\n}\n```\nThis may look reasonable but there are many ways it could fail to delete\n`pInv`. if there is a pre-mature return within the function, control would\nnever reach the delete. Another situation is if `createInvestment()` and\n`delete pInv` were in a loop that then breaks early. When this happens,\nthere will be a leak which will also affect any other resources helf by\n*that* object.\n\nTechnically, carefull programming an avoid this issues, but this is not\nrealistic. As the code is maintained, someone may add a pre-mature return\nwithout realising the consequences. Or someone may add an exception in a\nfunction that did not use exceptions which will then cause a leak.\n\nTo avoid all of this, we can put resources into a resource managing object\nwhich will then free the resources automatically when the destructor is\ncalled.\n\nThe STL has smart pointers that are tailormade for resources that are\ndynamically allocated on the heap and are used only within a single\nblock or function.\n\n```cpp\nvoid f()\n{\n    std::unique_ptr\u003cInvestment\u003e pInv(createInvestment());\n    ...\n}\n```\nThis example demonstrates two critical aspects of using objects to manage\nresources:\n- ==**Resources are acquired and immediately turned over to\nresource-managing objects.**==  The idea that resources are acquired and\nimmediately turned over to a resource managing object is referred to as\n*Resource Acquisition is Initialization*(RAII).\n- ==**Resource-managing objects use their destructors to ensure that\nresources are released.**== Destructors are automatically called when an object\ngoes out of scope so resources are released regardless of how control\nleaves a block.\n\n\u003e [!abstract] Summary  \n\u003e - To prevent leaks, use RAII objects that acquire objects in their\n\u003econstructor and delete them in their destructor\n\u003e- Two most common RAII classes are std::unique_ptr and\n\u003estd::shared_ptr\n\n### **Item 14:** Think carefully about copying behaviour in resource-managing classes  \nNot all resources are heap based. For these resources, unique_ptr and\nshared_ptr are generally inappropriate as resource handlers.\n\nFor example, if you create a RAII  class called `Lock` that unlocks a mutex\nin it's destructor so you never forget to unlock a mutex. What should\nhappen if this object is copied?\n```cpp\nLock ml1(\u0026m);\nLock ml2(ml1);\n```\n\nThere are a few valid options:\n- **Prohibit copying:** In many cases it makes no sense to copy a RAII object.\nIn these situations you should just prohibit it (item 6). This is likely to be\ntrue for an object such as `Lock`.\n- **Reference-count the underlying resource:** Sometimes you may want to\nhold on to a resource until there are no more objects using it. In this\nsituation a copy means that the count of objects referring to the resource\nis incremented. A shared_ptr should be used to implement this behaviour.\nshared_ptr also allows using a custom \"deleter\" where you can specify\na different behaviour (such as unlocking a mutex) instead when the\nreference count goes to 0.\n- **Copy the underlying resource:** Sometimes you can have as many copies\nas you want of a resource. The only reason to have a resource-managing\nclass would be to ensure resources are released. In this case, copying the\nRAII object should also mean copying the resource it wraps. An example\nwould be std::string.\n- **Transfer ownership of the underlying resource:** In rare situations, you\nmay want to ensure that only one RAII object refers to a resource. Here\nyou will want to make sure that a copy means that ownership is\ntransferred.\n\nRemember that copying function will be generated by the compiler so you\nwill need to need to write the custom behaviour yourself.\n\n\u003e [!abstract] Summary  \n\u003e - Copying an RAII object entails copying the resource it manages. The\n\u003e correct behaviour of the RAII object depends on the copying behaviour\n\u003e of the underlying resource.\n\u003e - Common RAII class copying behaviours are: disallowing copy and\n\u003e reference counting. However, there are others.\n\n### **Item 15:** Provide access to raw resources in resource-managing classes  \nResource-managing classes are great but they can't always be fully relied\non. Many APIs refer to the resources directly so from time to time you will\nneed to deal with raw resources.\n```cpp\nint daysHeld(const Investment* pi);\n```\n\nThere are two ways to convert a RAII object to the resource it contains:\nexplicit conversion and implicit conversion.\n\nSmart pointers contain a `get` member function that performs an explicit\nconversion i.e. returns a copy of the raw pointer inside the smart pointer\nobject.\n```cpp\nint days = daysHeld(pInv.get());\n```\n\nAs for implicit conversion, it is a bit more dangerous but can sometimes\nstill be the correct choice. Here is an example of a Font class that\nmanages an underlying FontHandle resource with an implicit conversion\nfunction.\n```cpp\nclass Font {\npublic:\n    ...\n    operator FontHandle() const { return f; }\n    ...\nprivate:\n    FontHandle f;\n};\n\n// explicit conversion used to call changeFontSize\nchangeFontSize(f.get(), newFontSize);\n// implicit conversion version of same code\nchangeFontSize(f, newFontSize);\n```\n\nHowever, now a client might accidentally create a FontHandle when a font\nwas intended.\n```cpp\nFont f1(getFont());\n...\nFontHandle f2 = f1;\n// meant to copy a font object but implicityly converted f1\n// into its underlying FontHandle and then copied that\n```\nNow the same FontHandle is being used in f1 and f2 which will then result\nin a dangling pointer.\n\n\u003e [!abstract] Summary  \n\u003e - APIs often require access to raw resources so RAII classes should\n\u003e offer a way to access the resource it manages.\n\u003e - Access may be explicit or implicit. Explicit is safer but implicit is\n\u003e more convenient.\n\n### **Item 16:** Use the same form in corresponding uses of `new` and `delete`  \n```cpp\nstd::string *stringArray = new std::string[100];\n...\ndelete stringArray;\n```\nThe above code is wrong as you are constructing an array of objects but\ndeleting only 1 object. `new` allocates only enough space for an object and\nthen constructs that object if its a single object. For an array, it also\nincludes the memory required to store information on the size of the array.\nTherefore, when you delete an array, you need to access the information.\nThis can only be done if you tell the compiler that the information is there\nby using `delete []`.\n\n\u003e [!warning] Warning  \n\u003e - Make sure to use same for of `new` in all of your constructors so you\n\u003e know which form to call in the destructor.\n\u003e - Abstain from using array types in `typedefs` so there is no confusion\n\u003e on which form of `delete` to call when using a typedef.\n\n\u003e [!abstract] Summary  \n\u003e - Match the forms of `new` and `delete`. `new` requires a corresponding\n\u003e `delete` and `new []` would require a corresponding `delete []`.\n\n### **Item 17:** Store newed objects in smart pointers in standalone statements  \nConsider a situation where we have a function that returns a priority and\na function that processes a dynamically allocated Widget.\n```cpp\nint priority();\nvoid processWidget(std::shared_ptr\u003cWidget\u003e pw, int priority);\n```\n\nNow consider the following way to call processWidget.\n```cpp\nprocessWidget(std::shared_Ptr\u003cWidget\u003e(new Widget), priority());\n```\n\nThree things need to happen:\n- Call priority()\n- Execute 'new Widget'\n- Call the shared_ptr constructor\n\nCompilers have leeway over which order these things are done. The order\nthey are done could be:\n- Execute 'new Widget'\n- Call priority()\n- Call shared_ptr constructor\n\nThe problem can now be seen. If there is an exception when priority() is\ncalled, the pointer returned from 'new Widget' will be lost and not stored\nin the shared_ptr we used to guard against leaks.\n\nTo prevent this, use a separate statement to create and store the Widget\nresource.\n```cpp\nstd::shared_ptr\u003cWidget\u003e pw(new Widget);\nprocessWidget(pw, priority());\n```\nThe revised code has less leeway to reorder the various components that\nmade the previous 1 line version of these two statements.\n\n\n\u003e [!summary] Summary\n\u003e - Store newed objects in smart pointers in standalone statements.\n\u003e Not doing so can lead to subtle resource leaks if exceptions are thrown.\n\n\n## Ch4: Designs and declarations  \n\n### **Item 18:** Make interfaces easy to use correctly and hard to use incorrectly.  \nIf clients use your code incorrectly, ==your interface is partially to blame==.\nConsider the design below for a Date class:\n```cpp\nclass Date {\npublic:\n    Date (int month, int day, int year);\n    ...\n};\n```\nTwo errors can easily happen:\n- Client passes in day value into month. `Date d(30, 3, 1995);`\n- Client passes in invalid value for month or date. `Date d(3, 40, 1995);`\n\nMany similar client errors can be fixed by using simple wrapper with\nexplicit constructors.\n```cpp\nstruct Day {\n    explicit Day(int d)\n    : val(d) {}\n\n    int val;\n};\nDate::Date(const Month\u0026 m, const Day\u0026 d, const Year\u0026 y);\n```\n\nFull fledged classes for day, month and year would be even better but\neven structs are enough to show that introducing types can prevent a\ninterface usage errors.\n\nOnce the right types are being used, you can then progress to limiting the\nvalues of those types if it is reasonable to do so. Enums can be used to do\nthis but they are not as typesafe as we would like as they can be used like\nints.\n\n```cpp\nclass Month {\n    static Month Jan() { return Month(1); }\n    static Month Feb() { return Month(2); }\n    ...\n}\nDate d(Month::Mar(), Day(30), Year(1995));\n```\n\n\u003e [!tip] Hint  \n\u003e This item was probably written before scoped enums (enum classes)\n\u003e were available. Now you probably could replace this with enum classes.\n\n*Another way to prevent client errors is to add const.* For example you\ncan const qualify operator* which can prevent this error  \n`if (a * b = c)...`  \nThis is an assignment when it should have been a comparison.\n\n*Try to make your interfaces behave consistently as possible.* Consistency\nis one of the most important characteristic to making easy to use\ninterfaces. Conversely, inconsistency leads to aggravating interfaces\n\n*Any interface that relies on the client to remember to do something is\nprone to incorrect use, because clients cant forget to do it.* An example\nis returning raw pointers.  \n`Investment* createInvestment();`  \nThis function creates the opportunity for two errors: not deleting the\npointer and deleting it twice. This can be avoided by returning a smart\npointer in the first place.  \n`std::shared_ptr\u003cInvestment\u003e createInvestment();`  \nIn fact shared_pt also make sit possible to get rid of other errors with the\nability to specify a custom release function (deleter). It can also get rid\nof the cross-DLL problem. This is a problem where an object is created\nusing `new` in one DLL but is deleted in a different DLL. shared_ptr gets\nrid of this as its default deleter uses `delete` from the same DLL where\nshared_ptr is created.\n\n\u003e [!abstract] Summary  \n\u003e - Strive to create interfaces that are easy to use correctly but difficult\n\u003e to use incorrectly.\n\u003e - For correct use: maintain consistency in interfaces and use built-in\n\u003e types for behavioural compatiblity.\n\u003e - For error prevention: create new types, restrict operations on types,\n\u003e constrain object values, and eliminate client resource management\n\u003e responsibilities.\n\u003e - std::shared_ptr supports custom deleters. This prevents cross DLL\n\u003e problem and can be used to automatically unlock mutexes.\n\n### **Item 19:** Treat class design as type design.  \nLook at class designing as type designing. This means as a C++ developer\nyou are a *type designer*. Designing good classes is a challenge because\ndesigning good types are a challenge.\n\nTo understand the issues you face which will help you design your type\nyou should consider the following questions:\n- How should objects of your new type be created and destroyed?\n- How should object initialisation differ from object assignment?\n- What does it mean for objects of your new type to be passed by value?\n- What are the restrictions on legal values of your new type?\n- Does your new type fit into an inheritance graph?\n- What kind of type conversion are allowed for your new type? - consider\nimplicit and explicit conversions. You may need conversion functions if you\nare looking to make it explicit only.\n- What operators and functions make sense for the new type?\n- What standard functions should be disallowed? - declare them private or\ndelete them(C++11).\n- Who should have access to the members of your new type?\n- What is the \"undeclared interface\" of your new type? - what guarantees\ndoes it offer with respect to performance, exception safety and resource\nusage.\n- How general is your new type?\n- Is a new type really what you need? - if it's a family of types, you\nmight want a class template.\n\n\u003e [!abstract] Summary  \n\u003e Class design is type design. When designing a new type, consider all 12\n\u003e questions listed in this item.\n\n\n### **Item 20:** Prefer pass-by-reference-to-const to pass-by-value.  \nC++ passes by value by default - function parameters are initialised with\ncopies of the actual argument and function callers get back a copy of the\nreturned value. These copies are produced by the objects copy constructor\nwhich makes it an expensive operation.\n\nConsider the following:  \n```cpp\nclass Person {\npublic:\n    Person();\n    virtual ~Person();\n    ...\nprivate:\n    std::string name;\n    std::string address;\n};\n\nclass Student: public Person {\npublic:\n    Student();\n    virtual ~Student();\n    ...\nprivate:\n    std::string schoolName;\n    std::string schoolAddress;\n};\n\n// function declaration\nbool validateStudent(Student s);\n\nStudent plato;\nbool platoIsOk = validateStudent(plato);\n```\n\nWhen the validateStudent function is called the cost is 1 call to the\ncopy constructor to initialise the parameter and one call to the destructor\nwhen the function returns. Furthermore, the strong objects are also copied\nand destroyed. With construction and destruction of the 4 strings\naccounted for, ther are 6 calls to constructors and destructors.\n\nPass by reference-to-const solves this. The const is essential as\npreviously the callers were shielded from any changes happening to the\nStudent object as it was a copy. Now that it is a reference, const is\nrequired to provide that assurance.\n\nPassig parameters by reference also prevents the *slicing problem*. This is\nwhen you pass a derived class into a function that accepts the base class.\nIf you do this by value, the base class constructor will be called and the\nderived class part of the object will not be copied. Then when you call the\nfunction that may have been overriden in the derived class, the base class\nversion will be called.\n\nIf you pass by reference (or pointer) the object will behave like the actual\nobject that is passed in.\n\nReferences are implemented as pointers under the hood of a C++ compiler.\nThis means that for built-in types (e.g.int) it is reasonable to choose to\npass-by-value.\n\nBuilt-in types are small which can lead people to conclude that small types\ncan be good pass-by-value candidates. However, there are a few reasons\nthat this should not be done. Small types can sometimes be only small\nas they contain only a pointer, however, the object that the pointer points\nto might then be expensive to copy. Another reason is that compilers will\ntreat built-in types differently to user-defined types. For example,\ncompilers can refuse to put user-defined types that consist of just a\ndouble in the register even if it will do so with a naked double. Finally,\nuser-defined types might change in the future so something that is small\nnow can increase in size later.\n\n==Generally, only built-in types, STL iterators and function object types can\nreasonably be assumed as good pass-by-value candidates==.\n\n\u003e [!abstract] Summary  \n\u003e - Prefer pass-by-reference-to-const over pass-by-value for efficiency\n\u003e and to sidestep the slicing problem.\n\u003e - The exceptions to the rule are built-in types, STL iterators and\n\u003e function object types.\n\n### **Item 21:** Don't try to return a reference when you must return an object.  \nDo not be over zealous in the pursuit of eliminating the 'evil' of\npass-by-value. This can lead to passing references of objects that do not\nexist.\n\nConsider a class representing rational numbers.\n```cpp\nclass Rational {\npublic:\n    Rational(int numerator = 0,\n             int denominator = 1);\n    ...\nprivate:\n    int n, d;\nfriend:\n    const Rational\n      operator*(const Rational\u0026 lhs,\n                const Rational\u0026 rhs);\n};\n```\n\nThe `operator*` function returns the result object by value. The question is,\ncan you avoid the cost of the object's deconstruction and construction?\n\nExample scenario:\n```cpp\nRational a(1,2); // 1/2\nRational b(3,5); // 3/5\n\nRational c = a * b; // 1/2 x 3/5 = 3/10\n```\n\nIt may be tempting to consider the following implementation:\n```cpp\nconst Rational\u0026 operator*(const Rational\u0026 lhs,\n                          const Rational\u0026 rhs)\n{\n    Rational result(lhs.n * rhs.n, lhs.d * rhs.d);\n    return result; // returns a reference\n}\n```\nThis is useless as the constructor and deconstructor is still being called.\nMore crucially though, the function returns a reference to a local object\nwhich will immediately go out of scope and we are in undefined territory.\n\nNow you might consider returning a reference to an object on the heap.\nYet again, this would be bad. You still have to pay for the constructor, but\nnow the client needs to remember to delete the newed object. And even if\nthey are, how do they handle a situation like this:  \n```cpp\nRational w, x, y, z;\nw = x * y * z;\n```\nThere are two calls to operator* but now way to delete the first call. This\nis a guaranteed resource leak.\n\nUsing a static 'result' object is also a no go. It will run into problems with\nsituations like this:\n```cpp\nRational a, b, c, d;\nif ((a * b) == (c * d))\n    ...\n```\nThis will always be true as there are two active calls to operator* when\noperator== is called. They will always be equal as they share the static\nresult object.\n\nThe right answer is simply something such as:\n```cpp\ninline const Rational operator*(const Rational\u0026 lhs,\n                                const Rational\u0026 rhs)\n{\n    return Rational(lhs.n * rhs.n, lhs.d * rhs.d);\n}\n```\n\n\u003e [!abstract] Summary  \n\u003e Never return a pointer or reference to a local stack object, a reference\n\u003e to a heap-allocated object, or a pointer or reference to a local static\n\u003e object if there is a chance that more than one such object will be\n\u003e needed.\n\n### **Item 22:** Declare data members private.  \nThe case for this item will follow this format: highlight why public data\nmembers is bad -\u003e highlight why all the arguments also apply to protected\nmembers -\u003e conclude that private is the way to go.\n\nIf everything in the public interface is a function, clients won't have to\nrecall whether to use parantheses to access members or not. Consistency.\n\nFunctions provide fine-grained control over the accessiblity of it's data\nmembers.\n\nFinally, encapsulation. If access to a data member is via a function, it is\npossible to then later replace the data member with a computation and your\nclients will not be aware or need to be aware at all.\n\nA quick example is a class that contains speed data:\n```cpp\nclass SpeedDataCollection {\n    ...\npublic:\n    void addValue(int speed);\n    double averageSoFar() const;\n    ...\n}\n```\nYou can use an approach that maintains a data member that contains the\nrunning average and the `averageSoFar()` function just returns this value OR\nan approach where the `averageSoFar()` is calculated from all the stored\nvalues whenever it is called. One has better performance on\n`averageSoFar()` at the cost of space and the other has worse performance\nbut doesn't take as much space.  \nWith encapsulation, you can interchange these easily.\n\n==Encapsulation is more valuabled than it might initially appear==. If data\nmembers are hidden, class invariants can be maintained. This has benefits\nwhen it comes to threaded environments as well. ==Hiding details is like\nreserving the right to change the implementation details at a later date==.\nYou will realise that even if you own the source code to a class, your\nability to change anything public will be severely limited.\n\n*The argument for protected members is identical*. This is because\nsomethings encapsulation is inversely proportional to the amount of code\nthat could break if that something changes. For public members this can\nbe 'all client code' which is an unknowably large amount. How about for\nprotected members? The answer is 'all the derived classes that access it'\nwhich is yet again an unknowably large amount of code.\n\n==Essentially there are two levels of access: private and everything\nelse.==\n\n\u003e [!abstract] Summary  \n\u003e - Declare data members private.\n\u003e - Protected is no more encapsulated than private.\n\n### **Item 23:** Prefer non-member non-friend functions to member functions.  \nConsider a web browser class which may have functions to manage the\ncache, history and cookies:\n```cpp\nclass WebBrowser {\npublic:\n    ...\n    void clearCache();\n    void clearHistory();\n    void removeCookies();\n    ...\n};\n```\n\nNow consider two ways of implementing a function that combines all three.\n```cpp\nclass WebBrowser {\n    public:\n    ...\n    void clearEverything();\n    ...\n};\n\nvoid clearBrowser(WebBrowser\u0026 wb) // non-member function\n{\n    wb.clearCache();\n    wb.clearHistory();\n    wb.removeCookies();\n}\n```\n\nWhich is better? The member or non-member function? A misunderstanding\nof object oriented principles may lead people to conclude that data and\nfunctions that operate on them should be bundled together. This is wrong.\nObject oriented principles dictate that data should be as *encapsulated* as\npossible.\n\nThe greater something is encapsulated, the greater our ability to change\nit. Adding another member function increases the public functions that\naccess the private data members. In the example it would go from 3 to 4.\nHowever, the non-member function does not affect the number of\nfunctions that can access the private parts of the class. Therefore, it is\nmore encapsulated with a non-member function.\n\nA way to 'bundle' convenience/utility functions without affecting\nencapsulation is to use namespaces. This is a very flexible approach as\nconvenience functions can be spread out over different files but in the\nsame namespace. Clients can then selectively `#include` only the parts\nthat they require. It also allows for easy extensibility by the clients\nor by the writers in future.\n\n\u003e [!abstract] Summary  \n\u003e Prefer non-member non-friend fucntions to member functions. Doing so\n\u003e increases encapsulation, packaging flexibility, and functional\n\u003e extensibility.\n\n### **Item 24:** Declare non-member functions when type conversions should apply to all parameters.  \nClasses supporting implicit type conversions is generally a bad idea,\nhowever there are exceptions. A common exception is for numerical types.\n\nConsider a `Rational` class:\n```cpp\nclass Rational {\npublic:\n    Rational(int numerator = 0, int denominator = 1);\n    int numerator() const;\n    int denominator() const;\nprivate:\n    ...\n};\n```\n\nNext lets say you want to support multiplication of Rational numbers. The\nquestion is should it be implemented as a member function, non-member\nfunction or non-member function that are friends.\n\nWell lets consider the member function version:\n```cpp\nclass Rational {\npublic:\n    ...\n    const Rational operator*(const Rational\u0026 rhs) const;\n};\n```\n\nThis design allows for the following:\n```cpp\nRational oneEighth(1,8);\nRational oneHalf(1,2);\n\nRational result = oneHalf *oneEighth;  //fine\nresult = result * oneEighth;           //fine\n```\n\nHowever, you also want to support mixed-mode operations where Rationals\nmight be multiplied with ints for example. Lets see what happens.\n\n```cpp\nresult = oneHalf * 2;       //fine\nresult = 2 * oneHalf;       //error\n```\n\nThe source of the problem is clearer if you rewrite it:\n```cpp\nresult = oneHalf.operator*(2);    //fine\nresult = 2.operator*(oneHalf);    //error\n```\n\noneHalf is an instance of a class containing the operator* where as 2 is\nnot. But then this raises the question, why does it work when you pass\nin an int (2)? This is because of implicit conversion. Compilers can figure\nout that although you are passing an int into a function that requires a\n`Rational`, the int can be use to construct the `Rational` so that's what it\ndoes.\n\nThis means that if the constructor for `Rational` was declared explicit,\nthen it would fail.\n\nAnyhow, the key to the solution of supporting operations both ways around\nis that implicit conversion is only available for parameters that are listed\nin the parameter list. Here is the solution:\n\n```cpp\nclass Rational {\n    ...   // operator* not defined/declared\n};\n\nconst Rational operator*(const Rational\u0026 lhs,\n                         const Rational\u0026 lhs);\n{\n    ...\n}\n\nRational oneFourth(1, 4);\nRational result;\n\nresult = oneFourth * 2;\nresult = 2 * oneFourth;   // both finally working\n```\n\nShould we make this function a friend function? No. It can already achieve\nwhat it needs to do without breaking encapsulation. A function should not\nbe made a friend just because it is 'related' to it.\n\n\u003e [!abstract] Summary  \n\u003e If you need type conversions on all parameters to a function including\n\u003e the one pointed to by `this`, the function must be a non-member.\n\n### **Item 25:** Consider support for a non-throwing swap.  \nSwap is an interesting function that is worth some special consideration.\nHere is a default implementation for swap:\n\n```cpp\nnamespace std {\n    template\u003ctypename T\u003e\n    void swap(T\u0026 a, T\u0026 b)\n    {\n        T temp(a);\n        a = b;\n        b = temp;\n    }\n}\n```\n\nThis default implementation may not thrill you as it involves copying three\nobjects. For some types, none of this copies will be necessary. For types\nlike this, the default swap implementation will slow down your code.\n\nThe most common example for types like these are those consisting\nprimarily of pointers to another type that then contains the real data. A\ncommon manifestation of this design approach is the \"pimpl idiom\"\n(\"pointer to implementation\" - item 31). An example using a Widget class:\n\n```cpp\nclass WidgetImpl {\npublic:\n    ...\nprivate:\n    int a, b,c;             //possibly lots of data\n    std::vector\u003cdouble\u003e v;  //expensive to copy\n};\n\nclass Widget {\npublic:\n    Widget(const Widget\u0026 rhs);\n    Widget\u0026 operator=(ocnst Widget\u0026 rhs)\n    {\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    }\n    ...\nprivate:\n    WidgetImpl *pImpl;\n};\n```\n\nIn this example, all we need to do to swap Widget objects is to swap\ntheir underlying `pImpl` pointers. However, the default swap function does\nnot know this. It would result in copy three widgets and ALSO three\nWidgetImpl objects. Very inefficient.\n\nWe would like to tell std::swap how to more efficiently handle the swap.\n```cpp\nnamespace std {\n    template\u003c\u003e\n    void swap\u003cWidget\u003e(Widget\u0026 a, Widget\u0026 b)\n    {\n        swap(a.pImpl, b.pImpl);  // wont compile. private ptrs\n    }\n}\n```\nThe \"template\u003c\u003e\" at the begining of the fucntion says that this is a *total\ntemplate specialisation* for std::swap and the \"\u003c Widget \u003e\" after the name\nof the function says that the specialisation is for when T is Widget.\n\nIn general, we are not permitted to alter contents of the std namespace,\nbut we are allowed to totally specialise standard template for our own\ntypes.\n\nThe above code won't compile due to `pImpl` being private. We could make\nthe specialisation a friend, but the convention is to declare a public\nmember function calle dswap that does the actual swapping, then\nspecialise the std::swap to call the member function.\n\n```cpp\nclass Widget {\npublic:\n    ...\n    void swap(Widget\u0026 other)\n    {\n        using std::swap; //need for this explained below\n        swap(pImpl, other.pImpl);\n    }\n    ...\n};\nnamespace std {\n    template\u003c\u003e\n    void swap\u003cWidget\u003e(Widget\u0026 a, Widget\u0026 b)\n    {\n        a.swap(b);\n    }\n}\n```\n\nThis compiles AND is consistent with the STL containers.\n\nBut what if `Widget` and `WidgetImpl` were class *templates* instead of\nclasses. Putting a swap member function in Widget is as easy as before.\nThe trouble arises with the specialisation. We 'want' to write:\n```cpp\nnamespace std {\n    template\u003ctypename T\u003e\n    void swap\u003cWidget\u003cT\u003e \u003e (Widget\u003cT\u003e\u0026 a,\n                           Widget\u003cT\u003e\u0026 b)\n    {a.swap(b);}\n}\n```\n\nThis looks reasonable but is illegal code. C++ supports partial \nspecialisation for classes but not function templates. To partially\nspecialise a function template, the usual approach is to simply use an\noverload.\n```cpp\nnamespace std {\n    tempalte\u003ctypename T\u003e\n    void swap(Widget\u003cT\u003e\u0026 a, Widget\u003cT\u003e\u0026 b)\n    {a.swap(b);}\n}\n```\n\nIn general this would be fine, but the std namespace is special. You can\ntotally specialize templates in std, but you can't add new templates (or\nclasses or functions or anything else). If you break this rule, you are\nonce again in the land of `undefined`.\n\nSo what do we actually do? We still declare a non-member swap that calls\nthe member swap, we just don't declare the non-member to be a\nspecialisation or overloading of std::swap.\n\n```cpp\nnamespace WidgetStuff {\n    ...\n    template\u003ctypename T\u003e\n    class Widget{...};\n    ...\n\n    template\u003ctypename T\u003e\n    void swap(Widget\u003cT\u003e\u0026 a, Widget\u003cT\u003e\u0026 b)\n    { a.swap(b); }\n}\n```\n\nNow, if any code anywhere calls swap on two Widget objects, the name \nlookup rules in C++ will find the Widget-specific version in WidgetStuff.\n\nThis approach works as well for classes as for class templates, so it \nseems like we should use it always. Unfortunately, there is a special\nreason for specialising std::swap for classes, so if you want to have\nyour class specific swap be called in as many contexts as possible\n(which you definitely do), you need to write a non-member version in\nthe same namespace as your class AND a specialisation of std::swap.\n\nThe above is for `swap` authors but we should consider one thing for th\nclients.\n```cpp\ntemplate\u003ctypename T\u003e\nvoid doSomething(T\u0026 obj1, T\u0026 obj2)\n{\n    ...\n    swap(obj1, obj2);\n    ...\n}\n```\nWhich swap does this call? The general one in std? or the specialisation of\nthe std? or a T-specific one? What you want to do is try to use the\nT-specific one, but if not fall back on the general std::swap.  \nHeres how you can do this:\n```cpp\ntemplate\u003ctypename T\u003e\nvoid doSomething(T\u0026 obj1, T\u0026 obj2)\n{\n    using std::swap;        // make std::swap available\n    ...\n    swap(obj1, obj2);       // call best swap\n    ...\n}\n```\n\nThe C++ lookup rules will ensure the best swap is called so don't worry\ntoo much. Just remember not to qualify it:\n`std::swap(obj1, obj2);`  \nQualifying swap does happen, that's why it's in your best interest to aslo\nimplement the specialised version.\n\n\u003e [!abstract] Summary  \n\u003e - Provide a swap member function when std::swap would be \n\u003e infefficient for your type. Make sure swap does not throw exceptions.\n\u003e - If you offer a member swap, make sure to also offier a non-member\n\u003e swap that calls the member. For classes (not templates), specialise\n\u003e std::swap too.\n\u003e - When calling swap, employ a using declaration for std::swap, then\n\u003e call swap without namespace qualification.\n\u003e - It's fine to totally specialise std templates for user-defined type,\n\u003e but never try to add something completely new to std.\n\n## Ch5: Implementations  \nThe lion's share of the battle is coming up with appropriate definitions for\nyour classes and appropriate declarations for your functions. However,\nthere are still implementation details to look out for.\n\n### **Item 26:** Postpone variable definitions as long as possible.  \nDefining a variable of a type with a constructor or destructor incurs the\ncost of construction and then the cost of destruction when the variable\ngoes out of scope. Due to the inherent cost of using a variable, you want\nto avoid using them if possible.\n\nConsider a function that returns an encrypted version of a password if the\npassword is long enough:\n```cpp\nstd::string encryptPassword(const std::string\u0026 password)\n{\n    using namespace std;\n    string encrypted;\n\n    if (password.length() \u003c MinimumPasswordLength) {\n        throw logic_error(\"Password is too short\");\n    }\n    ...      // encrypted password into encrypted var\n    return encrypted;\n}\n```\n\nThe object encrypted is unused an exception is thrown. Therefore, it's\nbetter if you postpone defining it until you know an exception won't be\nthrown.\n```cpp\nstd::string encryptPassword(const std::string\u0026 password)\n{\n    using namespace std;\n\n    if (password.length() \u003c MinimumPasswordLength) {\n        throw logic_error(\"Password is too short\");\n    }\n    string encrypted;\n    ...      // encrypted password into encrypted var\n    return encrypted;\n}\n```\n\nHowever, even this version isn't tight enough as `encrypted` is defined\nwithout any initialisation arguments. This means it is default constructed\nand then only assigned a value later.\n\nConsider if the hard part of the function was done in this function:  \n`void encrypt(std::string\u0026 s);`  \n\nThe code could then look like this:  \n```cpp\nstd::string encryptPassword(const std::string\u0026 password)\n{\n    ...\n    string encrypted;\n    encrypted = password;\n\n    encrypt(encrypted);\n    return encrypted;\n}\n```\n\nThis leads to a pointless default construction of `encrypted` though. Better\nwould be:  \n```cpp\nstd::string encryptPassword(const std::string\u0026 password)\n{\n    ...\n    string encrypted(password);\n    encrypt(encrypted);\n    return encrypted;\n}\n```\n\n==Not only should you postpone variable definition until right before you\nhave to use the variable, but also until you have the initialisation\nparameters for it.==\n\nBut what about loops?\n```cpp\n// Approach A: define outside loop\nWidget w;\nfor (int i = 0; i \u003c n; ++i) {\n    w = some value dependent on i;\n    ...\n}\n\n// Approach B: define inside loop\nfor (int i = 0; i \u003c n; ++i) {\n    Widget w(some value dependent on i);\n}\n```\n\nThe associated costs are:\n- Approach A: 1 constructor + 1 destructor + n assignments\n- Approach B: n constructors + n destructors\n\nFor classes where assignment is cheaper than constructor/destructor pair,\napproach A is generally more efficient. Otherwise, approach B is probably\nbetter. Default to approach B unless (1) assignment is cheaper than\nctor/dtor pair and (2) you're dealing with performance sensitve area of\ncode.\n\n\u003e [!abstract] Summary  \n\u003e Postpone variable definitons as long as possible. It improves clarity\n\u003e and efficiency.\n\n### **Item 27:** Minimise casting.  \nRules of C++ are designed to guarantee that type errors are impossible.\nHowever, casts subvert the type system. They should not be taken\nlightly.\n\nOld C style casts:\n- `(T) expression`\n- `T(expression)`\nThere is no difference in the meaning between these forms.\n\nNew C++ casts\n- const_cast\u003c T \u003e(expression);\n- dynamic_cast\u003c T \u003e(expression);\n- reinterpret\u003c T \u003e(expression);\n- static_cast\u003c T \u003e(expression);\n\nEach serves a distinct purpose:\n- `const_cast`: cast away constness. The only C++ cast that can do this.\n- `dynamic_cast`: Primarily for \"safe downcasting\" i.e. whether an\nobject is of a particular type in an inheritance hierarchy. e.g. whether\n`shape` can be cast to `triangle`. Cannot be performed in old style cast and\nhas significant runtime cost.\n- `reinterpret_cast`: intended for low-level casts that yield\nimplementation-dependent (unportable) results. e.g. pointer to int. Should\nrarely be used outside of low level code.\n- `static_cast`: Used to force implicit conversions (e.g. non-const to\nconst. int to double etc). It can also be used to perform the reverse\nof many such conversions (e.g. void pointers* to type pointers,\npointer-to-base to pointer-to-derived). Just not const to non-const.\n\nNew style casts are preferrable as they are easier to identify in code and\ntheir narrower usage provides more helpful usage errors.\n\n==Many programmers believe that casts do nothing but tell compilers to\ntreat one type as another==. This is wrong. Type conversions of any kind\ncan lead to code that is executed at runtime.\n\n```cpp\nint x, y;\n...\ndouble d = static_cast\u003cdouble\u003e(x) / y;\n```\nThis code almost certainly generates code as the underlying representation\nof a double differs from an int on most architectures. Not too surprising\nbut this may be a bit more unexpected:\n\n```cpp\nclass Base {...};\nclass Derived : public Base {...};\nDerived d;\nBase *pb = \u0026d;\n```\nWe're creating a base class pointer to a derived object, but sometimes\nthe two pointer values will not be the same. When this happens, an offset\nis ==*applied at runtime*== to the Derived* pointer to get the correct Base*\npointer value.\n\nThe last example demonstrates that a single object might have more than\none address (e.g. address when pointed by Base* and address when\npointed by Derived*). This does not happen in C, Java or C#, but it does\nhappen in C++. It happens all the time when multiple inheritance is in use.\nBut it can also happen in single inheritance. ==This means that you should\ngenerally avoid making assumptions about how things are laid out in\nC++ and certainly not make casts based on such assumptions.==\n\n\u003e [!info] Note  \n\u003e An offset is 'sometimes' required. Compiler specific implementation\n\u003e differs. Just because a cast based on assumed layout works on one\n\u003e platform does not mean it will work on another.\n\nCasts make it easy to write code that looks right, but is in fact wrong.\nFor example, often virtual member function implementations are required\nto call their base class counterparts first:\n```cpp\nclass Window {\npublic:\n    virtual void onResize() {...}\n    ...\n};\n\nclass SpecialWindow: public Window {\npublic:\n    virtual void onResize() {\n        static_cast\u003cWindow\u003e(*this).onResize();\n        ...\n    }\n    ...\n};\n```\nIn this code, it may appear to be casting `this`, the current object, into its\nbase class and then calling `onResize()` on it. However, what it does is\ncreates a new, ==temporary copy of the base class== part of `this`, calls\n`Window::onResize` on the copy of the base class part and continues with\nthe function and performs the `SpecialWindow` specific actions on the\ncurrent object.\n\nThe object might now be in an invalid state where the base class\nmodifications have not been made but the derived class parts have been.\nTo handle this properly you should do the following:\n```cpp\nclass SpecialWindow: public Window {\npublic:\n    virtual void onResize() {\n        Window::onResize();\n        ...\n    }\n    ...\n};\n```\n\nIf you are finding yourself wanting to cast, you could be approaching\nthings in the wrong way.\n\n`dynamic_cast` is an extremely costly cast. One common implementation\nis partly based on string comparisons between class names. In an\ninheritance hierarchy of four levels, this would cost 4 calls to `strcmp`. Be\nwary of casts in general, but especially wary of dynamic_casts.\n\nThe need for dynamic_cast usually arises when you want to perform\nderived class operations on what you think is a derived class, but what\nyou have is a pointer-to-base.\n\nThere are two possible solutions to avoid dynamic_casting for this reason:\n- Use containers that store pointers to derived class objects directly.\n- Use virtual functions in the base class that will allow you to do what\nyou need.\n\n\u003e [!abstract] Summary  \n\u003e - Avoid casts whenever practical, especially dynamic_casts. Explore\n\u003e cast-free alternatives if a design requires casting.\n\u003e - If casting is necessary, hide it inside a function.\n\u003e - Prefer C++ style casts to old-style casts. Easier to spot and\n\u003e more specific about what they do.\n\n\n### **Item 28:** Avoid returning \"handles\" to object internals.  \nConsider an implementation of a rectangle class that stores the upper-left\ncorner and lower-right corner. Tok keep the `Rectangle` object small, the\npoints that define it's extent aren't stored in the `Rectangle` itself, but\nan auxiliary struct that the rectangle points to.\n```cpp\nclass Point {\npublic:\n    Point(int x, int y);\n    ...\n    void setX(int newVal);\n    void setY(int newVal);\n};\n\nstruct RectData {\n    Point ulhc;\n    Point lrhc;\n};\n\nclass Rectangle {\n    ...\nprivate:\n    std::shared_ptr\u003cRectData\u003e pData;\n}\n```\n\nBecause the clients of `Rectangle` need to be able to determine the extents\nof a rectangle, there are functions `upperLeft` and `lowerRight`. Because\n`Point` is a user-defined type and it is more efficient to return a reference,\nthese functions return references.\n```cpp\nclass Rectangle {\npublic:\n    ...\n    Point\u0026 upperLeft() const { return pData-\u003eulhc; }\n    Point\u0026 lowerRight() const { return pData-\u003elrhc; }\n    ...\n};\n```\nThe design will compile, but it's wrong. The functions are declared const\nso they are designed to offer clients a way to learn what the points of the\nrectangle are, not to change them. However, since references to internal\ndata members are returned, they can now be changed.\n\n```cpp\nPoint coord1(0, 0);\npoint coord2(100, 100);\n\nconst Rectangle rec(coord1, coord2); // rectangle 0,0 x 100,100\n\nrec.upperLeft().setX(50);  // now rec 50,0 x 100,100\n```\n\nTwo lessons from this example:\n- ==A data member is only as encapsulated as the most accessible\nfunction returning reference to it==\n  - In this example, `ulhc` and `lrhc` are effectively public.\n- ==If a const member function returns a reference to data associated\nwith an object that is stored outside the object itself, the called can now\nchange that data.==\n\nThe example involved references but the same would be true for pointers\nand iterators as they all act as *handlers*.\n\nWe generally think of an object's internals as it's data members ,but \nmember functions not accessible to the general public are also part of\nan object's internals. This means that you should nver have a member\nfunction return a pointer to a less accessible member function.\n\nThe rectable example can be simply solved by adding const to their return\ntypes:\n```cpp\nclass Rectangle {\npublic:\n    ...\n    const Point\u0026 upperLeft() const { return pData-\u003eulhc; }\n    const Point\u0026 lowerRight() const { return pData-\u003elrhc; }\n    ...\n};\n```\nThe clients can now 'read' the points but not 'write' into them.\nHowever, `upperLeft` and `lowerRight` are still returning 'handles' to an\nobject's internals and this can be problematic still. In particular, it can\nlead to 'dangling handles'. Consider:  \n```cpp\nclass GUIObject{\n...\n};\n\n// returns a rectangle by value\nconst Rectangle boundingBox(const GUIObject\u0026 obj);\n\nGUIObject *pgo;\n...\n// get a ptr to upper left point of bounding box\nconst Point *pUpperLeft = \u0026(boundingBox(*pgo).upperLeft());\n```\nHere the call to `boundingBox` returns a rectangle by value. `upperLeft` is\nthen called on this rectangle and the pointer to this `Point` is assigned to\n`pUpperLeft`. Unfortunately, the temporary rectangle object will be\ndestroyed. That will then also leave `pUpperLeft` pointing to a `Point` that\nno longer exists.\n\n\u003e [!abstract] Summary  \n\u003e - Avoid returning handles (references, pointers, or iterators) to\n\u003e object internals. Doing so maximises encapsulation, helps const\n\u003e member functions act const, and minimises the creation of dangling\n\u003e handlers.\n\n### **Item 29:** Strive for exception-safe code.  \nThere are two requirements for exception safety:\n- **Leak no resources**\n- **Don't allow data structures to be corrupted**\n\nConsider a class for representing GUI menus with background images. The\nclass is designed to be used in threaded environments so it has a mutex.\n```cpp\nclass PrettyMenu {\npublic:\n    ...\n    void changeBackground(std::istream\u0026 imgSrc);\n    ...\nprivate:\n    Mutex mutex;\n    Image* bgImage;\n    int imageChanges;\n}\n```\n\nNow here is a possible implementation of the `changeBackground` function:\n```cpp\nvoid PrettyMenu::changeBackground(std::istream\u0026 imgSrc)\n{\n    lock(\u0026mutex);                //acquire mutex\n    delete bgImage;              //get rid of old bg\n    ++imageChanges;              //update image change count\n    bgImage = new Image(imgSrc);  //install new bg\n    unlock(\u0026mutex);              //release mutex\n}\n```\n\nThis function fulfils none of the requirements for exception safety. It leaks\nresources as if `new Image(imgSrc)` throws, the mutex is never unlocked.\nAs for data structure corruption, if `new Image` throws, `bgImage` is now\npointing to a deleted object and also `imageChanges` has been incremented\nwhen the new image has not actually been installed.\n\n*Addressing the resource leak*. To do this we just have to use objects to\nhelp us manage resources.\n```cpp\nvoid PrettyMenu::changeBackground(std::istream\u0026 imgSrc)\n{\n    Lock ml(\u0026mutex);   // item 14. ensures release\n\n    delete bgImage;\n    ++imageChanges;\n    bgImage = new Image(imgSrc);\n}\n```\n\n\u003e [!tip] info  \n\u003e Another good thing about resource management classes is that they\n\u003e usually make functions shorter.\n\n*Now for the data structure corruption.* We now have a choice. Exception\nsafe functions offer ==one of three guarantees.==\n- **Basic guarantee.** If an exception is thrown, everything in the program\nremains in a valid state. No objects or data structures corruped and\ninternal state is consistent. e.g. for `changeBackground` the original\nbackground is kept or a default background is used.\n- **Strong guarantee.** If an exception is thrown, the state of the program\nis left unchanged. The functions are ==atomic==. If they succeed, they \nsucceed they succeed completely, and if they fail ,the program state is\nis as if it was never called at all. Functions offering the 'strong'\nguarantee are easier to work with as after they are called there is only\ntwo possible states: same as before or expected state after successful\ncompletion. With the 'basic' guarantee the function could leave the\nprogram in any valid state.\n- **The nothrow guarantee**. Never throw exceptions as these functions\nalways do what they promise to. All operations on built-in types are\nnothrow. Functions with an empty exception specification *do not* imply\nthat they are nothrow. All it says is that if the function does throw an\nexception, it is a serious error.\n\nException-safe code must offer one of the three guarantees from above.\nIt is not exception-safe if it does not. The choice is only about which\nlevel of exception-safe code to offer as write exception-unsafe code\nwill cause resource leaks and corrupt data structures.\n\nThe general rule is to offer the strongest guarantee that is practical.\nAlthough nothrow guarantee is great, it is difficult to climb out of just the\nC part of C++ whilst guaranteeing it.\n\n*Back to the changeBackground example.* We can do two very simple\nthings to almost provide the strong guarantee.\n```cpp\nclass PrettyMenu {\n    ...\n    std::shared_ptr\u003cImage\u003e bgImage;\n    ...\n};\nvoid PrettyMenu::changeBackgroun(std::istream\u0026 imgSrc)\n{\n    Lock ml(\u0026mutex);\n    bgImage.reset(new Image(imgSrc));\n    ++imageChanges;\n}\n```\nThe two improvements are:\n- Using a shared_ptr to avoid resource leaks.\n- Reorder the statements so that `imageChanges` is only incremented until\nthe image has actually been changed.\n\nThe improvements make it 'almost' strong as it is possible that the\nread marker for input stream 'imgSrc' has been moved.\n\nThere is a general design strategy that typically leads to the strong\nguarantee. ==Copy and swap==. Make a copy of the object you want to\nmodify, make the necessary modifications to the copy. If an exception\nis thrown, the original is left unchanged. After all changes have been\nmade, swap the modified object with the original in a non-throwing\noperation.\n\nThis is usually implemented by putting all the per-object data into a\nseparate implementation object, then giving the real object a pointer\nto its implementation object. This is called the \"pimpl idiom\".\n\nThe ==copy-and-swap== strategy is an excellent way to make all-or-nothing\nchanges to an object's state, but still does not guarantee that the overall\nfunction is strongly exception safe.\n\n```cpp\nvoid someFunc()\n{\n    ...    //make copy of local state\n    f1();\n    f2();\n    ...    //swap modified state into place\n}\n```\n\nIf `f1` or `f2` are less than strongly safe, `someFunc` is almost certainly not\nstrongly safe. But even if they are, `f1` could succeed and `f2` could fail.\nThis means that the state is not the same as if `f1` and `f2` both ran all the\nway successfully. Such issues can prevent you from offering the strong\nguarantee.\n\nAnother issue with 'copy and swap' is efficiency. The strategy requires\ncreating a copy of each object to be modified which takes extra time and\nspace.\n\nIf you are unable to provide the strong guarantee because of limitations\nsuch as these, it is perfectly ok to only provide the weak guarantee. Just\nmake an effort to provide the strong guarantee.\n\n\u003e [!abstract] Summary  \n\u003e - Exception-safe functions ==leak no resource== and ==do not allow\n\u003e data structure corruption==. Even if exceptions are thrown; basic,\n\u003e strong, or nothrow guarantees are provided.\n\u003e - Strong guarantee can be provided via copy-and-swap.\n\u003e - A function can usually offer a guarantee no stronger than the\n\u003e function it itself calls.\n\n### **Item 30:** Understand the ins and outs of linlining.  \nInline functions are a great idea: look like functions, act like functions,\nbut without the overhead of a real function call and without using macros.\n==What more could you ask for?==  \nThey provide even more benefits! Compiler optimisations also work better\nas they are typically designed for long stretches of code that lack function\ncalls.\n\nHowever, nothing in life is free. They increase the size of your object\ncode. This could be a problem on machines with limited memory. Even\nwith virtual memory, code bloat can lead to additional paging, a reduced\ninstruction cache hit rate and the performance penalties these incur.\n\nOn the other hand, if an inline function body is very short, the code\ngenerated for the function body may be smaller than the code for a\nfunction call. This can lead to *smaller* object code and a higher instruction\ncache hit rate.\n\nBear in mind that `inline` is a 'request' not a command. The request can\nbe explicit or implicit. The implicit method is to define the function in the\nclass definition.\n```cpp\nclass Person {\npublic:\n    ...\n    int age() const { return theAge; }  //implicit inline req\n    ...\nprivate:\n    int theAge;\n};\n```\n\nThe explicit way is to precede its definition with the `inline` keyword.\n```cpp\ninline const T\u0026 std::max(const T\u0026 a, const T\u0026 b)\n{ return a \u003c b ? b : a; }\n```\n\nJust because inline functions and function templates are usually defined\nin header files does **not** mean that function templates must be inline. The\nreason that this happens is because inlining and function template\ninstantiation both happens at compile time. If you inline all function\ntemplates mindlessly, you will bloat the code unnecessarily and incur all of\nthe associated costs.\n\n*Inline is a request.* Most compilers refuse to inline functions that are too\ncomplicated (contain loops or are recursive) and all but the most trivial\ncalls to virtual functions. After all virtual means 'figure out which\nfunction to call at runtime'. How you call the function also affects\nwhether the function is inlined. Calling a function through a pointer will\nmost likely not result in it being inlined.\n\nIt is also important to carefully consider inlining as a library designer as it\nis impossible to provide binary upgrades to the client-visible inline\nfunctions in a library. This is because inline functions are compiled into\nthe clients application. To change this the clients would have to recompile\nwith the new provided inline function code. This is more onerous than\ndynamically linking a non inline function.\n\nThis all culminates in the logical strategy that functions should generally\nnot be declared inline. The 80-20 rule should be recalled and you should\nidentify the 20% of your code that increases your code's performance\nand selectively apply inline.\n\n\u003e [!abstract] Summary  \n\u003e - Limit most inlining to small, frequently called functions. This\n\u003e facilitate debugging, binary upgradability, minimises code bloat, and\n\u003e maxmises chances of greater performance.\n\u003e - Don't declare function templates inline just because they appear\n\u003e in header files.\n\n### **Item 31:** Minimise compilation dependencies between files.  \nC++ does not do a very good job of separating interfaces from\nimplementations. You might make a small change to an implementation,\njust the private stuff and find your whole project recompiling.\n\n```cpp\nclass Person {\npublic:\n    ...\n    Person(const std::string\u0026 name, const Date\u0026 birthday,\n           const Address\u0026 addr);\n    std::string name() const;\n    std::string birthDate() const;\n    std::string address() const;\n    ...\nprivate:\n    std::string theName;  //implementation detail\n    Date theBirthDate;    //implementation detail\n    Address theAddress;   //implementation detail\n};\n```\n\nIn this example, the `Person` class can't be compiled without access to\ndefinitions that the `Person` ==implementation== uses (string, Date, Address).\nSuch definitions are typically provided using the `#include` directive.\n```cpp\n#include \u003cstring\u003e\n#include \"date.h\"\n#include \"address.h\"\n```\n\nUnfortunately, this leads to compilation dependencies as changes to any\nof these files will require Person to also be recompiled. C++ requires the\nimplementation details of a class in the class definition as compilers need\nto know how much memory to allocate for objects. This info cannot be\nfound in forward declarations. ==This is not a problem in languages like\nJava== as in those languages compilers allocate only enough space for a\npointer to an object.\n\nIn C++ there are two ways to solve this problem:\n- Like Java, play the game of \"hide the object implementation behind a\npointer game\" using the pimpl idiom.\n- Use ==interface classes==.\n\n*pimpl idion method*\n```cpp\n#include \u003cstring\u003e\n#include \u003cmemory\u003e\n\nclass PersonImpl;\nclass Date;\nclass Address;\n\nclass Person {\n    Person(const std::string\u0026 name, const Date\u0026 birthday,\n           const Address addr);\n    std::string name() const;\n    std::string birthDate() const;\n    std::string address() const;\n    ...\nprivate:\n    std::shared_ptr\u003cPersonImpl\u003e pImpl;//ptr to implementation\n};\n```\n\nWith this design, clients of Person are divorced from the details of dates,\naddresses and persons. The implementations can be changed at will, but\n`Person` clients do not need to recompile. ==Furthermore, since the clients\nare unable to view the implementation, the are unlikely to write code that\ndepends on those details==. Hence:\n- *Avoid using objects when object references will do*. You can define\npointers and references to a type with only a declaration for a type.\nDefining objects of a type is what necessitates the definition of the class.\n- *Depend on class declarations instead of class definitions whenever\nyou can*. You never need a class definition to declare a function using that\nclass, not even if the function passes or returns the class type by value.\n```cpp\nclass Date;   //class declaration\n\nDate today(); // fine even though it returns Date by value\nvoid clearAppointments(Date d); // also fine\n```\nWhy declare functions that no one calls? It allows you to have a header\nfile of function declarations. However, clients of your library will most\nlikely not use every function. Now the burden of `#include`'ing the types\nthe clients need is on the client. If you put all of the includes in the\nfunction declaration file, the clients would have artificial dependencies on\nfiles that they do not need as they would be including things that they\ndon't need from the functions they don't call.\n- *Provide separate header files for declarations and definitions.* To\nfacilitate adherance to these guidelines, header files should come in pairs:\none for declarations, the other for definitions. These files need to be kept\nconsistent. This means that library clients should `#include` a declaration\nfile instead of forward declaring themselves. This means that library\nauthors should provide both of these header files. The above example\nwould look like so:\n```cpp\n#include \"datefwd.h\"\n\nDate today();\nvoid clearAppointments(Date d);\n```\n\nClasses like `Person` that use the 'pimpl idiom' are often called handle\nclasses. Here's how `Person` might be implemented(aka the .cpp file):\n```cpp\n#include \"Person.h\"\n#include \"PersonImpl.h\"\n\nPerson::Person(const std::string\u0026 name, const Date\u0026 birthday,\n               const Address\u0026 addr)\n:pImpl(new PersonImpl(name, birthday, addr))\n{}\n\nstd::string Person::name() const\n{\n    return pImpl-\u003ename();\n}\n```\n\nNow lets consider the alternative. Interface classes. An interface class\nfor `Person` might look like this:\n```cpp\nclass Person {\npublic:\n    virtual ~Person();\n\n    virtual std::string name() const = 0;\n    virtual std::string birthDate() const = 0;\n    virtual std::string address() const = 0;\n}\n```\n\n==Clients of this class must program in terms of Person pointers and\nreferences as it is impossible to instantiate classes containing pure virtual\nfunctions.== It is however, possible to instantiate classes *derived* from\n`Person`. Like handle classes, clients of the interface class do not have to\nrecompile unless the interface is modified.\n\nClients of interface classes need a way to create new objects. This is\ntypically done using 'factory functions' that play the role of the\nconstructor. They return pointers (preferably smart) to dynamically\nallocated objects that support the Interface classes interface. Such\nfunctions are often declared static inside the interface class:\n```cpp\nclass Person {\npublic:\n    ...\n    static std::shared_ptr\u003cPerson\u003e\n        create(const std::string\u0026 name,\n               const Date\u0026 birthday,\n               const Address\u0026 addr);\n    ...\n};\n\n// to use the factory function\nstd::string name;\nDate dob;\nAddress addr;\n\nstd::shared_ptr\u003cPerson\u003e pp(Person::create(name, dob, addr));\n```\n\nAt some point the Person interface class will need to be 'implemented'.\nThat might look like this:\n```cpp\nclass RealPerson: public Person {\npublic:\n    RealPerson(const std::string\u0026 name, const Date\u0026 dob,\n               const Address\u0026 addr)\n    : theName(name), theBirthdate(dob), theAddress(addr)\n    {}\n    virtual ~RealPerson() {}\n    virtual std::string name() const;\n    virtual std::string birthDate() const;\n    virtual std::string address() const;\nprivate:\n    std::string theName;\n    Date theBirthDate;\n    Address theAddress;\n};\n\n...\nshared_ptr\u003cPerson\u003e Person::create(const std::string\u0026 name,\n                                  const Date\u0026 birthday,\n                                  cosnt Address\u0026 addr)\n{\n    return std::shared_ptr\u003cPerson\u003e(new RealPerson(name,dob\n                                                  addr));\n}\n```\n\nThis demonstrates one of two most common mechanisms for implementing\nan Interface class: inherit its interface specification, then implement the\nfunction from the interface. A second way is using multiple inheritance\n(item 40).\n\n==So what are the costs for all this magic?== Some speed at runtime, plus\nsome additional memory per object. For handle classes, you have to go\nthrough one layer of indirection to get to the object's data per access.\nThe space required for this extra implementation pointer increases the\nmemory required as well. Finally, since the object is dynamically\nallocated, there are associated costs with that.\n\nFor interface classes, every function call is virtual, so you pay the cost\nof an indirect jump each time you make a function call. All objects derived\nfrom an interface class also requires a virtual table pointer.\n\nFinally, for both, they don't really benefit from `inline` functions.\n\nDo not dismiss ==handle classes== and ==interface classes== due to these costs\nthough. Use them evolutionarily. Use them during development and then\nreplace with concrete classes for production use if you can prove the\nspeed/size benefit outweighs the coupling.\n\n\u003e [!abstract] Summary  \n\u003e - Main idea to reduce compilation dependencies is to rely on\n\u003e declarations as much as possible. The two approaches are =='handle\n\u003e classes'== and =='interface classes'==.\n\u003e - Library header files should exist in full and declaration-only forms\n\u003e even if templates are involved.\n\n## Ch6: Inheritance and Object-Oriented Design  \n\n### **Item 32:** Make sure public inheritance models \"is-a.\"  \nThe most important rule with OOP in C++ is that *public inheritance means\n\"is-a\"*. If you write that class D(derived) publicly inherits from class\nB(base), you are telling C++ compilers that every object of type D is also\nan object of type B. Anywhere an object of type B can be used, you can\nalso use type D, but not vice versa.\n```cpp\nclass Person {...};\nclass Student: public Person {...};\n\nvoid eat(const Person\u0026 p);\nvoid study(const Student\u0026 s);\n\nPerson p;\nStudent s;\n\neat(p);  //fine - p is a person\neat(s);  //fine - s is a student. student is-a person\n\nstudy(s);//fine\nstudy(p);//error - p is not a student. \n```\n\nThis is true only for *public* inheritance. Private inheritance means\nsomething different. Who knows what protected inheritance means.\n\nHowever, human intuition can be misleading. If we say penguins are birds\nand birds can fly, we could represent it like this:\n```cpp\nclass Bird {\npublic:\n    virtual void fly();      //birds can fly\n    ...\n};\nclass Penguin: public Bird { // Penguins are birds\n    ...\n};\n```\n\nNow, we are in trouble because this hierarchy is claiming that penguins\ncan fly. We are victims of an imprecise language called english. When we\nsay birds can fly, we don't mean *all* birds can fly. There can be non flying\nbirds. Now that we are clear about this, we could represent it like so:\n```cpp\nclass Bird {\npublic:\n    ...                      // no fly function\n};\nclass FlyingBird {\npublic:\n    virtual void fly();\n    ...\n};\nclass Penguin: public Bird { // Penguins are birds\n    ...\n};\n```\nThis is now more faithful to reality. However, if your application does not\ndeal with flying, the original two class hierarchy may be sufficient. It\ndepends on what the system is expected to do.\n\nThere is another school of thought on how to handle the \"penguins are\nbirds but they can't fly\" issue. The approach is to redefine the fly\nfunction for penguins so that it generates a *runtime* error.  \n```cpp\nvoid error(const std::string\u0026 msg); //defined elsewhere\n\nclass Penguin: public Bird {\npublic:\n    virtual void fly() { error(\"Penguins don't fly!\");}\n    ...\n};\n```\nIt is important to recognise that this does *NOT* say \"penguins can't fly\". It\nactually says \"Penguins can fly, but it's an error when they actually try\nto do so\". The main way to detect this is that the error is actually only\ndetected at *runtime*. The way to correctly, definitively say that penguins\ncan't fly is to not implement the fly function for penguins so that now the\ncompiler will detect the error at *compile* time.\n\nLets consider another example. Should square inherit from rectangle? You\nmight be tempted to think so. But you might run into this issue:\n```cpp\nclass Rectangle {\npublic:\n    virtual void setHeight(int newHeight);\n    virtual void setWidth(int newWidth);\n    virtual int height() const;\n    virtual int width() const;\n    ...\n};\nvoid makeBigger(Rectangle\u0026 r)\n{\n    int oldHeight = r.height();\n    r.setWidth(r.width() + 10);\n    assert(r.height() == oldHeight); //ensure height unchanged\n}\n\nclass Square: public Rectangle {...};\nSquare s;\n...\nassert(s.width() == s.height());  //true for squares. surely\nmakeBigger(s); // is a rectangle by inheritance so can call it\nassert(s.width() == s.height());  //true for squares. surely\n```\nIt is clear that the second assertion on the square should remain true as\na square by definition has equal height and width. However, the call to\n`makeBigger()` has changed the width but not height. The fundamental\nissue here is that something applicable for rectangles is not applicable for\nsquares. This property is: ==height can be changed independently of width==.\nBut public inheritance asserts that everything that applies to the base\napplies to the derived class too. \n\n\u003e [!abstract] Summary  \n\u003e Public inheritance means \"is-a\". Everything that applies to a base\n\u003e must also apply to a derived class because a derived class is-a base\n\u003e class.\n\n### **Item 33:** Avoid hiding inherited names.  \n```cpp\nint x;\nvoid someFunc()\n{\n    double x;\n    std::cin \u003e\u003e x;\n}\n```\nFrom the above code it is easy to recognise that global variable x is hidden\nby the `x` in the inner scope. Inheritance behaves similarly as if the scope\nof the derived class is inside a base class.\n\n```cpp\nclass Base {\nprivate:\n    int x;\npublic:\n    virtual void mf1() = 0;\n    virtual void mf1(int);\n\n    virtual void mf2();\n\n    mf3();\n    void mf3(double);\n    ...\n};\n\nclass Derived: public Base {\npublic:\n    virtual void mf1();\n    void mf3();\n    void mf4();\n};\n```\nIn this example, `mf1` and `mf3` hide the base class version. From the\nperspective of *name lookup*, Base::mf1 and Base::mf2 are no longer\ninherited at all.\n\n```cpp\nDerived d;\nint x;\n...\nd.mf1(); //fine. calls Derived::mf1\nd.mf1(x) //error. Derived::mf1 hides Base::mf1\nd.mf2(); //fine. calls Derived::mf2\nd.mf3(); //fine. calls Derived::mf3\nd.mf3(x);//error. Derived::mf3 hides Base::mf3\n```\n\nThe surprising behaviour is that the hiding also affects functions in the\nbase class that take different parameters. The rationale is that it prevents\naccidentally inheriting overlods from distant base classes when you create\na new derived class in a library or application framework.\n\nUnfortunately, you do want to inherit the overloads when using public\ninheritance. You don't wan to violate the *\"is-a\"* relationship. You can\noverride this behaviour with `using declarations`.\n\n```cpp\nclass Derived: public Base {\npublic:\n    using Base::mf1; //make things in Base called mf1 and\n    using Base::mf1; //mf1 visible in Derived's scope\n\n    virtual void mf1();\n    void mf3();\n    void mf4();\n};\nDerived d;\nint x;\n...\nd.mf1(); //fine. calls Derived::mf1\nd.mf1(x) //now ok. Calls Base::mf1\nd.mf2(); //fine. calls Derived::mf2\nd.mf3(); //fine. calls Derived::mf3\nd.mf3(x);//now ok. Calls Base::mf3\n```\n\nIn public inheritance you always want to inherit all the functions from the\nBase class. However, with private inheritance, you may not want to\ninherit all the functions. Lets say Derived privately inherits from Base, and\nit only wants to inherit the `mf1` that takes on parameters. You can't use\n`using` to do this. For this you have to use a ==forwarding function==.\n\n```cpp\nclass Base {\npublic:\n    virtual void mf1() = 0;\n    virtual void mf1(int);\n    ...\n};\nclass Derived: private Base {\npublic:\n    virtual void mf1() { Base::mf1(); }\n    ...\n};\n...\nDerived d;\nint x;\nd.mf1();  //works as expected\nd.mf1(x); //hidden as expected\n```\n\n\u003e [!abstract] Summary  \n\u003e - Names in derived classes hide names in base classes. Under pubilc\n\u003e inheritance, this is never desirable.\n\u003e - To make hidden names visible again, employ using declarations or\n\u003e forwarding functions.\n\n\n### **Item 34:** Differentiate between inheritance of interface and inheritance of implementation.  \nPublic inheritance is composed of two separable parts: inheritance of\nfunction interfaces and inheritance of function implementations. This\ncorresponds exactly to the difference between function declarations\nand function definitions.\n\nAs a class designer you may want to (1) allow a derived class to only\ninherit the interface of a member function, (2) allow a derived class to\ninherit a function's interface and implementation, but with the option to\noverride the inherited implementation or (3) allow a derived class to\ninherit interface and implementation without allowing it to be overriden.\n\n#### **1)** Interface only - AKA pure virtual functions\n```cpp\nclass Shape {\npublic:\n    virtual void draw() const = 0;\n    ...\n};\n```\nTwo most salient features of pure virtual functions:  \n- Must be redeclared by conrete class that inherits them.\n- Typically have no definition in abstract classes.\nThese two imply that the whole point of pure virtual functions is to have a\nderived class inherit the *interface only*.\n\nIn the shape example, we have no idea how a shape will be drawn. Just\nthat the designer of a concrete shape derived class has to make provide\nan implementation.\n\n#### **2)** Interface + optional default implementation - AKA virtual functions\nThe big risk with virtual functions is that a new derived class is added into\nthe inheritance hierarchy, *BUT* this new derived class differs from its\nsiblings and does *NOT* want the default implementation of the virtual\nfunction. If the programmers forget to implement the custom overriden\nversion for this new derived class, then we have issues.\n\nWhat we would like to do is offer a default implementation but require it to\nbe explicitly asked for instead of being given it by default.  \nThere are two ways to solve this. The first:\n```cpp\nclass Airplane {\npublic:\n    virtual void fly(const Airport\u0026 destination) = 0;\n    ...\nprotected:\n    void defaultFly(const Airport\u0026 destination);\n};\n\nvoid Airplane::defaultFly(const Airport\u0026 destination)\n{\n    // default code to fly to desination airport\n    ...\n}\n```\nThe key here is to disconnect the interface from the default\nimplementation. The fly virtual function has been changed into a pure\nvirtual function which has to be implemented but the implementation can\nnow just use the `defaultFly` function provided.\n\nNow any new derived classes will have to implement `fly` and will not use\nthe `defaultFly` function accidentally.\n\nAn objection to this method of solving the problem is the pollution of the\nnamespace. You can solve this with something very similar:\n```cpp\nclass Airplane {\npublic:\n    virtual void fly(const Airport\u0026 destination) = 0;\n    ...\n};\n\nvoid Airplane::fly(const Airport\u0026 destination)\n{\n    // default code to fly to destination\n    ...\n}\n\nclass ModelA: public Airplane { // uses default  fly\npublic:\n    virutal void fly(const Airport\u0026 destination)\n    {Airplane::fly(destination);}\n    ...\n};\n\nclass ModelB: public Airplane {\npublic:\n    virutal void fly(const Airport\u0026 destination);\n    ...\n};\n\nvoid ModelB::fly(const Airport\u0026 destination)\n{\n    // code for ModelB plane to fly to destination\n}\n```\nThe main thing you lose with this method is to have different protection\nlevels. The code that used to be in `defaultFly` is now public.\n\n#### **3)** Interface + mandatory implementation\n```cpp\nclass Shape {\npublic:\n    int objectID() const;\n    ...\n}\n```\nNothing fancy in terms of implementation. But you should consider the\nimplication of a mandatory implementation. It's basically saying \"Every\nshape object has a funtion that returns it's ID, and no derived class can\nchange the implementation\". It is an ==invariant over specialisation==.\n\n**Common mistakes**\n- Making everything non-virtual\n    - Might happen due to concerns over performance. Just remember the 80-20 rule.\n- Declaring all member functions virtual\n    - Can be sign of a class designer to make a firm stance on what functions really are invariants.\n\n\u003e [!abstract] Summary  \n\u003e - Inheriting interfaces is different from inheriting implementations.\n\u003e Under public inheritance, derived classes always inherit base class\n\u003e interfaces.\n\u003e - Pure virtual functions specify inheritance of interface only.\n\u003e - Simple (impure) virtual functions specify inheritance of interface\n\u003e and inheritance of a default implementation.\n\u003e - Non-virtual functions specify inheritanc of interface and a\n\u003e mandatory implementation.\n\n\n### **Item 35:** Consider alternatives to virtual functions.  \nConsider a video game and a hierarchy for characters in the game. You\noffer a member function `healthValue`, that returns an integer indicating\nhow healthy the character is. However, different characters may calculate\ntheir health differently. Declaring `healthValue` virtual seems obvious:\n```cpp\nclass GameCharacter {\npublic:\n    virtual int healthValue() const;\n    ...\n};\n```\nThe problem is in fact that this design does seem so obvious. However,\nthere are alternative ways to approach this problem and we should bear\nthis in mind and consider them.\n\n#### The Template Method Pattern via the `Non-Virtual Interface Idiom`  \nOne school of thought is that virtual functions should always be private.\nTo adhere to this rule and solve the healthvalue problem you could retain\n`healthValue` but change it to public. Then a different private virtual\nfunction does the actual calculation and is called by the public function:\n```cpp\nclass GameCharacter {\npublic:\n    int healValue() const\n    {\n        ...  //do \"before\" stuff. aka setup\n        int retVal = doHealthValue(); //do real work\n        ...  //do \"after\" stuff. aka cleanup(?)\n        return retVal;\n    }\n    ...\nprivate:\n    virtual int doHealthValue() const\n    {\n        ... //default algorithm for health calc\n    }\n};\n```\nThis design is calle dthe non-virtual interface (NVI) idiom. It is a\nminifestation of a more general design pattern called Template Method\n(unrelated to C++ templates).\n\nin the NVI idiom, the non-virtual method becomes the 'wrapper' used to\ncall the virtual method that does the work. This means that the wrapper\nfunction can ensure that the context is setup before the work is done and\nthen cleaned up after (e.g. Locking and unlocking a mutex).\n\n#### The Strategy pattern via Function Pointers\nThe NVI idiom is an interesting alternative to public virtual functions, but\nultimately it's little more than window dressing. After all, the real work\nis still being done with virtual functions. A more dramatic design would be\nsaying that calculating a character's health is independent of the\ncharacter's type. For example we could require that each character's\nconstructor be passed a pointer to a health calculation function.\n```cpp\nclass GameCharacter;  // forward declaration\n\n//function for default health calculation algo\nint defaultHealthCalc(const GameCharacter\u0026 gc);\n\nclass GameCharacter {\npublic:\n    typedef int (*HealthCalcFunc)(const GameCharacter\u0026);\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)\n    : healthFunc(hcf)\n    {}\n    int healthValue() const\n    { return healthFunct(*this); }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\nThis approach is a simple application of another common design pattern -\n==strategy==. Compared to approaches based on virutal functions, it offers\nsome interesting flexibility:\n- Different instances of the same character type can have different health\ncalculation functions.\n- Health calculation functions can be changed at runtime.\n\nHowever, on the other hand, it means that the health calculation function\nno longer has special access to the internal parts of `Character`. This\nis something that you have to bear in mind for all functions outside of the\nclass. The only way to resolve this is to weaken the encapsulation of the\nclass i.e. declare non-member function a friend, offer public accessor\nfunctions that would otherwise not be necessary.\n\n#### The Strategy Pattern via std::function\nOnce you get accustomed to templates though, the function pointer\napproach can seem limiting and rigid. Why can't we use something that\n*acts* like a function such as a function object? Why can't it be a member\nfunction? Why must it return an int instead of a type convertible to an int.\n\nThese constraints vanish when we use std::function instead of a function\npointer. Here is the same design but with std::function.\n```cpp\nclass GameCharacter;\nint defaultHealthCalc(const GameCharacter\u0026 gc);\n\nclass GameCharacter {\npublic:\n    typedef std::function\u003cint (const GameCharacter\u0026)\u003e HealthCalcFunc;\n\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)\n    :healthFunc(hcf)\n    {}\n    int healthValue() const { return healthFunc(*this);}\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\nLets take a closer look at what the typedef was for:  \n`std::function\u003cint (const GameCharacter\u0026)\u003e`  \nThe target signature is \"function taking a const GameCharacter\u0026 and\nreturning an int\". An object of this type can hold any callable entity\ncompatitble with that signature. Compatible means that\n`const GameCharacter\u0026` can be converted to the type of the entity's\nparameter and the entity's return type can be converted to int.\n\nThis is similar to using function pointers but with a staggering amount\nmore flexibility.\n\n#### The \"Classic\" Stretegy Pattern\nFor a more design pattern friendly approach instead of a 'C++ coolness'\napproach you can have `GameCharacter` be the base class for `EvilBadGuy`\nand `EyeCandyCharacter`. `HealthCalcFunc` would then be the root of\nanother hierarchy with derived classes `SlowHealthLoser` and\n`FastHealthLoser`. Each `GameCharacter` would contain a pointer to an\nobject from the `HealthCalcFunc` hierarachy.\n```cpp\nclass GameCharacter;\n\nclass HealthCalcFunc {\npublic:\n    ...\n    virtual int calc(const GameCharacter\u0026 gc) const\n    {...}\n    ...\n};\n\nHealthCalcFunc defaultHealthCalc;\n\nclass GameCharacter {\npublic:\n    explicit GameCharacter(HealthCalcFunc* phcf = \u0026defaulthealthCalc)\n    : pHealthCalc(phcf)\n    {}\n    int healthValue() const\n    { return pHealthCalc-\u003ecalc(*this);}\n    ...\nprivate:\n    HealthCalcFunc *pHealthCalc;\n};\n\n```\n\nThis approach has the appeal of being quickly recognisable to people\nfamiliar with the 'standard' strategy pattern implementation. It also has\nthe benefit of allowing the existing health calculation to be tweaked with\nthe use of derived classes.\n\n\u003e [!abstract] Summary  \n\u003e Consider alternatives to virtual functions when searching for a design\n\u003e to solve your problem. Alternatives include:\n\u003e - **Non-virutal Interface Idiom**. A form of the Template Method design\n\u003e - Replace virtual functions with **function pointer data members**\n\u003e - Replace virtual functions with **std::function data members**\n\u003e - Replace virtual functions in one hierarchy with **virtual functions from a different hierarchy**.\n\u003e This is the conventional approach to the strategy pattern.\n\n### **Item 36:** Never redefine an inherited non-virtual function.  \nLets say you have a base class B and a derived class D that inherits from\nB.\n```cpp\nclass B {\npublic:\n    void mf();\n    ...\n};\nclass D: public B{...}\n```\nNow if you were to call mf though a pointer to object D...\n```cpp\nD x;\nB* pB = \u0026x;\nD* pD = \u0026x;\n\npB-\u003emf();  // surely these function calls\npD-\u003emf():  // do the same thing\n```\nYou would expect the same result. However, this may not be the case if\nclass D has redefined `mf()`. This is because ==non-virtual functions are statically bound==.\nVirtual functions. on the other hand are dynamically bound, so you would\nget the expected result. That's the pragmatic argument.\n\nNow for a more theoretical argument. If public inheritance means an \"is-a\"\nrelationship and declaring a non virtual function establishes an invariant\nover specialisation for that class, then:\n- Everything that applies to B objects also apply to D objects\n- Classes derived from B must inherit both the interface and\nimplementation of `mf()` because mf is non-virtual\n\nThen what is D do doing by redefining `mf()`? It makes no sense. It means\nthat every D is a B is no longer true. It would mean that D should not\ninherit from B. If D does really have to inherit from B, then that also\nmeans that the invariant over specialisation is not true. This means that\n`mf()` should be virtual.\n\nBasically, just don't do it. It's pragmatically bad and theoretically\nnonsensical.\n\n\u003e [!abstract] Summary  \n\u003e Never redefine an inherited non-virtual function\n\n\n### **Item 37:** Never redifine a function's inherited default parameter value.  \nThe previous item rules out redefining non virtual functions so this item\naddress redefining the *default parameter value* of a virtual function.\n\n==Virtual functions are dynamically bound, but default parameter values are statically bound.==\n\nEssentially this means that if you redefine a default parameter value in a\nderived function, it will still use the default parameter value from the base\nclass. So don't do it.\n\nIf you want to supply a default parameter value for both the base and\nderived class though, without redefining the same colour in both, resulting\nin code duplication and dependencies, you can use NVI.\n\n\u003e [!abstract] Summary  \n\u003e Never redefine an inherited default parameter value because default\n\u003e parameter values are statically bound and virtual functions are\n\u003e dynamically bound.\n\n### **Item 38:** Model \"has-a\" or \"is-implemented-in-terms-of\" throw composition.  \n*Composition* is the relationship that arises when objects of one type\ncontain objects of another type. For example:\n```cpp\nclass Address {...};\nclass PhoneNumber {...};\nclass Person {\npublic:\n    ...\nprivate:\n    std::string name;         //composed object\n    Address;                  // ditto\n    PhoneNumber voiceNumber;  // ditto\n    PhoneNumber faxNumber;    // ditto\n};\n```\n\nItem 32 explains that public inheritance means \"is-a\". Composition also\nhas a meaning. Composition means \"has-a\" or\n\"is-implemented-in-terms-of\". That's because some objects in your code\ncorrespond to things in the world you are modeling e.g. people, vehicles,\nvideo frames etc. Such objects are part of the *application domain*. Other\nobjects are purely implementation artefacts e.g. buffers, mutexes, search\ntrees etc. Application domain -\u003e \"has-a\". Implementation domain -\u003e\n\"is-implemented-in-terms-of\".\n\nThe \"has-a\" relationship is relatively simple and people do not struggle\nwith it. More problematic is the \"is-implemented-in-terms-of\"\nrelationship. Lets say you need a hash set. The STL has such a data\nstructure. However, the tradeoff made in the STL implementation is\nto sacrifice space for speed and requires three pointers per element. So\nyou decided to implement as set yourself. You decide to implement it as\na linked list and not a search tree. To do this you decide to use the STL\nimplementation of linked list. You may choose to do the following:\n```cpp\ntemplate\u003ctypename T\u003e\nclass Set: public std::list\u003cT\u003e { ... };\n```\n\nThis would be wrong. This implies that what's true for list is also true\nfor your set. It models an \"is-a\" relationship. what you should do is:\n```cpp\ntemplate\u003ctypename T\u003e\nclass Set {\npublic:\n    bool member(const T\u0026 item) const;\n    void insert(const T\u0026 item);\n    void remove(const T\u0026 item);\n    std::size_t size() const;\nprivate:\n    std::list\u003cT\u003e rep;     // representation of set data\n};\n```\n\nFinally the relationship has been established correctly. Set is \"implemented\nin terms of\" a linked list.\n\n\u003e [!abstract] Summary  \n\u003e - Composition has meanings completely different from that of public\n\u003e inheritance.\n\u003e - In the application domain, composition means \"has-a\"\n\u003e - In the implementation domain, composition means \"is-implemented-in-terms-of\"\n\n### **Item 39:** Use private inheritance judiciously.  \nLets repeast the 'A Person can eat and a Student can study' example from\nthe public inheritance section, but with private inheritance.\n```cpp\nclass Person {...};\nclass Student: private Person {...};  //private inheritance\nvoid eat(const Person\u0026 p);            // any person can eat\nvoid study(const Student\u0026 s);         // only students study\nPerson p;\nStudent s;\neat(p);   //fine, p is a person\neat(s);   //error! a Student isn't a person\n```\n\nAs you can see compilers will generally *NOT* convert a derived class into\nthe base class with private inheritance. This seems to indicate that it is\n*NOT* an \"is-a\" relationship. The other thing that happens is that members\ninherited from a private base class will all be converted to private\nmembers of the derived base class even if they are public or protected.\n\nSo what is the meaning? Private inheritance means\n\"is-implemented-in-terms-of\". If you make class D privately inherit from\nclass B, you are doing so to take advantage of some features in B, not\nbecause there's any conceptual link between them. If we think of it in\na way similar to item 34, private inheritance means to *only* inherit the\nimplementation and not the interface.\n\nThe catch is that this 'meaning' is the exact same as item 38 -\ncomposition. So when should you use one or the other?  \n==Use composition whenever you can, and use private inheritance when you must.==\nAnd when must you? Primarily when protected members and/or virtual\nfunctions enter the picutre.\n\nLets consider a widget class that runs overtime. We want to track how\noften member functions are being called in regular time intervals. We\nmight reuse a Timer class that looks like this:\n```cpp\nclass Timer {\npublic:\n    explicit Timer(int tickFrequency);\n    virtual void onTick() const;  //auto called for each tick\n    ...\n};\n```\n\nThis class is perfect as we can redefine the virtual function so that it\nexamines the state of the `Widget`. In order to redefine a virtual function\nthough we need to inherit from Timer. However, public inheritance is\nnot suitable as clients would then be able to call onTick which we do not\nwant. Therefore we inherit privately:\n```cpp\nclass Widget: private Timer {\nprivate:\n    class WidgetTimer: public Timer {\n    public:\n        virtual void onTick() const;\n        ...\n    };\n    WidgetTimer timer;\n    ...\n};\n```\n\nThis is a nice design but we need to remember that this can still be done\nwith composition. It would be a bit more complicated though. We would\nhave to declare a private nested class inside Widget that would publicly\ninherit from Timer, redefine `onTick()` in there and put an object of that\ntype into Widget.\n```cpp\nclass Widget {\nprivate:\n    class WidgetTimer: public Timer {\n    public:\n        virtual void onTick() const;\n        ...\n    };\n    WidgetTimer timer;\n    ...\n};\n```\n\nShowing this design is primarily a reminder that there are many ways to do\nthe same thing and they should be considered. However, there are two\nrearsons why public inheritance + composition might be preferrable over\nprivate inheritance.\n- You might want to design Widget to allow for derived classes but\nprevent derived classes from redefining `onTick`. Private inheritance would\nstill allow it as you can still redefine functions that you can't call. If you\nwant to replicate Java/C# ability to prevent derived classes from\nredefining virtual functions this is a way to approximate that behaviour.\n- You might want to minimise Widget's compilation dependencies. If\nWidget inherits from Timer, Timer's definition must be available when\nWidget is compiled so the file defining Widget probably has to\n`#include \"Timer.h\"`. On the other hand, if WidgetTimer is moved out of\nWidget and Widget contains only a pointer to a WidgetTimer, Widget can\nget by with a simple declaration for `WidgetTimer`.\n\nThere is an edge case that private inheritance might be useful for involving\nspace optimisation. It applies when dealing with classes that have no data\nin it: no non-static data members; no virtual functions; and no virtual\nbase classes. In theory these sort of classes should use no space.\nHowever, they do.\n```cpp\nclass Empty {}; //has no data so objects should use no memory\n\nclass HoldsAnInt {  // should only use space for 1 int\n    int x;\n    Empty e;    //should require no memory\n};\n```\nYou'll find that `sizeof(HoldsAnint) \u003e sizeof(int);`. This is because\nwith most compilers, sizeof(Empty) is 1. What makes this even worse is\nthat alignment requirements can make HoldsAndInt take even more space.\nIt would take the space of 2 ints, instead of 1 int + 1 char.\n\nThis is because C++ has an edict against zero-size free standing objects.\nHowever, this does mean that if you inherit from Empty instead, the size\nwill be as expected:\n```cpp\nclass HoldsAnInt: private Empty {\nprivate:\n    int x;\n};\n```\nNow `sizeof(HoldsAnInt) == sizeof(int)`. This is known as the 'empty\nbase optimisation' (EBO). In practice, most empty classes aren't emtpy,\nthey contain typedefs, enums, static data members, or non-virtual\nmembers. The STL has many 'technically' empty classes. Thanks to EBO,\nthese classes rarely increase the size of the inheriting class.\n\nHowever, this use case is indeed niche. It's good to be aware of but most\nlikely rarely used.\n\n\u003e [!abstract] Summary  \n\u003e - Private inheritance means \"is-implemented-in-terms-of\". It is\n\u003e usually inferior to composition, but makes sense if a derived class\n\u003e needs access to protected base class members or to redefine virtual\n\u003e functions.\n\u003e - Unlike composition, private inheritance can enable the *empty base otimisation*.\n\u003e This can be important for library developers who strive to minimise\n\u003e object sizes.\n\n### **Item 40:** Use multiple inheritance judiciously.  \nC++ community seems to break up into two camps regarding multiple\ninheritance:\n- if single inheritance(SI) is good, multiple inheritance(MI) must be better\n- single inheritance is good, but multiple inheritance isn't worth the\ntrouble\n\nFirst thing to recognise with multiple inheritance is that it makes it\npossible to inherit the same name leading to ambiguity. For example you\nmight inherit from two classes that both have the `checkout()` function.\nTo fix this you would then have to specify which one you are calling:  \n`BorrowableItem::checkout();`  \n`ElectronicGadget::checkout();`  \n\nMI can also lead to the 'deadly MI diamond'.\n```cpp\nclass File {...};\n\nclass InputFile: public File {...};\nclass OutputFile: public File {...};\n\nclass IOFile: public InputFile, public OutputFile\n{...};\n```\nHere you have to confront the question whether you want to replicate the\ndata members of the base class for each 'path':\n- IOFile -\u003e InputFile -\u003e File\n- IOFile -\u003e OutputFile -\u003e File\nC++ takes no position and happily supports both option. The default is to\nperform the replication. If you don't want that, you have to make the\nclass with the data a virtual base class:\n```cpp\nclass File {...};\n\nclass InputFile: virtual public File {...};\nclass OutputFile: virtual public File {...};\n\nclass IOFile: public InputFile, public OutputFile\n{...};\n```\n\nFrom the viewpoint of correct behaviour, public inheritance should always\nbe virtual. However, correctness is not the only perspective. Virtual\ninheritance has space and time costs. It also has complexity costs.\n==The responsibility of initialising a virtual base is borne by the most derived class in the hierarchy==.\nThis means that (1) classes derived from virtual base classes must be aware of their virtual bases no matter how distant and (2) when a new\nderived class is added to the hierarchy, it must assume direct initialisation\nresponsibilities for its virtual bases.\n\nTherefore the advice on virtual base classes is simple. Don't use virtual\nbases unless you have to. If you must, then avoid putting data in them so\nyou don't have to worry about initialisation oddities. Interfaces in Java\nare in many ways comparable to virtual base classes in C++ and are also\nnot allowed to contain any data.\n\nOne legitimate use is to combine public inheritance of an interface with\nthe private inheritance of an implementation.\n```cpp\nclass IPerson {\npublic:\n    virtual ~IPerson();\n    virtual std::string name() const = 0;\n    virtual std::string birthDate() const = 0;\n};\n// factory function to create Person object\nstd::shared_ptr\u003cIPerson\u003e makePerson(DatabaseID personIdentified);\n```\nHere we have an interface IPerson and a factory function declaration used\nto create Person objects. But there has to be a concrete class for\nmakePerson to instantiate and return a pointer for.\n\nNow lets assume we  already have a class called PersonInfo that we want\nto reuse to fit the IPerson interface.\n```cpp\nclass PersonInfo {\npublic:\n    explicit PersonInfo(DatabaseID pid);\n    virtual ~PersonInfo();\n    virtual const char* theName() const;\n    virtual const char* theBirthDate() const;\n    ...\nprivate:\n    virtual const char* valueDelimOpen() const;\n    virtual const char* valueDelimClose() const;\n    ...\n};\n```\n\nIf we want to create a new class `CPerson` using the existing `PersonInfo`\nclass, the relationship is clearly \"CPerson is implemented in terms of\nPersonInfo\". So we could combine private and public inheritance like so:\n```cpp\nclass CPerson: public IPerson, private PersonInfo {\npublic:\n    explicit CPerson(DatabaseID pid): PersonInfo(pid) {}\n\n    virtual std::string name() const\n    { return PersonInfo::theName();}\n    virtual std::string birthDate() const\n    { return PersonInfo::theBirthDate(); }\nprivate:\n    const char* valueDelimOpen() const { return \"\";}\n    const char* valueDelimClose() const { return \"\";}\n};\n```\n\nThe example should demonstrate that multiple inheritance can be both\nuseful and sensible. However, single inheritance is typically better. Just\nbe judicious with the use of MI.\n\n\u003e [!abstract] Summary  \n\u003e - Multiple inheritance is more complex than single inheritance. It can\n\u003e lead to ambiguity issues.\n\u003e - Virtual inheritance imposes costs in size, speed, and complexity of\n\u003e initialisation and assignment. It's most practical when virtual base\n\u003e classes have no data.\n\u003e - Multiple inheritance does have legitimate uses. One scenario involves\n\u003e combining public inheritance from an iterface class with private\n\u003e inheritance from a class that helps with implementation\n\n## Ch7: Templates and generic programming  \n\n## Ch8: Customising `new` and `delete`  \n\n## Ch9: Miscellany  \n\n\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Sources/How-to-focus":{"title":"Dr. K - How do I focus?","content":"Author: [Dr K](Authors/Dr%20K.md)  \nLink: https://www.youtube.com/watch?v=BZPRX9X5V5I  \nTopics:  [Productivity](Topics/Productivity.md)  \n\n---\n\n## Problem Statement  \nThere is variabillity on human performance where somedays things\n'click' and you perform very well and on other days you perform poorly.\nThis is somewhat counterintuitive as tecnically you have more\nexperience and knowledge every time you attempt something, however,\nperformance still seems to vary.\n\n## The mind and the self\nThe self may say \"I need to focus\", however the mind \"does not want\nto focus\". First we must acknowledge there are different parts of\n'you'. The ability for the self to win involves the frontal lobe which\nis responsible for things such as ==impulse control, delayed gratification and directing attention==.\n\nThe question is how do we skew the balance in the favour of the self.\n\nIn order of what the mind wants to do:  \n1. High dopamine activity\n2. 'Productive' task\n3. The real work\n4. Boredom\n\nThe 'mind' wants to get to the high dopamine activity. It will distract you\nto force you into a state of boredom.\nYou can't tolerate boredom, so you'll tend towards something that is\nproductive but not the work you want to do.\nThen at that point you will tell yourself its ok to indulge in the high\ndopamine activity.\n\nCrucially the mind knows you hate boredom and will weaponise it against you\nto get to high dopamine activities. ALL of the minds power over you\nrevolves around boredom. However, ==you can tolerate boredom more than your mind can==.\n\nDue to the fact that you can tolerate boredom more than your 'mind',\nif you tell yourself that you only have two options: work or sleep;\nyour mind will eventually get productive due to the boredom.\n\n## Sitting with the self\nYou have to notice the various tricks you or your mind play on yourself.\nSometimes it may say that you need to do additional prep before you can\ndo a specific task.This may be true sometimes, or sometimes it can be\nthe mind just give you excuses not to do the task. You need to just\naccept that you will never truly be 'ready'.\n\nYou may also have the thought that since you can't focus today, you as\nwell enjoy the day. Yet again the conclusion is that you don't have to do\nthe work today.\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Sources/Leon-Hendrix-Journaled-for-1000-days.-What-I-learned.":{"title":"Leon Hendrix - Journaled for 1000 days. What I learned.","content":"\nAuthor: [Leon Hendrix](Authors/Leon%20Hendrix.md)  \nLink: https://www.youtube.com/watch?v=0UhZDFK2Pwc  \nTopics: [Journaling](Topics/Journaling.md)  \n\n---\n\n### 7 key points\n- Vison journaling  (visualisation) - motivation\n    - Inspired by Arnold Schwarzenegger - \"When your vision is powerful enough, everything else falls into place\"\n    - **Write down what your ideal life would look like**\n- 'Positive worry' - motivation\n    - What if ...(series of good things)... happens to me?\n    - **Write down a series of good things that could happen to you.**\n- Focus on the one most important thing - productivity\n    - Gary Keller - The One thing\n    - Steve Jobs - \"People think focus means saying yes to the thing you've got to focus on. But that's not what it means at all. It means saying no to the hundred other good ideas that there are.\"\n    - Steps:\n        - **Make a list of everything you COULD do**\n        - **Narrow your focus. \"What is the one thing I could do that would make everything else easier or even unnecessary?\"**\n- Think bigger. 10x exercise - productivity\n- The brain dump - counter anxiety\n    - **Write down all thoughts. No filters. Until everything you're worried about is written down.**\n    - **Reassess**\n- To counter procastrination - productivity\n    - Usually because you need more clarity. Three most common reasons are:\n        - Unclear effort\n        - Unsure about capability/competence\n        - Unclear on outcome\n    - Steps:\n        - **Ask why are you procrastinating**\n        - **Write down resisting thoughts.**\n        - **Dig deeper. Ask follow up questions**\n- Gratitude on steroids - Mood elevation\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Sources/Mental-Models-The-Best-Way-to-Make-Intelligent-Decisions~100-Models-Explained":{"title":"Mental Models - The Best Way to Make Intelligent Decisions(~100 Models Explained)","content":"\nAuthor: [Rhiannon Beaubien](Authors/Rhiannon%20Beaubien.md)  \nLink: [fs blog](https://fs.blog/mental-models/)  \nTopics: [Mental Models](Topics/Mental%20Models.md)  \n\n---\n\n## What are they?\n- **Representation** of how something works.\n- **Simplify** the complex with models into **understandable and organisable** chunks.\n\n- Shapes how we think and how we understand.\n- Shapes **connections and opportunities** we see.\n\n## Learning to think better\n- More models -\u003e bigger toolbox -\u003e more likely to have right models to grasp reality.\n- Decision making ability improves with variety of models.\n\n- Engineer thinks in systems, pyschologist in incentives, biologist in evolution etc.\n- Combining disciplines -\u003e analyse problem in 3D way.\n- Practical wisdom is not just isolated facts. They need to hang together on latticework of theory.\n\n### Core Mental Models\n- **The Map is Not the Territory**\n- **Circle of Competence**\n\t- Know what you understand. Know where your edge is over others.\n\t- Understanding circle of competence improves decision-making and outcomes.\n- First Principles Thinking\n- Thought Experiment\n- **Second-Order Thinking**\n\t- Thinking farther ahead than immeidate results.\n\t- Thinking holistically.\n- Probabilistic Thinking\n- Inversion\n- Occam's Razor\n- Hanlon's Razor","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Sources/Roam-Research-White-Paper":{"title":"Roam Research White Paper","content":"citation:  [White Paper](https://roamresearch.com/#/app/help/page/dZ72V0Ig6)  \nTopics:  [Productivity](Topics/Productivity.md)  \n\n---\nWe are experiencing an unprecedented explosion of knowledge, yet neither the human brain nor current technologies are equipped to ==harnesess== it to its ==full potential==.\n\n## Brief\n- Current approaches to knowledge management are ill suited for information age. They are usually 'cabinet like'.\n\t- Note: Presumable being hierarchical and isolated from one another.\n- Cabinet approach makes it difficult to share ideas across your files and lack interconnectivity.\n- Knowledge graphs are a more flexible data structure to tackle this challenge of knowledge management.\n- Basic users: ease of storage, recollection of ideas and cross-referencing of ideas\n- Power users: applications in logic and reasoning.\n- ==Optimising for serendipity==. Humans have difficulty generating random numbers, thoughts etc. Exposure to random 'noise' can be the stimuli to new insights. These new insights usually occur at the juncture of two seemingly unrelated concepts.\n- Roam's interconnectivity constantly creates opportunities for serendipity and new insights.\n- _Collaborative problem solving - separating the noise from the signal:_ Current learning/research protocols are bound by necessary consensus. As information increases, so does noise, making it difficult to come to a consensus. A curated knowledge graph allows weighing up of conflicting opinions and ideas to develop your own understanding without autocracy (listening to one trusted source) or democracy (waiting for a full consensus that might never come).\n","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Topics/AI":{"title":"AI","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Topics/Journaling":{"title":"Journaling","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Topics/Mental-Models":{"title":"Mental Models","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Topics/Productivity":{"title":"Productivity","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Topics/Software-Engineering":{"title":"Software Engineering","content":"","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null},"/Work-with-the-garage-door-up":{"title":"Work with the garage door up","content":"References:  [Work with the garage door up - Andy Matuschak](https://notes.andymatuschak.org/About_these_notes?stackedNotes=z21cgR9K3UcQ5a7yPsj2RUim3oM2TzdBByZu\u0026stackedNotes=z2DABWsGLkXcCuUet2scfD1duL1ZHBztwGKp) [Learn in public](https://www.swyx.io/learn-in-public)  \nTopics:  [Productivity](Topics/Productivity.md)  \n\n---\n\n\"Work with the garage door up\" is the idea that you should share what you're working on and learning to the public. The idea is that by sharing your work, you can document your progress and allow people to provide feedback, inspiration and support.  \n\nWorking with the garage door up can also have a motivating aspect to it. If you are publishing your development, you are more likely to keep consistent as well as to think through your ideas more. The transparency and openness also makes it naturally align with the philosophy of [anti-marketing](Anti-marketing.md).     \n\nIt seems to have similarities with the 'rubber duck debugging' method where even if no one is reading your notes/posts, the idea that it might be read by other people forces your mind to process the information more carefully which makes your own learning more effective.","lastmodified":"2023-03-18T14:33:43.455371859Z","tags":null}}