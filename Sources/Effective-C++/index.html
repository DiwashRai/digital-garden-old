<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Author: Scott Meyers
Topics: Software Engineering
 Ch1: Accustoming yourself to C++ Item 1: View C++ as a federation of languages C++ is better understood as a group of related sub-languages."><title>Effective C++</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://diwashrai.github.io/digital-garden//icon.png><link href=https://diwashrai.github.io/digital-garden/styles.547fb332ce56cdc523146ba5ede80d7f.min.css rel=stylesheet><link href=https://diwashrai.github.io/digital-garden/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://diwashrai.github.io/digital-garden/js/darkmode.e7521685fecdfbca6dd54d07ef93b61b.min.js></script>
<script src=https://diwashrai.github.io/digital-garden/js/util.a0ccf91e1937fe761a74da4946452710.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script async src=https://diwashrai.github.io/digital-garden/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://diwashrai.github.io/digital-garden/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://diwashrai.github.io/digital-garden/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://diwashrai.github.io/digital-garden/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://diwashrai.github.io/digital-garden/",fetchData=Promise.all([fetch("https://diwashrai.github.io/digital-garden/indices/linkIndex.8b96ec6f45aa29ec767002dca626f738.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://diwashrai.github.io/digital-garden/indices/contentIndex.583f40ef9ce93fd0195426745bbd4054.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://diwashrai.github.io/digital-garden",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://diwashrai.github.io/digital-garden",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/diwashrai.github.io\/digital-garden\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=diwashrai.github.io/digital-garden src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://diwashrai.github.io/digital-garden/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://diwashrai.github.io/digital-garden/>Diwash's Digital Garden ðŸŒ±</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Effective C++</h1><p class=meta>Last updated
Mar 25, 2023
<a href=https://github.com/DiwashRai/digital-garden/tree/main/content/Sources/Effective%20C++.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://diwashrai.github.io/digital-garden/tags/source/>Source</a></li><li><a href=https://diwashrai.github.io/digital-garden/tags/textbook/>Textbook</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#ch1-accustoming-yourself-to-c>Ch1: Accustoming yourself to C++</a><ol><li><a href=#item-1-view-c-as-a-federation-of-languages><strong>Item 1:</strong> View C++ as a federation of languages</a></li><li><a href=#item-2-prefer-consts-enums-and-inlines-to-defines><strong>Item 2:</strong> Prefer consts, enums, and inlines to #defines</a></li><li><a href=#item-3-use-const-whenever-possible><strong>Item 3:</strong> Use const whenever possible</a></li><li><a href=#item-4-make-sure-objects-are-initialised-before-use><strong>Item 4:</strong> Make sure objects are initialised before use</a></li></ol></li><li><a href=#ch2-constructors-destructors-and-assignment-operators>Ch2: Constructors, destructors and assignment operators</a><ol><li><a href=#item-5-know-what-functions-c-silently-writes-and-calls><strong>Item 5:</strong> Know what functions C++ silently writes and calls</a></li><li><a href=#item-6-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want><strong>Item 6:</strong> Explicitly disallow the use of compiler-generated functions you do not want</a></li><li><a href=#item-7-declare-destructors-virtual-in-polymorphic-base-classes><strong>Item 7:</strong> Declare destructors virtual in polymorphic base classes</a></li><li><a href=#item-8-prevent-exceptions-from-leaving-destructors><strong>Item 8:</strong> Prevent exceptions from leaving destructors</a></li><li><a href=#item-9-never-call-virtual-functions-during-construction-or-destruction><strong>Item 9:</strong> Never call virtual functions during construction or destruction</a></li><li><a href=#item-10-have-assignment-operators-return-a-reference-to-this><strong>Item 10:</strong> Have assignment operators return a reference to <code>this</code></a></li><li><a href=#item-11-handle-assignment-to-self-in-operator><strong>Item 11:</strong> Handle assignment to self in operator=.</a></li><li><a href=#item-12-copy-all-parts-of-an-object><strong>Item 12:</strong> Copy all parts of an object.</a></li></ol></li><li><a href=#ch3-resource-management>Ch3: Resource management</a><ol><li><a href=#item-13-use-objects-to-manage-resources><strong>Item 13:</strong> Use objects to manage resources</a></li><li><a href=#item-14-think-carefully-about-copying-behaviour-in-resource-managing-classes><strong>Item 14:</strong> Think carefully about copying behaviour in resource-managing classes</a></li><li><a href=#item-15-provide-access-to-raw-resources-in-resource-managing-classes><strong>Item 15:</strong> Provide access to raw resources in resource-managing classes</a></li><li><a href=#item-16-use-the-same-form-in-corresponding-uses-of-new-and-delete><strong>Item 16:</strong> Use the same form in corresponding uses of <code>new</code> and <code>delete</code></a></li><li><a href=#item-17-store-newed-objects-in-smart-pointers-in-standalone-statements><strong>Item 17:</strong> Store newed objects in smart pointers in standalone statements</a></li></ol></li><li><a href=#ch4-designs-and-declarations>Ch4: Designs and declarations</a><ol><li><a href=#item-18-make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly><strong>Item 18:</strong> Make interfaces easy to use correctly and hard to use incorrectly.</a></li><li><a href=#item-19-treat-class-design-as-type-design><strong>Item 19:</strong> Treat class design as type design.</a></li><li><a href=#item-20-prefer-pass-by-reference-to-const-to-pass-by-value><strong>Item 20:</strong> Prefer pass-by-reference-to-const to pass-by-value.</a></li><li><a href=#item-21-dont-try-to-return-a-reference-when-you-must-return-an-object><strong>Item 21:</strong> Don&rsquo;t try to return a reference when you must return an object.</a></li><li><a href=#item-22-declare-data-members-private><strong>Item 22:</strong> Declare data members private.</a></li><li><a href=#item-23-prefer-non-member-non-friend-functions-to-member-functions><strong>Item 23:</strong> Prefer non-member non-friend functions to member functions.</a></li><li><a href=#item-24-declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters><strong>Item 24:</strong> Declare non-member functions when type conversions should apply to all parameters.</a></li><li><a href=#item-25-consider-support-for-a-non-throwing-swap><strong>Item 25:</strong> Consider support for a non-throwing swap.</a></li></ol></li><li><a href=#ch5-implementations>Ch5: Implementations</a><ol><li><a href=#item-26-postpone-variable-definitions-as-long-as-possible><strong>Item 26:</strong> Postpone variable definitions as long as possible.</a></li><li><a href=#item-27-minimise-casting><strong>Item 27:</strong> Minimise casting.</a></li><li><a href=#item-28-avoid-returning-handles-to-object-internals><strong>Item 28:</strong> Avoid returning &ldquo;handles&rdquo; to object internals.</a></li><li><a href=#item-29-strive-for-exception-safe-code><strong>Item 29:</strong> Strive for exception-safe code.</a></li><li><a href=#item-30-understand-the-ins-and-outs-of-linlining><strong>Item 30:</strong> Understand the ins and outs of linlining.</a></li><li><a href=#item-31-minimise-compilation-dependencies-between-files><strong>Item 31:</strong> Minimise compilation dependencies between files.</a></li></ol></li><li><a href=#ch6-inheritance-and-object-oriented-design>Ch6: Inheritance and Object-Oriented Design</a><ol><li><a href=#item-32-make-sure-public-inheritance-models-is-a><strong>Item 32:</strong> Make sure public inheritance models &ldquo;is-a.&rdquo;</a></li><li><a href=#item-33-avoid-hiding-inherited-names><strong>Item 33:</strong> Avoid hiding inherited names.</a></li><li><a href=#item-34-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation><strong>Item 34:</strong> Differentiate between inheritance of interface and inheritance of implementation.</a></li><li><a href=#item-35-consider-alternatives-to-virtual-functions><strong>Item 35:</strong> Consider alternatives to virtual functions.</a></li><li><a href=#item-36-never-redefine-an-inherited-non-virtual-function><strong>Item 36:</strong> Never redefine an inherited non-virtual function.</a></li><li><a href=#item-37-never-redifine-a-functions-inherited-default-parameter-value><strong>Item 37:</strong> Never redifine a function&rsquo;s inherited default parameter value.</a></li><li><a href=#item-38-model-has-a-or-is-implemented-in-terms-of-throw-composition><strong>Item 38:</strong> Model &ldquo;has-a&rdquo; or &ldquo;is-implemented-in-terms-of&rdquo; throw composition.</a></li><li><a href=#item-39-use-private-inheritance-judiciously><strong>Item 39:</strong> Use private inheritance judiciously.</a></li><li><a href=#item-40-use-multiple-inheritance-judiciously><strong>Item 40:</strong> Use multiple inheritance judiciously.</a></li></ol></li><li><a href=#ch7-templates-and-generic-programming>Ch7: Templates and generic programming</a><ol><li><a href=#item-41-understand-implicit-interfaces-and-compile-time-polymorphism><strong>Item 41:</strong> Understand implicit interfaces and compile time polymorphism</a></li><li><a href=#item-42-understand-the-two-meanings-of-typename><strong>Item 42:</strong> Understand the two meanings of typename.</a></li><li><a href=#item-43-know-how-to-access-names-in-templatised-base-classes><strong>Item 43:</strong> Know how to access names in templatised base classes.</a></li><li><a href=#item-44-factor-parameter-independent-code-out-of-templates><strong>Item 44:</strong> Factor parameter-independent code out of templates</a></li><li><a href=#item-45-use-member-function-templates-to-accept-all-compatible-types><strong>Item 45:</strong> Use member function templates to accept &ldquo;all compatible types.&rdquo;</a></li><li><a href=#item-46-define-non-member-functions-inside-templates-when-type-conversions-are-desired><strong>Item 46:</strong> Define non-member functions inside templates when type conversions are desired</a></li><li><a href=#item-47-use-traits-classes-for-information-about-types><strong>Item 47:</strong> Use traits classes for information about types.</a></li><li><a href=#item-48-be-aware-of-template-metaprogramming><strong>Item 48:</strong> Be aware of template metaprogramming.</a></li></ol></li><li><a href=#ch8-customising-new-and-delete>Ch8: Customising <code>new</code> and <code>delete</code></a><ol><li><a href=#item-49-understand-the-behaviour-of-the-new-handler><strong>Item 49:</strong> Understand the behaviour of the new-handler</a></li><li><a href=#item-50-understand-when-it-makes-sense-to-replace-new-and-delete><strong>Item 50:</strong> Understand when it makes sense to replace new and delete</a></li><li><a href=#item-51-adhere-to-convention-when-writing-new-and-delete><strong>Item 51:</strong> Adhere to convention when writing <code>new</code> and <code>delete</code></a></li><li><a href=#item-52-write-placement-delete-if-you-write-placement-new><strong>Item 52:</strong> Write placement <code>delete</code> if you write placement <code>new</code></a></li></ol></li><li><a href=#ch9-miscellany>Ch9: Miscellany</a><ol><li><a href=#item-53-pay-attention-to-compiler-warnings><strong>Item 53:</strong> Pay attention to compiler warnings</a></li><li><a href=#item-54-familiarise-yourself-with-the-standard-library-including-tr1><strong>Item 54:</strong> Familiarise yourself with the standard library, including TR1</a></li><li><a href=#item-55-familiarise-yourself-with-boost><strong>Item 55:</strong> Familiarise yourself with Boost.</a></li></ol></li></ol></nav></details></aside><p>Author:
<a href=/digital-garden/Authors/Scott-Meyers/ rel=noopener class=internal-link data-src=/digital-garden/Authors/Scott-Meyers/>Scott Meyers</a><br>Topics:
<a href=/digital-garden/Topics/Software-Engineering/ rel=noopener class=internal-link data-src=/digital-garden/Topics/Software-Engineering/>Software Engineering</a></p><hr><a href=#ch1-accustoming-yourself-to-c><h2 id=ch1-accustoming-yourself-to-c><span class=hanchor arialabel=Anchor># </span>Ch1: Accustoming yourself to C++</h2></a><a href=#item-1-view-c-as-a-federation-of-languages><h3 id=item-1-view-c-as-a-federation-of-languages><span class=hanchor arialabel=Anchor># </span><strong>Item 1:</strong> View C++ as a federation of languages</h3></a><p>C++ is better understood as a group of related sub-languages. These are:</p><ul><li>C</li><li>Object-oriented C++</li><li>Template C++</li><li>The STL</li></ul><p>This is important to keep in mind as different sub-languages have different effective strategies and different conventions.</p><a href=#item-2-prefer-consts-enums-and-inlines-to-defines><h3 id=item-2-prefer-consts-enums-and-inlines-to-defines><span class=hanchor arialabel=Anchor># </span><strong>Item 2:</strong> Prefer consts, enums, and inlines to #defines</h3></a><p>Rule could also be called &ldquo;Prefer the compiler over the preprocessor&rdquo;.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// BAD
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define ASPECT_RATIO 1.653
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// GOOD
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>double</span> <span class=n>AspectRation</span> <span class=o>=</span> <span class=mf>1.653</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>authorName</span> <span class=o>=</span> <span class=s>&#34;Scott Meyers&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>authorName</span><span class=p>(</span><span class=s>&#34;Scott Meyers&#34;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>The preprocessor will blindly substitute ASPECT_RATIO for 1.653 resulting in multiple copies in the object code.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// BAD
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// GOOD
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=n>callWithMax</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>(</span><span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span><span class=p>:</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Function like macros can be very error prone. Calling <code>CALL_WITH_MAX(++a, b)</code> for example results in a being incremented twice.</p><a href=#item-3-use-const-whenever-possible><h3 id=item-3-use-const-whenever-possible><span class=hanchor arialabel=Anchor># </span><strong>Item 3:</strong> Use const whenever possible</h3></a><ul><li>Helps detect usage errors.</li><li>Using <code>const</code> in function declaration is extremely powerful so make use of it. It can refer to the function&rsquo;s return value, the individual parameters or even the function as a whole.</li><li>Compilers enforce &lsquo;bitwise constness&rsquo; but you should program using &rsquo;logical constness&rsquo;.<ul><li>Bitwise constness/Physical: does not modify any of object&rsquo;s data members</li><li>Logical constness: Some data members of an object can be modified but should be in ways the client cannot detect. Achieved using <code>mutable</code>. Also considers situations where something is bitwise const, but does not behave const. e.g. the altering of data members by returning non-const references.</li></ul></li><li>When const and non-const member functions have similar implementations, avoid duplication by calling const version in the non-const function and using <code>const_cast</code>.</li></ul><a href=#item-4-make-sure-objects-are-initialised-before-use><h3 id=item-4-make-sure-objects-are-initialised-before-use><span class=hanchor arialabel=Anchor># </span><strong>Item 4:</strong> Make sure objects are initialised before use</h3></a><p>The rules about when objects initialisation is guaranteed or not is too complicated to be worth memorising. Avoid the issue by <mark>always initialising</mark>.</p><ul><li>For non-member built in types, this needs to be done manually. e.g. <code>int x = 0;</code></li><li>For the rest, initialisation is the responsibility of the constructors and the use of initialisation list is preferred.</li></ul><a href=#ch2-constructors-destructors-and-assignment-operators><h2 id=ch2-constructors-destructors-and-assignment-operators><span class=hanchor arialabel=Anchor># </span>Ch2: Constructors, destructors and assignment operators</h2></a><a href=#item-5-know-what-functions-c-silently-writes-and-calls><h3 id=item-5-know-what-functions-c-silently-writes-and-calls><span class=hanchor arialabel=Anchor># </span><strong>Item 5:</strong> Know what functions C++ silently writes and calls</h3></a><p>Compilers will declare the following if you do not do so yourself:</p><ul><li>Copy constructor</li><li>Copy assignment operator</li><li>Destructor</li></ul><p>If no constructors are declared at all, compilers will also declare:</p><ul><li>Default constructor</li></ul><a href=#item-6-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want><h3 id=item-6-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want><span class=hanchor arialabel=Anchor># </span><strong>Item 6:</strong> Explicitly disallow the use of compiler-generated functions you do not want</h3></a><p>An example of an unwanted generated function is a copy constructor and copy assignment operator for objects that should not be copied.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>HomeForSale</span> <span class=n>h1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>HomeForSale</span> <span class=n>h2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>HomeForSale</span> <span class=nf>h3</span><span class=p>(</span><span class=n>h1</span><span class=p>);</span> <span class=c1>//should not compile
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>h1</span> <span class=o>=</span> <span class=n>h2</span><span class=p>;</span>            <span class=c1>// should not compile
</span></span></span></code></pre></td></tr></table></div></div><p>To achieve this there is a <mark>well known trick</mark>. Declare the functions private and do not implement them.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>HomeForSale</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>HomeForSale</span><span class=p>(</span><span class=k>const</span> <span class=n>HomeForSale</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>HomeForSale</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>ocnst</span> <span class=n>HomeForSale</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This trick works and generates a link-time error. It is possible to move
it up to a compile time error by declaring the functions private in a base
class designed just to prevent copying.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Disallow compiler generated function by declaring the function private and not providing an implementation</li></ul></blockquote><a href=#item-7-declare-destructors-virtual-in-polymorphic-base-classes><h3 id=item-7-declare-destructors-virtual-in-polymorphic-base-classes><span class=hanchor arialabel=Anchor># </span><strong>Item 7:</strong> Declare destructors virtual in polymorphic base classes</h3></a><p>Lets say you have a base class <code>TimeKeeper</code> and some derivided classes
that inherit from it:</p><ul><li>AtomicClock</li><li>WaterClock</li><li>WristWatch</li></ul><p>If you try to delete a derived class (e.g. WristWatch) with a base class
pointer (TimeKeeper), the results are undefined. Most likely, the derived
class parts of the object won&rsquo;t be deleted. This is a good way to leak
memory.</p><p>Solution is simple: <mark>give the base class a virtual destructor</mark>.</p><p>However, when a class is not meant to be used as a base class, making it
virtual is usually a bad idea. This is because virtual functions require the
use of vptr (&ldquo;virtual table pointers&rdquo;) which increases the size of the type.
A simple data type that contains two ints, would go from 64bits in size to
128bits. An increase of 100%. It also makes the object less portable to C.</p><p>If you want to make a class abstract that does not have functions to make
virtual, you can just give it a pure virtual destructor. This is because a
abstract classes are meant to be base classes and base classes should
have a virtual destructor.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Polymorphic base classes should declare virtual destructors.</li><li>Any class with virtual functions should have a virtual destructor.</li><li>Classes that aren&rsquo;t base classes should not declare virtual destructors.</li><li>Use a pure virtual destructor to make classes abstract that do not have functions</li></ul></blockquote><a href=#item-8-prevent-exceptions-from-leaving-destructors><h3 id=item-8-prevent-exceptions-from-leaving-destructors><span class=hanchor arialabel=Anchor># </span><strong>Item 8:</strong> Prevent exceptions from leaving destructors</h3></a><p>C++ allows destructors to emit exceptions but it is heavily discouraged.
This is because if an exception is thrown, for example, in a vector
containing 10 widgets, the rest of the widgets still need to be deleted or
there will be leak. However, if you then have another exception when
deleting the other widgets, now you have two simultaneous exceptions
which results in undefined behaviour.</p><p>Example class that closes database connection in destructor:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>DBConn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>DBConn</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>db</span><span class=p>.</span><span class=n>close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>DBConnection</span> <span class=n>db</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This will cause issues if the call to close results in an exception. The
exception will be propagated.</p><p>There are two options to fix this:</p><ul><li><mark>Terminate the program</mark> (e.g. with std::abort()). This is a reasonable solution if the program can no longer run due to the error.</li><li><mark>Swallow the exception</mark>. This is a bad idea as we need to know when something fails.</li></ul><p>The actual ideal solution is to create a function that closes the connection
in the DBConn interface so the client can react to the exception. Then
the backup call to &lsquo;close()&rsquo; can still be placed in the destructor. This may
seem like it goes against <em>item 11</em>, by placing an extra burden on the client,
however it is not as it actually <strong>gives</strong> them a chance to react to the
exception.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Destructors should never emit exceptions.</li><li>If a classes clients need to react to exceptions during an operation, offer a regular &rsquo;non-destrcutor&rsquo; function that performs the operation.</li></ul></blockquote><a href=#item-9-never-call-virtual-functions-during-construction-or-destruction><h3 id=item-9-never-call-virtual-functions-during-construction-or-destruction><span class=hanchor arialabel=Anchor># </span><strong>Item 9:</strong> Never call virtual functions during construction or destruction</h3></a><p>Don&rsquo;t call virtual functions during construction or destruction as they won&rsquo;t
do what you expect them to. If they did, it would lead to undefined
behaviour.</p><p>Example: Say you have a base class <code>Transaction</code> that is inherited by a
class called <code>BuyTransaction</code>. If you have a virtual function in Transaction
that is called during construction, it will call the base class version. Not
the derived version. This is because the base class is constructed first so
the derived members will not have been constructed yet.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Don&rsquo;t call virtual functions from constructors or destructors.</li></ul></blockquote><a href=#item-10-have-assignment-operators-return-a-reference-to-this><h3 id=item-10-have-assignment-operators-return-a-reference-to-this><span class=hanchor arialabel=Anchor># </span><strong>Item 10:</strong> Have assignment operators return a reference to <code>this</code></h3></a><p>Assignments can be chained together and is right associative.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>y</span> <span class=o>=</span> <span class=n>z</span> <span class=o>=</span> <span class=mi>15</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//equivalent to
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>y</span> <span class=o>=</span> <span class=p>(</span><span class=n>z</span> <span class=o>=</span> <span class=mi>15</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><p>This is implemented by assignments returning a reference to it&rsquo;s left hand argument. This is the convention that should be followed.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Widget</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=abstract-callout><p>Summary</p><ul><li>Have assignment operators return a reference to <code>*this</code></li></ul></blockquote><a href=#item-11-handle-assignment-to-self-in-operator><h3 id=item-11-handle-assignment-to-self-in-operator><span class=hanchor arialabel=Anchor># </span><strong>Item 11:</strong> Handle assignment to self in operator=.</h3></a><p>This looks silly but is allowed:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Widget</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>w</span> <span class=o>=</span> <span class=n>w</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>``
If it&rsquo;s allowed, clients will end up doing it. A less obvious version may look
like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// potential assignment to selfs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>px</span> <span class=o>=</span> <span class=o>*</span><span class=n>py</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>When writing resource managing classes you can fall into the trap of
accidentally releasing a resource before you&rsquo;re done with it:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Bitmap</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Bitmap</span> <span class=o>*</span><span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pb</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bitmap</span><span class=p>(</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>pb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Here you delete rhs not realising that it is the same as <code>this</code>. The
traditional fix is this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pb</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bitmap</span><span class=p>(</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>pb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This is now self-assignment safe but not exception safe. If <code>new Bitmap</code>
causes an exception, it will still cause issues.</p><p>Making operator= exception-safe also typically also renders it
self-assignment-safe. It is common to deal with self-assignment issues by
ignoring them and isntead focusing on exception safety. A careful ordering
of statements can make code exception safe. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Bitmap</span> <span class=o>*</span><span class=n>pOrig</span> <span class=o>=</span> <span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pb</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bitmap</span><span class=p>(</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>pb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>pOrig</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=tip-callout><p>Performance Hint</p><p>The identity test can still be placed at the top for efficiency, however,
consider how often self-assignment occurs. The check is not free. It
makes the source code and object bigger and introduces a branch.</p></blockquote><p>Alternative to manual ordering is the &ldquo;copy and swap&rdquo; technique.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>swap</span><span class=p>(</span><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span> <span class=c1>// exchanges *this and rhs&#39;s data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Widget</span> <span class=nf>temp</span><span class=p>(</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>swap</span><span class=p>(</span><span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The final variation sacrifices some clarity for allowing the compiler to
sometimes generate more efficient code.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Widget</span> <span class=n>rhs</span><span class=p>)</span> <span class=c1>// rhs is a copy of the object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>swap</span><span class=p>(</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=abstract-callout><p>Summary</p><ul><li>Make sure operator= can handle self-assignment in a well-behaved
manner</li><li>Make sure any function operating on more than one object behaves
well if two or more of the objects are the same.</li></ul></blockquote><a href=#item-12-copy-all-parts-of-an-object><h3 id=item-12-copy-all-parts-of-an-object><span class=hanchor arialabel=Anchor># </span><strong>Item 12:</strong> Copy all parts of an object.</h3></a><p>Well-designed objects contain only two functions that copy objects: the
copy constructor and copy assignment operator. Compilers will generate
these functions if required and do what you expect them to: copy all the
data of the object being copied.</p><p>However, when you declare your own copy functions, they do not warn you
when your implementation is wrong. You may forget to copy a newly
added data member and there will be no warnings.</p><p>Another way that you may run into issues is when using inheritance.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>PriorityCustomer</span><span class=o>:</span><span class=k>public</span> <span class=n>Customer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>PriorityCustomer</span><span class=p>(</span><span class=k>const</span> <span class=n>PriorityCustomer</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>PriorityCustomer</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>PriorityCustomer</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>priority</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PriorityCustomer</span><span class=o>::</span><span class=n>PriorityCustomer</span><span class=p>(</span><span class=k>const</span> <span class=n>PriorityCustomer</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>:</span> <span class=n>priority</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>priority</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>logCall</span><span class=p>(</span><span class=s>&#34;PriorityCustomer copy constructor&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PriorityCustomer</span><span class=o>&amp;</span>
</span></span><span class=line><span class=cl><span class=n>PriorityCustomer</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>PriorityCustomer</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>logCall</span><span class=p>(</span><span class=s>&#34;PriorityCustomer copy assignment operator&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>priority</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>priority</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This may look fine and appear to be copying everything, however,
crucially, they are not copying the data members it inherits from customer.
The fix to this would be the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PriorityCustomer</span><span class=o>::</span><span class=n>PriorityCustomer</span><span class=p>(</span><span class=k>const</span> <span class=n>PriorityCustomer</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>:</span> <span class=n>Customer</span><span class=p>(</span><span class=n>rhs</span><span class=p>)</span>                 <span class=c1>// invoke base class copy ctor
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>priority</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>priority</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>logCall</span><span class=p>(</span><span class=s>&#34;PriorityCustomer copy constructor&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PriorityCustomer</span><span class=o>&amp;</span>
</span></span><span class=line><span class=cl><span class=n>PriorityCustomer</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>PriorityCustomer</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>logCall</span><span class=p>(</span><span class=s>&#34;PriorityCustomer copy assignment operator&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Customer</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>rhs</span><span class=p>);</span>  <span class=c1>// assign base class parts
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>priority</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>priority</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=warning-callout><p>Warning</p><p>The two copy functions will have similar code but do not call one from
the other as it is a non-sensical operation. If you really must, have the
two call a third private function such as init().</p></blockquote><blockquote class=summary-callout><p>Summary</p><ul><li>Make sure copy functions copy all of an object&rsquo;s data members
including the base class parts.</li><li>Don&rsquo;t implement one copy function in terms of the other. Put common
code in a third function.</li></ul></blockquote><a href=#ch3-resource-management><h2 id=ch3-resource-management><span class=hanchor arialabel=Anchor># </span>Ch3: Resource management</h2></a><a href=#item-13-use-objects-to-manage-resources><h3 id=item-13-use-objects-to-manage-resources><span class=hanchor arialabel=Anchor># </span><strong>Item 13:</strong> Use objects to manage resources</h3></a><p>Managing resources manually is very error prone and should be avoided.
Consider the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Investment</span> <span class=o>*</span> <span class=n>pInv</span> <span class=o>=</span> <span class=n>createInvestment</span><span class=p>();</span> <span class=c1>// factory function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>                                     <span class=c1>// use pInv
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>pInv</span><span class=p>;</span>                            <span class=c1>// release object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This may look reasonable but there are many ways it could fail to delete
<code>pInv</code>. if there is a pre-mature return within the function, control would
never reach the delete. Another situation is if <code>createInvestment()</code> and
<code>delete pInv</code> were in a loop that then breaks early. When this happens,
there will be a leak which will also affect any other resources helf by
<em>that</em> object.</p><p>Technically, carefull programming an avoid this issues, but this is not
realistic. As the code is maintained, someone may add a pre-mature return
without realising the consequences. Or someone may add an exception in a
function that did not use exceptions which will then cause a leak.</p><p>To avoid all of this, we can put resources into a resource managing object
which will then free the resources automatically when the destructor is
called.</p><p>The STL has smart pointers that are tailormade for resources that are
dynamically allocated on the heap and are used only within a single
block or function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Investment</span><span class=o>&gt;</span> <span class=n>pInv</span><span class=p>(</span><span class=n>createInvestment</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This example demonstrates two critical aspects of using objects to manage
resources:</p><ul><li>==<strong>Resources are acquired and immediately turned over to
resource-managing objects.</strong>== The idea that resources are acquired and
immediately turned over to a resource managing object is referred to as
<em>Resource Acquisition is Initialization</em>(RAII).</li><li>==<strong>Resource-managing objects use their destructors to ensure that
resources are released.</strong>== Destructors are automatically called when an object
goes out of scope so resources are released regardless of how control
leaves a block.</li></ul><blockquote class=abstract-callout><p>Summary</p><ul><li>To prevent leaks, use RAII objects that acquire objects in their
constructor and delete them in their destructor</li><li>Two most common RAII classes are std::unique_ptr and
std::shared_ptr</li></ul></blockquote><a href=#item-14-think-carefully-about-copying-behaviour-in-resource-managing-classes><h3 id=item-14-think-carefully-about-copying-behaviour-in-resource-managing-classes><span class=hanchor arialabel=Anchor># </span><strong>Item 14:</strong> Think carefully about copying behaviour in resource-managing classes</h3></a><p>Not all resources are heap based. For these resources, unique_ptr and
shared_ptr are generally inappropriate as resource handlers.</p><p>For example, if you create a RAII class called <code>Lock</code> that unlocks a mutex
in it&rsquo;s destructor so you never forget to unlock a mutex. What should
happen if this object is copied?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Lock</span> <span class=nf>ml1</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Lock</span> <span class=nf>ml2</span><span class=p>(</span><span class=n>ml1</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>There are a few valid options:</p><ul><li><strong>Prohibit copying:</strong> In many cases it makes no sense to copy a RAII object.
In these situations you should just prohibit it (item 6). This is likely to be
true for an object such as <code>Lock</code>.</li><li><strong>Reference-count the underlying resource:</strong> Sometimes you may want to
hold on to a resource until there are no more objects using it. In this
situation a copy means that the count of objects referring to the resource
is incremented. A shared_ptr should be used to implement this behaviour.
shared_ptr also allows using a custom &ldquo;deleter&rdquo; where you can specify
a different behaviour (such as unlocking a mutex) instead when the
reference count goes to 0.</li><li><strong>Copy the underlying resource:</strong> Sometimes you can have as many copies
as you want of a resource. The only reason to have a resource-managing
class would be to ensure resources are released. In this case, copying the
RAII object should also mean copying the resource it wraps. An example
would be std::string.</li><li><strong>Transfer ownership of the underlying resource:</strong> In rare situations, you
may want to ensure that only one RAII object refers to a resource. Here
you will want to make sure that a copy means that ownership is
transferred.</li></ul><p>Remember that copying function will be generated by the compiler so you
will need to need to write the custom behaviour yourself.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Copying an RAII object entails copying the resource it manages. The
correct behaviour of the RAII object depends on the copying behaviour
of the underlying resource.</li><li>Common RAII class copying behaviours are: disallowing copy and
reference counting. However, there are others.</li></ul></blockquote><a href=#item-15-provide-access-to-raw-resources-in-resource-managing-classes><h3 id=item-15-provide-access-to-raw-resources-in-resource-managing-classes><span class=hanchor arialabel=Anchor># </span><strong>Item 15:</strong> Provide access to raw resources in resource-managing classes</h3></a><p>Resource-managing classes are great but they can&rsquo;t always be fully relied
on. Many APIs refer to the resources directly so from time to time you will
need to deal with raw resources.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>daysHeld</span><span class=p>(</span><span class=k>const</span> <span class=n>Investment</span><span class=o>*</span> <span class=n>pi</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>There are two ways to convert a RAII object to the resource it contains:
explicit conversion and implicit conversion.</p><p>Smart pointers contain a <code>get</code> member function that performs an explicit
conversion i.e. returns a copy of the raw pointer inside the smart pointer
object.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>days</span> <span class=o>=</span> <span class=n>daysHeld</span><span class=p>(</span><span class=n>pInv</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><p>As for implicit conversion, it is a bit more dangerous but can sometimes
still be the correct choice. Here is an example of a Font class that
manages an underlying FontHandle resource with an implicit conversion
function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Font</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=n>FontHandle</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>f</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>FontHandle</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// explicit conversion used to call changeFontSize
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>changeFontSize</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>get</span><span class=p>(),</span> <span class=n>newFontSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// implicit conversion version of same code
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>changeFontSize</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>newFontSize</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>However, now a client might accidentally create a FontHandle when a font
was intended.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Font</span> <span class=nf>f1</span><span class=p>(</span><span class=n>getFont</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>FontHandle</span> <span class=n>f2</span> <span class=o>=</span> <span class=n>f1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// meant to copy a font object but implicityly converted f1
</span></span></span><span class=line><span class=cl><span class=c1>// into its underlying FontHandle and then copied that
</span></span></span></code></pre></td></tr></table></div></div><p>Now the same FontHandle is being used in f1 and f2 which will then result
in a dangling pointer.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>APIs often require access to raw resources so RAII classes should
offer a way to access the resource it manages.</li><li>Access may be explicit or implicit. Explicit is safer but implicit is
more convenient.</li></ul></blockquote><a href=#item-16-use-the-same-form-in-corresponding-uses-of-new-and-delete><h3 id=item-16-use-the-same-form-in-corresponding-uses-of-new-and-delete><span class=hanchor arialabel=Anchor># </span><strong>Item 16:</strong> Use the same form in corresponding uses of <code>new</code> and <code>delete</code></h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>*</span><span class=n>stringArray</span> <span class=o>=</span> <span class=k>new</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>[</span><span class=mi>100</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>stringArray</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>The above code is wrong as you are constructing an array of objects but
deleting only 1 object. <code>new</code> allocates only enough space for an object and
then constructs that object if its a single object. For an array, it also
includes the memory required to store information on the size of the array.
Therefore, when you delete an array, you need to access the information.
This can only be done if you tell the compiler that the information is there
by using <code>delete []</code>.</p><blockquote class=warning-callout><p>Warning</p><ul><li>Make sure to use same for of <code>new</code> in all of your constructors so you
know which form to call in the destructor.</li><li>Abstain from using array types in <code>typedefs</code> so there is no confusion
on which form of <code>delete</code> to call when using a typedef.</li></ul></blockquote><blockquote class=abstract-callout><p>Summary</p><ul><li>Match the forms of <code>new</code> and <code>delete</code>. <code>new</code> requires a corresponding
<code>delete</code> and <code>new []</code> would require a corresponding <code>delete []</code>.</li></ul></blockquote><a href=#item-17-store-newed-objects-in-smart-pointers-in-standalone-statements><h3 id=item-17-store-newed-objects-in-smart-pointers-in-standalone-statements><span class=hanchor arialabel=Anchor># </span><strong>Item 17:</strong> Store newed objects in smart pointers in standalone statements</h3></a><p>Consider a situation where we have a function that returns a priority and
a function that processes a dynamically allocated Widget.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>priority</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processWidget</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=n>pw</span><span class=p>,</span> <span class=kt>int</span> <span class=n>priority</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Now consider the following way to call processWidget.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>processWidget</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_Ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>Widget</span><span class=p>),</span> <span class=n>priority</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><p>Three things need to happen:</p><ul><li>Call priority()</li><li>Execute &rsquo;new Widget&rsquo;</li><li>Call the shared_ptr constructor</li></ul><p>Compilers have leeway over which order these things are done. The order
they are done could be:</p><ul><li>Execute &rsquo;new Widget'</li><li>Call priority()</li><li>Call shared_ptr constructor</li></ul><p>The problem can now be seen. If there is an exception when priority() is
called, the pointer returned from &rsquo;new Widget&rsquo; will be lost and not stored
in the shared_ptr we used to guard against leaks.</p><p>To prevent this, use a separate statement to create and store the Widget
resource.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=n>pw</span><span class=p>(</span><span class=k>new</span> <span class=n>Widget</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>processWidget</span><span class=p>(</span><span class=n>pw</span><span class=p>,</span> <span class=n>priority</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><p>The revised code has less leeway to reorder the various components that
made the previous 1 line version of these two statements.</p><blockquote class=summary-callout><p>Summary</p><ul><li>Store newed objects in smart pointers in standalone statements.
Not doing so can lead to subtle resource leaks if exceptions are thrown.</li></ul></blockquote><a href=#ch4-designs-and-declarations><h2 id=ch4-designs-and-declarations><span class=hanchor arialabel=Anchor># </span>Ch4: Designs and declarations</h2></a><a href=#item-18-make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly><h3 id=item-18-make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly><span class=hanchor arialabel=Anchor># </span><strong>Item 18:</strong> Make interfaces easy to use correctly and hard to use incorrectly.</h3></a><p>If clients use your code incorrectly, <mark>your interface is partially to blame</mark>.
Consider the design below for a Date class:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Date</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Date</span> <span class=p>(</span><span class=kt>int</span> <span class=n>month</span><span class=p>,</span> <span class=kt>int</span> <span class=n>day</span><span class=p>,</span> <span class=kt>int</span> <span class=n>year</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Two errors can easily happen:</p><ul><li>Client passes in day value into month. <code>Date d(30, 3, 1995);</code></li><li>Client passes in invalid value for month or date. <code>Date d(3, 40, 1995);</code></li></ul><p>Many similar client errors can be fixed by using simple wrapper with
explicit constructors.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Day</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=nf>Day</span><span class=p>(</span><span class=kt>int</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>val</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Date</span><span class=o>::</span><span class=n>Date</span><span class=p>(</span><span class=k>const</span> <span class=n>Month</span><span class=o>&amp;</span> <span class=n>m</span><span class=p>,</span> <span class=k>const</span> <span class=n>Day</span><span class=o>&amp;</span> <span class=n>d</span><span class=p>,</span> <span class=k>const</span> <span class=n>Year</span><span class=o>&amp;</span> <span class=n>y</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Full fledged classes for day, month and year would be even better but
even structs are enough to show that introducing types can prevent a
interface usage errors.</p><p>Once the right types are being used, you can then progress to limiting the
values of those types if it is reasonable to do so. Enums can be used to do
this but they are not as typesafe as we would like as they can be used like
ints.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Month</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Month</span> <span class=nf>Jan</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>Month</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Month</span> <span class=nf>Feb</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>Month</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>Date</span> <span class=nf>d</span><span class=p>(</span><span class=n>Month</span><span class=o>::</span><span class=n>Mar</span><span class=p>(),</span> <span class=n>Day</span><span class=p>(</span><span class=mi>30</span><span class=p>),</span> <span class=n>Year</span><span class=p>(</span><span class=mi>1995</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=tip-callout><p>Hint</p><p>This item was probably written before scoped enums (enum classes)
were available. Now you probably could replace this with enum classes.</p></blockquote><p><em>Another way to prevent client errors is to add const.</em> For example you
can const qualify operator* which can prevent this error<br><code>if (a * b = c)...</code><br>This is an assignment when it should have been a comparison.</p><p><em>Try to make your interfaces behave consistently as possible.</em> Consistency
is one of the most important characteristic to making easy to use
interfaces. Conversely, inconsistency leads to aggravating interfaces</p><p><em>Any interface that relies on the client to remember to do something is
prone to incorrect use, because clients cant forget to do it.</em> An example
is returning raw pointers.<br><code>Investment* createInvestment();</code><br>This function creates the opportunity for two errors: not deleting the
pointer and deleting it twice. This can be avoided by returning a smart
pointer in the first place.<br><code>std::shared_ptr&lt;Investment> createInvestment();</code><br>In fact shared_pt also make sit possible to get rid of other errors with the
ability to specify a custom release function (deleter). It can also get rid
of the cross-DLL problem. This is a problem where an object is created
using <code>new</code> in one DLL but is deleted in a different DLL. shared_ptr gets
rid of this as its default deleter uses <code>delete</code> from the same DLL where
shared_ptr is created.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Strive to create interfaces that are easy to use correctly but difficult
to use incorrectly.</li><li>For correct use: maintain consistency in interfaces and use built-in
types for behavioural compatiblity.</li><li>For error prevention: create new types, restrict operations on types,
constrain object values, and eliminate client resource management
responsibilities.</li><li>std::shared_ptr supports custom deleters. This prevents cross DLL
problem and can be used to automatically unlock mutexes.</li></ul></blockquote><a href=#item-19-treat-class-design-as-type-design><h3 id=item-19-treat-class-design-as-type-design><span class=hanchor arialabel=Anchor># </span><strong>Item 19:</strong> Treat class design as type design.</h3></a><p>Look at class designing as type designing. This means as a C++ developer
you are a <em>type designer</em>. Designing good classes is a challenge because
designing good types are a challenge.</p><p>To understand the issues you face which will help you design your type
you should consider the following questions:</p><ul><li>How should objects of your new type be created and destroyed?</li><li>How should object initialisation differ from object assignment?</li><li>What does it mean for objects of your new type to be passed by value?</li><li>What are the restrictions on legal values of your new type?</li><li>Does your new type fit into an inheritance graph?</li><li>What kind of type conversion are allowed for your new type? - consider
implicit and explicit conversions. You may need conversion functions if you
are looking to make it explicit only.</li><li>What operators and functions make sense for the new type?</li><li>What standard functions should be disallowed? - declare them private or
delete them(C++11).</li><li>Who should have access to the members of your new type?</li><li>What is the &ldquo;undeclared interface&rdquo; of your new type? - what guarantees
does it offer with respect to performance, exception safety and resource
usage.</li><li>How general is your new type?</li><li>Is a new type really what you need? - if it&rsquo;s a family of types, you
might want a class template.</li></ul><blockquote class=abstract-callout><p>Summary</p><p>Class design is type design. When designing a new type, consider all 12
questions listed in this item.</p></blockquote><a href=#item-20-prefer-pass-by-reference-to-const-to-pass-by-value><h3 id=item-20-prefer-pass-by-reference-to-const-to-pass-by-value><span class=hanchor arialabel=Anchor># </span><strong>Item 20:</strong> Prefer pass-by-reference-to-const to pass-by-value.</h3></a><p>C++ passes by value by default - function parameters are initialised with
copies of the actual argument and function callers get back a copy of the
returned value. These copies are produced by the objects copy constructor
which makes it an expensive operation.</p><p>Consider the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Person</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>address</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=o>:</span> <span class=k>public</span> <span class=n>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Student</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Student</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>schoolName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>schoolAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// function declaration
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>validateStudent</span><span class=p>(</span><span class=n>Student</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Student</span> <span class=n>plato</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>platoIsOk</span> <span class=o>=</span> <span class=n>validateStudent</span><span class=p>(</span><span class=n>plato</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>When the validateStudent function is called the cost is 1 call to the
copy constructor to initialise the parameter and one call to the destructor
when the function returns. Furthermore, the strong objects are also copied
and destroyed. With construction and destruction of the 4 strings
accounted for, ther are 6 calls to constructors and destructors.</p><p>Pass by reference-to-const solves this. The const is essential as
previously the callers were shielded from any changes happening to the
Student object as it was a copy. Now that it is a reference, const is
required to provide that assurance.</p><p>Passig parameters by reference also prevents the <em>slicing problem</em>. This is
when you pass a derived class into a function that accepts the base class.
If you do this by value, the base class constructor will be called and the
derived class part of the object will not be copied. Then when you call the
function that may have been overriden in the derived class, the base class
version will be called.</p><p>If you pass by reference (or pointer) the object will behave like the actual
object that is passed in.</p><p>References are implemented as pointers under the hood of a C++ compiler.
This means that for built-in types (e.g.int) it is reasonable to choose to
pass-by-value.</p><p>Built-in types are small which can lead people to conclude that small types
can be good pass-by-value candidates. However, there are a few reasons
that this should not be done. Small types can sometimes be only small
as they contain only a pointer, however, the object that the pointer points
to might then be expensive to copy. Another reason is that compilers will
treat built-in types differently to user-defined types. For example,
compilers can refuse to put user-defined types that consist of just a
double in the register even if it will do so with a naked double. Finally,
user-defined types might change in the future so something that is small
now can increase in size later.</p><p>==Generally, only built-in types, STL iterators and function object types can
reasonably be assumed as good pass-by-value candidates==.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Prefer pass-by-reference-to-const over pass-by-value for efficiency
and to sidestep the slicing problem.</li><li>The exceptions to the rule are built-in types, STL iterators and
function object types.</li></ul></blockquote><a href=#item-21-dont-try-to-return-a-reference-when-you-must-return-an-object><h3 id=item-21-dont-try-to-return-a-reference-when-you-must-return-an-object><span class=hanchor arialabel=Anchor># </span><strong>Item 21:</strong> Don&rsquo;t try to return a reference when you must return an object.</h3></a><p>Do not be over zealous in the pursuit of eliminating the &rsquo;evil&rsquo; of
pass-by-value. This can lead to passing references of objects that do not
exist.</p><p>Consider a class representing rational numbers.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Rational</span><span class=p>(</span><span class=kt>int</span> <span class=n>numerator</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=kt>int</span> <span class=n>denominator</span> <span class=o>=</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>friend</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Rational</span>
</span></span><span class=line><span class=cl>      <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>operator*</code> function returns the result object by value. The question is,
can you avoid the cost of the object&rsquo;s deconstruction and construction?</p><p>Example scenario:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Rational</span> <span class=nf>a</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span> <span class=c1>// 1/2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Rational</span> <span class=nf>b</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// 3/5
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Rational</span> <span class=n>c</span> <span class=o>=</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span> <span class=c1>// 1/2 x 3/5 = 3/10
</span></span></span></code></pre></td></tr></table></div></div><p>It may be tempting to consider the following implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Rational</span> <span class=nf>result</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>n</span> <span class=o>*</span> <span class=n>rhs</span><span class=p>.</span><span class=n>n</span><span class=p>,</span> <span class=n>lhs</span><span class=p>.</span><span class=n>d</span> <span class=o>*</span> <span class=n>rhs</span><span class=p>.</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span> <span class=c1>// returns a reference
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This is useless as the constructor and deconstructor is still being called.
More crucially though, the function returns a reference to a local object
which will immediately go out of scope and we are in undefined territory.</p><p>Now you might consider returning a reference to an object on the heap.
Yet again, this would be bad. You still have to pay for the constructor, but
now the client needs to remember to delete the newed object. And even if
they are, how do they handle a situation like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Rational</span> <span class=n>w</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>w</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>*</span> <span class=n>z</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>There are two calls to operator* but now way to delete the first call. This
is a guaranteed resource leak.</p><p>Using a static &lsquo;result&rsquo; object is also a no go. It will run into problems with
situations like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Rational</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>)</span> <span class=o>==</span> <span class=p>(</span><span class=n>c</span> <span class=o>*</span> <span class=n>d</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span></code></pre></td></tr></table></div></div><p>This will always be true as there are two active calls to operator* when
operator== is called. They will always be equal as they share the static
result object.</p><p>The right answer is simply something such as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kr>inline</span> <span class=k>const</span> <span class=n>Rational</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>Rational</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>n</span> <span class=o>*</span> <span class=n>rhs</span><span class=p>.</span><span class=n>n</span><span class=p>,</span> <span class=n>lhs</span><span class=p>.</span><span class=n>d</span> <span class=o>*</span> <span class=n>rhs</span><span class=p>.</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=abstract-callout><p>Summary</p><p>Never return a pointer or reference to a local stack object, a reference
to a heap-allocated object, or a pointer or reference to a local static
object if there is a chance that more than one such object will be
needed.</p></blockquote><a href=#item-22-declare-data-members-private><h3 id=item-22-declare-data-members-private><span class=hanchor arialabel=Anchor># </span><strong>Item 22:</strong> Declare data members private.</h3></a><p>The case for this item will follow this format: highlight why public data
members is bad -> highlight why all the arguments also apply to protected
members -> conclude that private is the way to go.</p><p>If everything in the public interface is a function, clients won&rsquo;t have to
recall whether to use parantheses to access members or not. Consistency.</p><p>Functions provide fine-grained control over the accessiblity of it&rsquo;s data
members.</p><p>Finally, encapsulation. If access to a data member is via a function, it is
possible to then later replace the data member with a computation and your
clients will not be aware or need to be aware at all.</p><p>A quick example is a class that contains speed data:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpeedDataCollection</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>addValue</span><span class=p>(</span><span class=kt>int</span> <span class=n>speed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=nf>averageSoFar</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>You can use an approach that maintains a data member that contains the
running average and the <code>averageSoFar()</code> function just returns this value OR
an approach where the <code>averageSoFar()</code> is calculated from all the stored
values whenever it is called. One has better performance on
<code>averageSoFar()</code> at the cost of space and the other has worse performance
but doesn&rsquo;t take as much space.<br>With encapsulation, you can interchange these easily.</p><p><mark>Encapsulation is more valuabled than it might initially appear</mark>. If data
members are hidden, class invariants can be maintained. This has benefits
when it comes to threaded environments as well. ==Hiding details is like
reserving the right to change the implementation details at a later date==.
You will realise that even if you own the source code to a class, your
ability to change anything public will be severely limited.</p><p><em>The argument for protected members is identical</em>. This is because
somethings encapsulation is inversely proportional to the amount of code
that could break if that something changes. For public members this can
be &lsquo;all client code&rsquo; which is an unknowably large amount. How about for
protected members? The answer is &lsquo;all the derived classes that access it&rsquo;
which is yet again an unknowably large amount of code.</p><p>==Essentially there are two levels of access: private and everything
else.==</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Declare data members private.</li><li>Protected is no more encapsulated than private.</li></ul></blockquote><a href=#item-23-prefer-non-member-non-friend-functions-to-member-functions><h3 id=item-23-prefer-non-member-non-friend-functions-to-member-functions><span class=hanchor arialabel=Anchor># </span><strong>Item 23:</strong> Prefer non-member non-friend functions to member functions.</h3></a><p>Consider a web browser class which may have functions to manage the
cache, history and cookies:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>WebBrowser</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>clearCache</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>clearHistory</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>removeCookies</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Now consider two ways of implementing a function that combines all three.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>WebBrowser</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>clearEverything</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>clearBrowser</span><span class=p>(</span><span class=n>WebBrowser</span><span class=o>&amp;</span> <span class=n>wb</span><span class=p>)</span> <span class=c1>// non-member function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>wb</span><span class=p>.</span><span class=n>clearCache</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>wb</span><span class=p>.</span><span class=n>clearHistory</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>wb</span><span class=p>.</span><span class=n>removeCookies</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Which is better? The member or non-member function? A misunderstanding
of object oriented principles may lead people to conclude that data and
functions that operate on them should be bundled together. This is wrong.
Object oriented principles dictate that data should be as <em>encapsulated</em> as
possible.</p><p>The greater something is encapsulated, the greater our ability to change
it. Adding another member function increases the public functions that
access the private data members. In the example it would go from 3 to 4.
However, the non-member function does not affect the number of
functions that can access the private parts of the class. Therefore, it is
more encapsulated with a non-member function.</p><p>A way to &lsquo;bundle&rsquo; convenience/utility functions without affecting
encapsulation is to use namespaces. This is a very flexible approach as
convenience functions can be spread out over different files but in the
same namespace. Clients can then selectively <code>#include</code> only the parts
that they require. It also allows for easy extensibility by the clients
or by the writers in future.</p><blockquote class=abstract-callout><p>Summary</p><p>Prefer non-member non-friend fucntions to member functions. Doing so
increases encapsulation, packaging flexibility, and functional
extensibility.</p></blockquote><a href=#item-24-declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters><h3 id=item-24-declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters><span class=hanchor arialabel=Anchor># </span><strong>Item 24:</strong> Declare non-member functions when type conversions should apply to all parameters.</h3></a><p>Classes supporting implicit type conversions is generally a bad idea,
however there are exceptions. A common exception is for numerical types.</p><p>Consider a <code>Rational</code> class:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Rational</span><span class=p>(</span><span class=kt>int</span> <span class=n>numerator</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>denominator</span> <span class=o>=</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>numerator</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>denominator</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Next lets say you want to support multiplication of Rational numbers. The
question is should it be implemented as a member function, non-member
function or non-member function that are friends.</p><p>Well lets consider the member function version:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Rational</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This design allows for the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Rational</span> <span class=nf>oneEighth</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Rational</span> <span class=nf>oneHalf</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Rational</span> <span class=n>result</span> <span class=o>=</span> <span class=n>oneHalf</span> <span class=o>*</span><span class=n>oneEighth</span><span class=p>;</span>  <span class=c1>//fine
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span> <span class=o>=</span> <span class=n>result</span> <span class=o>*</span> <span class=n>oneEighth</span><span class=p>;</span>           <span class=c1>//fine
</span></span></span></code></pre></td></tr></table></div></div><p>However, you also want to support mixed-mode operations where Rationals
might be multiplied with ints for example. Lets see what happens.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>oneHalf</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>       <span class=c1>//fine
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>oneHalf</span><span class=p>;</span>       <span class=c1>//error
</span></span></span></code></pre></td></tr></table></div></div><p>The source of the problem is clearer if you rewrite it:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>oneHalf</span><span class=p>.</span><span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>    <span class=c1>//fine
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span> <span class=o>=</span> <span class=mf>2.</span><span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=n>oneHalf</span><span class=p>);</span>    <span class=c1>//error
</span></span></span></code></pre></td></tr></table></div></div><p>oneHalf is an instance of a class containing the operator* where as 2 is
not. But then this raises the question, why does it work when you pass
in an int (2)? This is because of implicit conversion. Compilers can figure
out that although you are passing an int into a function that requires a
<code>Rational</code>, the int can be use to construct the <code>Rational</code> so that&rsquo;s what it
does.</p><p>This means that if the constructor for <code>Rational</code> was declared explicit,
then it would fail.</p><p>Anyhow, the key to the solution of supporting operations both ways around
is that implicit conversion is only available for parameters that are listed
in the parameter list. Here is the solution:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>   <span class=c1>// operator* not defined/declared
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Rational</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Rational</span> <span class=nf>oneFourth</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Rational</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>oneFourth</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>oneFourth</span><span class=p>;</span>   <span class=c1>// both finally working
</span></span></span></code></pre></td></tr></table></div></div><p>Should we make this function a friend function? No. It can already achieve
what it needs to do without breaking encapsulation. A function should not
be made a friend just because it is &lsquo;related&rsquo; to it.</p><blockquote class=abstract-callout><p>Summary</p><p>If you need type conversions on all parameters to a function including
the one pointed to by <code>this</code>, the function must be a non-member.</p></blockquote><a href=#item-25-consider-support-for-a-non-throwing-swap><h3 id=item-25-consider-support-for-a-non-throwing-swap><span class=hanchor arialabel=Anchor># </span><strong>Item 25:</strong> Consider support for a non-throwing swap.</h3></a><p>Swap is an interesting function that is worth some special consideration.
Here is a default implementation for swap:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>std</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>swap</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=nf>temp</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This default implementation may not thrill you as it involves copying three
objects. For some types, none of this copies will be necessary. For types
like this, the default swap implementation will slow down your code.</p><p>The most common example for types like these are those consisting
primarily of pointers to another type that then contains the real data. A
common manifestation of this design approach is the &ldquo;pimpl idiom&rdquo;
(&ldquo;pointer to implementation&rdquo; - item 31). An example using a Widget class:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>WidgetImpl</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span><span class=n>c</span><span class=p>;</span>             <span class=c1>//possibly lots of data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>  <span class=c1>//expensive to copy
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Widget</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Widget</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>ocnst</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pImpl</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>pImpl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>WidgetImpl</span> <span class=o>*</span><span class=n>pImpl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>In this example, all we need to do to swap Widget objects is to swap
their underlying <code>pImpl</code> pointers. However, the default swap function does
not know this. It would result in copy three widgets and ALSO three
WidgetImpl objects. Very inefficient.</p><p>We would like to tell std::swap how to more efficiently handle the swap.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>std</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>swap</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>pImpl</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>pImpl</span><span class=p>);</span>  <span class=c1>// wont compile. private ptrs
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The &ldquo;template&lt;>&rdquo; at the begining of the fucntion says that this is a <em>total
template specialisation</em> for std::swap and the &ldquo;&lt; Widget >&rdquo; after the name
of the function says that the specialisation is for when T is Widget.</p><p>In general, we are not permitted to alter contents of the std namespace,
but we are allowed to totally specialise standard template for our own
types.</p><p>The above code won&rsquo;t compile due to <code>pImpl</code> being private. We could make
the specialisation a friend, but the convention is to declare a public
member function calle dswap that does the actual swapping, then
specialise the std::swap to call the member function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>swap</span><span class=p>(</span><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>;</span> <span class=c1>//need for this explained below
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>swap</span><span class=p>(</span><span class=n>pImpl</span><span class=p>,</span> <span class=n>other</span><span class=p>.</span><span class=n>pImpl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>std</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>swap</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This compiles AND is consistent with the STL containers.</p><p>But what if <code>Widget</code> and <code>WidgetImpl</code> were class <em>templates</em> instead of
classes. Putting a swap member function in Widget is as easy as before.
The trouble arises with the specialisation. We &lsquo;want&rsquo; to write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>std</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>swap</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=p>(</span><span class=n>Widget</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>a</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>Widget</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=n>a</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>b</span><span class=p>);}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This looks reasonable but is illegal code. C++ supports partial
specialisation for classes but not function templates. To partially
specialise a function template, the usual approach is to simply use an
overload.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>std</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>tempalte</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>swap</span><span class=p>(</span><span class=n>Widget</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>Widget</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=n>a</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>b</span><span class=p>);}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>In general this would be fine, but the std namespace is special. You can
totally specialize templates in std, but you can&rsquo;t add new templates (or
classes or functions or anything else). If you break this rule, you are
once again in the land of <code>undefined</code>.</p><p>So what do we actually do? We still declare a non-member swap that calls
the member swap, we just don&rsquo;t declare the non-member to be a
specialisation or overloading of std::swap.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>WidgetStuff</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Widget</span><span class=p>{...};</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>swap</span><span class=p>(</span><span class=n>Widget</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>Widget</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>a</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>b</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Now, if any code anywhere calls swap on two Widget objects, the name
lookup rules in C++ will find the Widget-specific version in WidgetStuff.</p><p>This approach works as well for classes as for class templates, so it
seems like we should use it always. Unfortunately, there is a special
reason for specialising std::swap for classes, so if you want to have
your class specific swap be called in as many contexts as possible
(which you definitely do), you need to write a non-member version in
the same namespace as your class AND a specialisation of std::swap.</p><p>The above is for <code>swap</code> authors but we should consider one thing for th
clients.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doSomething</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>obj1</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>obj2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>swap</span><span class=p>(</span><span class=n>obj1</span><span class=p>,</span> <span class=n>obj2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Which swap does this call? The general one in std? or the specialisation of
the std? or a T-specific one? What you want to do is try to use the
T-specific one, but if not fall back on the general std::swap.<br>Heres how you can do this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doSomething</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>obj1</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>obj2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>;</span>        <span class=c1>// make std::swap available
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>swap</span><span class=p>(</span><span class=n>obj1</span><span class=p>,</span> <span class=n>obj2</span><span class=p>);</span>       <span class=c1>// call best swap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The C++ lookup rules will ensure the best swap is called so don&rsquo;t worry
too much. Just remember not to qualify it:
<code>std::swap(obj1, obj2);</code><br>Qualifying swap does happen, that&rsquo;s why it&rsquo;s in your best interest to aslo
implement the specialised version.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Provide a swap member function when std::swap would be
infefficient for your type. Make sure swap does not throw exceptions.</li><li>If you offer a member swap, make sure to also offier a non-member
swap that calls the member. For classes (not templates), specialise
std::swap too.</li><li>When calling swap, employ a using declaration for std::swap, then
call swap without namespace qualification.</li><li>It&rsquo;s fine to totally specialise std templates for user-defined type,
but never try to add something completely new to std.</li></ul></blockquote><a href=#ch5-implementations><h2 id=ch5-implementations><span class=hanchor arialabel=Anchor># </span>Ch5: Implementations</h2></a><p>The lion&rsquo;s share of the battle is coming up with appropriate definitions for
your classes and appropriate declarations for your functions. However,
there are still implementation details to look out for.</p><a href=#item-26-postpone-variable-definitions-as-long-as-possible><h3 id=item-26-postpone-variable-definitions-as-long-as-possible><span class=hanchor arialabel=Anchor># </span><strong>Item 26:</strong> Postpone variable definitions as long as possible.</h3></a><p>Defining a variable of a type with a constructor or destructor incurs the
cost of construction and then the cost of destruction when the variable
goes out of scope. Due to the inherent cost of using a variable, you want
to avoid using them if possible.</p><p>Consider a function that returns an encrypted version of a password if the
password is long enough:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>encryptPassword</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>password</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>encrypted</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>password</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>MinimumPasswordLength</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=nf>logic_error</span><span class=p>(</span><span class=s>&#34;Password is too short&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>      <span class=c1>// encrypted password into encrypted var
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>encrypted</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The object encrypted is unused an exception is thrown. Therefore, it&rsquo;s
better if you postpone defining it until you know an exception won&rsquo;t be
thrown.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>encryptPassword</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>password</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>password</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>MinimumPasswordLength</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=nf>logic_error</span><span class=p>(</span><span class=s>&#34;Password is too short&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>encrypted</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>      <span class=c1>// encrypted password into encrypted var
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>encrypted</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>However, even this version isn&rsquo;t tight enough as <code>encrypted</code> is defined
without any initialisation arguments. This means it is default constructed
and then only assigned a value later.</p><p>Consider if the hard part of the function was done in this function:</p><p><code>void encrypt(std::string& s);</code></p><p>The code could then look like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>encryptPassword</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>password</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>encrypted</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>encrypted</span> <span class=o>=</span> <span class=n>password</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>encrypt</span><span class=p>(</span><span class=n>encrypted</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>encrypted</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This leads to a pointless default construction of <code>encrypted</code> though. Better
would be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>encryptPassword</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>password</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>encrypted</span><span class=p>(</span><span class=n>password</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>encrypt</span><span class=p>(</span><span class=n>encrypted</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>encrypted</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>==Not only should you postpone variable definition until right before you
have to use the variable, but also until you have the initialisation
parameters for it.==</p><p>But what about loops?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Approach A: define outside loop
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Widget</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>w</span> <span class=o>=</span> <span class=n>some</span> <span class=n>value</span> <span class=n>dependent</span> <span class=n>on</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Approach B: define inside loop
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Widget</span> <span class=nf>w</span><span class=p>(</span><span class=n>some</span> <span class=n>value</span> <span class=n>dependent</span> <span class=n>on</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The associated costs are:</p><ul><li>Approach A: 1 constructor + 1 destructor + n assignments</li><li>Approach B: n constructors + n destructors</li></ul><p>For classes where assignment is cheaper than constructor/destructor pair,
approach A is generally more efficient. Otherwise, approach B is probably
better. Default to approach B unless (1) assignment is cheaper than
ctor/dtor pair and (2) you&rsquo;re dealing with performance sensitve area of
code.</p><blockquote class=abstract-callout><p>Summary<br>Postpone variable definitons as long as possible. It improves clarity
and efficiency.</p></blockquote><a href=#item-27-minimise-casting><h3 id=item-27-minimise-casting><span class=hanchor arialabel=Anchor># </span><strong>Item 27:</strong> Minimise casting.</h3></a><p>Rules of C++ are designed to guarantee that type errors are impossible.
However, casts subvert the type system. They should not be taken
lightly.</p><p>Old C style casts:</p><ul><li><code>(T) expression</code></li><li><code>T(expression)</code>
There is no difference in the meaning between these forms.</li></ul><p>New C++ casts</p><ul><li>const_cast&lt; T >(expression);</li><li>dynamic_cast&lt; T >(expression);</li><li>reinterpret&lt; T >(expression);</li><li>static_cast&lt; T >(expression);</li></ul><p>Each serves a distinct purpose:</p><ul><li><code>const_cast</code>: cast away constness. The only C++ cast that can do this.</li><li><code>dynamic_cast</code>: Primarily for &ldquo;safe downcasting&rdquo; i.e. whether an
object is of a particular type in an inheritance hierarchy. e.g. whether
<code>shape</code> can be cast to <code>triangle</code>. Cannot be performed in old style cast and
has significant runtime cost.</li><li><code>reinterpret_cast</code>: intended for low-level casts that yield
implementation-dependent (unportable) results. e.g. pointer to int. Should
rarely be used outside of low level code.</li><li><code>static_cast</code>: Used to force implicit conversions (e.g. non-const to
const. int to double etc). It can also be used to perform the reverse
of many such conversions (e.g. void pointers* to type pointers,
pointer-to-base to pointer-to-derived). Just not const to non-const.</li></ul><p>New style casts are preferrable as they are easier to identify in code and
their narrower usage provides more helpful usage errors.</p><p>==Many programmers believe that casts do nothing but tell compilers to
treat one type as another==. This is wrong. Type conversions of any kind
can lead to code that is executed at runtime.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>d</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>This code almost certainly generates code as the underlying representation
of a double differs from an int on most architectures. Not too surprising
but this may be a bit more unexpected:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Base</span> <span class=o>*</span><span class=n>pb</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>d</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>We&rsquo;re creating a base class pointer to a derived object, but sometimes
the two pointer values will not be the same. When this happens, an offset
is <mark><em>applied at runtime</em></mark> to the Derived* pointer to get the correct Base*
pointer value.</p><p>The last example demonstrates that a single object might have more than
one address (e.g. address when pointed by Base* and address when
pointed by Derived*). This does not happen in C, Java or C#, but it does
happen in C++. It happens all the time when multiple inheritance is in use.
But it can also happen in single inheritance. ==This means that you should
generally avoid making assumptions about how things are laid out in
C++ and certainly not make casts based on such assumptions.==</p><blockquote class=info-callout><p>Note</p><p>An offset is &lsquo;sometimes&rsquo; required. Compiler specific implementation
differs. Just because a cast based on assumed layout works on one
platform does not mean it will work on another.</p></blockquote><p>Casts make it easy to write code that looks right, but is in fact wrong.
For example, often virtual member function implementations are required
to call their base class counterparts first:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Window</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>onResize</span><span class=p>()</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpecialWindow</span><span class=o>:</span> <span class=k>public</span> <span class=n>Window</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>onResize</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Window</span><span class=o>&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>).</span><span class=n>onResize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>In this code, it may appear to be casting <code>this</code>, the current object, into its
base class and then calling <code>onResize()</code> on it. However, what it does is
creates a new, <mark>temporary copy of the base class</mark> part of <code>this</code>, calls
<code>Window::onResize</code> on the copy of the base class part and continues with
the function and performs the <code>SpecialWindow</code> specific actions on the
current object.</p><p>The object might now be in an invalid state where the base class
modifications have not been made but the derived class parts have been.
To handle this properly you should do the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpecialWindow</span><span class=o>:</span> <span class=k>public</span> <span class=n>Window</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>onResize</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Window</span><span class=o>::</span><span class=n>onResize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>If you are finding yourself wanting to cast, you could be approaching
things in the wrong way.</p><p><code>dynamic_cast</code> is an extremely costly cast. One common implementation
is partly based on string comparisons between class names. In an
inheritance hierarchy of four levels, this would cost 4 calls to <code>strcmp</code>. Be
wary of casts in general, but especially wary of dynamic_casts.</p><p>The need for dynamic_cast usually arises when you want to perform
derived class operations on what you think is a derived class, but what
you have is a pointer-to-base.</p><p>There are two possible solutions to avoid dynamic_casting for this reason:</p><ul><li>Use containers that store pointers to derived class objects directly.</li><li>Use virtual functions in the base class that will allow you to do what
you need.</li></ul><blockquote class=abstract-callout><p>Summary</p><ul><li>Avoid casts whenever practical, especially dynamic_casts. Explore
cast-free alternatives if a design requires casting.</li><li>If casting is necessary, hide it inside a function.</li><li>Prefer C++ style casts to old-style casts. Easier to spot and
more specific about what they do.</li></ul></blockquote><a href=#item-28-avoid-returning-handles-to-object-internals><h3 id=item-28-avoid-returning-handles-to-object-internals><span class=hanchor arialabel=Anchor># </span><strong>Item 28:</strong> Avoid returning &ldquo;handles&rdquo; to object internals.</h3></a><p>Consider an implementation of a rectangle class that stores the upper-left
corner and lower-right corner. Tok keep the <code>Rectangle</code> object small, the
points that define it&rsquo;s extent aren&rsquo;t stored in the <code>Rectangle</code> itself, but
an auxiliary struct that the rectangle points to.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Point</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>setX</span><span class=p>(</span><span class=kt>int</span> <span class=n>newVal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setY</span><span class=p>(</span><span class=kt>int</span> <span class=n>newVal</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>RectData</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Point</span> <span class=n>ulhc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Point</span> <span class=n>lrhc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rectangle</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>RectData</span><span class=o>&gt;</span> <span class=n>pData</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Because the clients of <code>Rectangle</code> need to be able to determine the extents
of a rectangle, there are functions <code>upperLeft</code> and <code>lowerRight</code>. Because
<code>Point</code> is a user-defined type and it is more efficient to return a reference,
these functions return references.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rectangle</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Point</span><span class=o>&amp;</span> <span class=n>upperLeft</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>pData</span><span class=o>-&gt;</span><span class=n>ulhc</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Point</span><span class=o>&amp;</span> <span class=n>lowerRight</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>pData</span><span class=o>-&gt;</span><span class=n>lrhc</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The design will compile, but it&rsquo;s wrong. The functions are declared const
so they are designed to offer clients a way to learn what the points of the
rectangle are, not to change them. However, since references to internal
data members are returned, they can now be changed.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Point</span> <span class=nf>coord1</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>point</span> <span class=nf>coord2</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Rectangle</span> <span class=nf>rec</span><span class=p>(</span><span class=n>coord1</span><span class=p>,</span> <span class=n>coord2</span><span class=p>);</span> <span class=c1>// rectangle 0,0 x 100,100
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>rec</span><span class=p>.</span><span class=n>upperLeft</span><span class=p>().</span><span class=n>setX</span><span class=p>(</span><span class=mi>50</span><span class=p>);</span>  <span class=c1>// now rec 50,0 x 100,100
</span></span></span></code></pre></td></tr></table></div></div><p>Two lessons from this example:</p><ul><li>==A data member is only as encapsulated as the most accessible
function returning reference to it==<ul><li>In this example, <code>ulhc</code> and <code>lrhc</code> are effectively public.</li></ul></li><li>==If a const member function returns a reference to data associated
with an object that is stored outside the object itself, the called can now
change that data.==</li></ul><p>The example involved references but the same would be true for pointers
and iterators as they all act as <em>handlers</em>.</p><p>We generally think of an object&rsquo;s internals as it&rsquo;s data members ,but
member functions not accessible to the general public are also part of
an object&rsquo;s internals. This means that you should nver have a member
function return a pointer to a less accessible member function.</p><p>The rectable example can be simply solved by adding const to their return
types:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rectangle</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>upperLeft</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>pData</span><span class=o>-&gt;</span><span class=n>ulhc</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>lowerRight</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>pData</span><span class=o>-&gt;</span><span class=n>lrhc</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The clients can now &lsquo;read&rsquo; the points but not &lsquo;write&rsquo; into them.
However, <code>upperLeft</code> and <code>lowerRight</code> are still returning &lsquo;handles&rsquo; to an
object&rsquo;s internals and this can be problematic still. In particular, it can
lead to &lsquo;dangling handles&rsquo;. Consider:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>GUIObject</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// returns a rectangle by value
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>Rectangle</span> <span class=nf>boundingBox</span><span class=p>(</span><span class=k>const</span> <span class=n>GUIObject</span><span class=o>&amp;</span> <span class=n>obj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>GUIObject</span> <span class=o>*</span><span class=n>pgo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// get a ptr to upper left point of bounding box
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>Point</span> <span class=o>*</span><span class=n>pUpperLeft</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>boundingBox</span><span class=p>(</span><span class=o>*</span><span class=n>pgo</span><span class=p>).</span><span class=n>upperLeft</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><p>Here the call to <code>boundingBox</code> returns a rectangle by value. <code>upperLeft</code> is
then called on this rectangle and the pointer to this <code>Point</code> is assigned to
<code>pUpperLeft</code>. Unfortunately, the temporary rectangle object will be
destroyed. That will then also leave <code>pUpperLeft</code> pointing to a <code>Point</code> that
no longer exists.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Avoid returning handles (references, pointers, or iterators) to
object internals. Doing so maximises encapsulation, helps const
member functions act const, and minimises the creation of dangling
handlers.</li></ul></blockquote><a href=#item-29-strive-for-exception-safe-code><h3 id=item-29-strive-for-exception-safe-code><span class=hanchor arialabel=Anchor># </span><strong>Item 29:</strong> Strive for exception-safe code.</h3></a><p>There are two requirements for exception safety:</p><ul><li><strong>Leak no resources</strong></li><li><strong>Don&rsquo;t allow data structures to be corrupted</strong></li></ul><p>Consider a class for representing GUI menus with background images. The
class is designed to be used in threaded environments so it has a mutex.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrettyMenu</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>changeBackground</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Mutex</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Image</span><span class=o>*</span> <span class=n>bgImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>imageChanges</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Now here is a possible implementation of the <code>changeBackground</code> function:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>PrettyMenu</span><span class=o>::</span><span class=n>changeBackground</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>                <span class=c1>//acquire mutex
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>delete</span> <span class=n>bgImage</span><span class=p>;</span>              <span class=c1>//get rid of old bg
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++</span><span class=n>imageChanges</span><span class=p>;</span>              <span class=c1>//update image change count
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>bgImage</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imgSrc</span><span class=p>);</span>  <span class=c1>//install new bg
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>              <span class=c1>//release mutex
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This function fulfils none of the requirements for exception safety. It leaks
resources as if <code>new Image(imgSrc)</code> throws, the mutex is never unlocked.
As for data structure corruption, if <code>new Image</code> throws, <code>bgImage</code> is now
pointing to a deleted object and also <code>imageChanges</code> has been incremented
when the new image has not actually been installed.</p><p><em>Addressing the resource leak</em>. To do this we just have to use objects to
help us manage resources.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>PrettyMenu</span><span class=o>::</span><span class=n>changeBackground</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Lock</span> <span class=nf>ml</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>   <span class=c1>// item 14. ensures release
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>bgImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>imageChanges</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>bgImage</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imgSrc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=tip-callout><p>info</p><p>Another good thing about resource management classes is that they
usually make functions shorter.</p></blockquote><p><em>Now for the data structure corruption.</em> We now have a choice. Exception
safe functions offer <mark>one of three guarantees.</mark></p><ul><li><strong>Basic guarantee.</strong> If an exception is thrown, everything in the program
remains in a valid state. No objects or data structures corruped and
internal state is consistent. e.g. for <code>changeBackground</code> the original
background is kept or a default background is used.</li><li><strong>Strong guarantee.</strong> If an exception is thrown, the state of the program
is left unchanged. The functions are <mark>atomic</mark>. If they succeed, they
succeed they succeed completely, and if they fail ,the program state is
is as if it was never called at all. Functions offering the &lsquo;strong&rsquo;
guarantee are easier to work with as after they are called there is only
two possible states: same as before or expected state after successful
completion. With the &lsquo;basic&rsquo; guarantee the function could leave the
program in any valid state.</li><li><strong>The nothrow guarantee</strong>. Never throw exceptions as these functions
always do what they promise to. All operations on built-in types are
nothrow. Functions with an empty exception specification <em>do not</em> imply
that they are nothrow. All it says is that if the function does throw an
exception, it is a serious error.</li></ul><p>Exception-safe code must offer one of the three guarantees from above.
It is not exception-safe if it does not. The choice is only about which
level of exception-safe code to offer as write exception-unsafe code
will cause resource leaks and corrupt data structures.</p><p>The general rule is to offer the strongest guarantee that is practical.
Although nothrow guarantee is great, it is difficult to climb out of just the
C part of C++ whilst guaranteeing it.</p><p><em>Back to the changeBackground example.</em> We can do two very simple
things to almost provide the strong guarantee.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrettyMenu</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Image</span><span class=o>&gt;</span> <span class=n>bgImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>PrettyMenu</span><span class=o>::</span><span class=n>changeBackgroun</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Lock</span> <span class=nf>ml</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>bgImage</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imgSrc</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>imageChanges</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The two improvements are:</p><ul><li>Using a shared_ptr to avoid resource leaks.</li><li>Reorder the statements so that <code>imageChanges</code> is only incremented until
the image has actually been changed.</li></ul><p>The improvements make it &lsquo;almost&rsquo; strong as it is possible that the
read marker for input stream &lsquo;imgSrc&rsquo; has been moved.</p><p>There is a general design strategy that typically leads to the strong
guarantee. <mark>Copy and swap</mark>. Make a copy of the object you want to
modify, make the necessary modifications to the copy. If an exception
is thrown, the original is left unchanged. After all changes have been
made, swap the modified object with the original in a non-throwing
operation.</p><p>This is usually implemented by putting all the per-object data into a
separate implementation object, then giving the real object a pointer
to its implementation object. This is called the &ldquo;pimpl idiom&rdquo;.</p><p>The <mark>copy-and-swap</mark> strategy is an excellent way to make all-or-nothing
changes to an object&rsquo;s state, but still does not guarantee that the overall
function is strongly exception safe.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>someFunc</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>    <span class=c1>//make copy of local state
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>f1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>f2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>    <span class=c1>//swap modified state into place
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>If <code>f1</code> or <code>f2</code> are less than strongly safe, <code>someFunc</code> is almost certainly not
strongly safe. But even if they are, <code>f1</code> could succeed and <code>f2</code> could fail.
This means that the state is not the same as if <code>f1</code> and <code>f2</code> both ran all the
way successfully. Such issues can prevent you from offering the strong
guarantee.</p><p>Another issue with &lsquo;copy and swap&rsquo; is efficiency. The strategy requires
creating a copy of each object to be modified which takes extra time and
space.</p><p>If you are unable to provide the strong guarantee because of limitations
such as these, it is perfectly ok to only provide the weak guarantee. Just
make an effort to provide the strong guarantee.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Exception-safe functions <mark>leak no resource</mark> and ==do not allow
data structure corruption==. Even if exceptions are thrown; basic,
strong, or nothrow guarantees are provided.</li><li>Strong guarantee can be provided via copy-and-swap.</li><li>A function can usually offer a guarantee no stronger than the
function it itself calls.</li></ul></blockquote><a href=#item-30-understand-the-ins-and-outs-of-linlining><h3 id=item-30-understand-the-ins-and-outs-of-linlining><span class=hanchor arialabel=Anchor># </span><strong>Item 30:</strong> Understand the ins and outs of linlining.</h3></a><p>Inline functions are a great idea: look like functions, act like functions,
but without the overhead of a real function call and without using macros.
<mark>What more could you ask for?</mark></p><p>They provide even more benefits! Compiler optimisations also work better
as they are typically designed for long stretches of code that lack function
calls.</p><p>However, nothing in life is free. They increase the size of your object
code. This could be a problem on machines with limited memory. Even
with virtual memory, code bloat can lead to additional paging, a reduced
instruction cache hit rate and the performance penalties these incur.</p><p>On the other hand, if an inline function body is very short, the code
generated for the function body may be smaller than the code for a
function call. This can lead to <em>smaller</em> object code and a higher instruction
cache hit rate.</p><p>Bear in mind that <code>inline</code> is a &lsquo;request&rsquo; not a command. The request can
be explicit or implicit. The implicit method is to define the function in the
class definition.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>age</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>theAge</span><span class=p>;</span> <span class=p>}</span>  <span class=c1>//implicit inline req
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>theAge</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The explicit way is to precede its definition with the <code>inline</code> keyword.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kr>inline</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>b</span> <span class=p>:</span> <span class=n>a</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Just because inline functions and function templates are usually defined
in header files does <strong>not</strong> mean that function templates must be inline. The
reason that this happens is because inlining and function template
instantiation both happens at compile time. If you inline all function
templates mindlessly, you will bloat the code unnecessarily and incur all of
the associated costs.</p><p><em>Inline is a request.</em> Most compilers refuse to inline functions that are too
complicated (contain loops or are recursive) and all but the most trivial
calls to virtual functions. After all virtual means &lsquo;figure out which
function to call at runtime&rsquo;. How you call the function also affects
whether the function is inlined. Calling a function through a pointer will
most likely not result in it being inlined.</p><p>It is also important to carefully consider inlining as a library designer as it
is impossible to provide binary upgrades to the client-visible inline
functions in a library. This is because inline functions are compiled into
the clients application. To change this the clients would have to recompile
with the new provided inline function code. This is more onerous than
dynamically linking a non inline function.</p><p>This all culminates in the logical strategy that functions should generally
not be declared inline. The 80-20 rule should be recalled and you should
identify the 20% of your code that increases your code&rsquo;s performance
and selectively apply inline.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Limit most inlining to small, frequently called functions. This
facilitate debugging, binary upgradability, minimises code bloat, and
maxmises chances of greater performance.</li><li>Don&rsquo;t declare function templates inline just because they appear
in header files.</li></ul></blockquote><a href=#item-31-minimise-compilation-dependencies-between-files><h3 id=item-31-minimise-compilation-dependencies-between-files><span class=hanchor arialabel=Anchor># </span><strong>Item 31:</strong> Minimise compilation dependencies between files.</h3></a><p>C++ does not do a very good job of separating interfaces from
implementations. You might make a small change to an implementation,
just the private stuff and find your whole project recompiling.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=n>Date</span><span class=o>&amp;</span> <span class=n>birthday</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=k>const</span> <span class=n>Address</span><span class=o>&amp;</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>birthDate</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>address</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>theName</span><span class=p>;</span>  <span class=c1>//implementation detail
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Date</span> <span class=n>theBirthDate</span><span class=p>;</span>    <span class=c1>//implementation detail
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Address</span> <span class=n>theAddress</span><span class=p>;</span>   <span class=c1>//implementation detail
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>In this example, the <code>Person</code> class can&rsquo;t be compiled without access to
definitions that the <code>Person</code> <mark>implementation</mark> uses (string, Date, Address).
Such definitions are typically provided using the <code>#include</code> directive.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;date.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;address.h&#34;</span><span class=cp>
</span></span></span></code></pre></td></tr></table></div></div><p>Unfortunately, this leads to compilation dependencies as changes to any
of these files will require Person to also be recompiled. C++ requires the
implementation details of a class in the class definition as compilers need
to know how much memory to allocate for objects. This info cannot be
found in forward declarations. ==This is not a problem in languages like
Java== as in those languages compilers allocate only enough space for a
pointer to an object.</p><p>In C++ there are two ways to solve this problem:</p><ul><li>Like Java, play the game of &ldquo;hide the object implementation behind a
pointer game&rdquo; using the pimpl idiom.</li><li>Use <mark>interface classes</mark>.</li></ul><p><em>pimpl idion method</em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PersonImpl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Date</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Address</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=n>Date</span><span class=o>&amp;</span> <span class=n>birthday</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=k>const</span> <span class=n>Address</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>birthDate</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>address</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>PersonImpl</span><span class=o>&gt;</span> <span class=n>pImpl</span><span class=p>;</span><span class=c1>//ptr to implementation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>With this design, clients of Person are divorced from the details of dates,
addresses and persons. The implementations can be changed at will, but
<code>Person</code> clients do not need to recompile. ==Furthermore, since the clients
are unable to view the implementation, the are unlikely to write code that
depends on those details==. Hence:</p><ul><li><em>Avoid using objects when object references will do</em>. You can define
pointers and references to a type with only a declaration for a type.
Defining objects of a type is what necessitates the definition of the class.</li><li><em>Depend on class declarations instead of class definitions whenever
you can</em>. You never need a class definition to declare a function using that
class, not even if the function passes or returns the class type by value.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Date</span><span class=p>;</span>   <span class=c1>//class declaration
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Date</span> <span class=nf>today</span><span class=p>();</span> <span class=c1>// fine even though it returns Date by value
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>clearAppointments</span><span class=p>(</span><span class=n>Date</span> <span class=n>d</span><span class=p>);</span> <span class=c1>// also fine
</span></span></span></code></pre></td></tr></table></div></div><p>Why declare functions that no one calls? It allows you to have a header
file of function declarations. However, clients of your library will most
likely not use every function. Now the burden of <code>#include</code>&lsquo;ing the types
the clients need is on the client. If you put all of the includes in the
function declaration file, the clients would have artificial dependencies on
files that they do not need as they would be including things that they
don&rsquo;t need from the functions they don&rsquo;t call.</p><ul><li><em>Provide separate header files for declarations and definitions.</em> To
facilitate adherance to these guidelines, header files should come in pairs:
one for declarations, the other for definitions. These files need to be kept
consistent. This means that library clients should <code>#include</code> a declaration
file instead of forward declaring themselves. This means that library
authors should provide both of these header files. The above example
would look like so:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;datefwd.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>Date</span> <span class=nf>today</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>clearAppointments</span><span class=p>(</span><span class=n>Date</span> <span class=n>d</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Classes like <code>Person</code> that use the &lsquo;pimpl idiom&rsquo; are often called handle
classes. Here&rsquo;s how <code>Person</code> might be implemented(aka the .cpp file):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Person.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;PersonImpl.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>Person</span><span class=o>::</span><span class=n>Person</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=n>Date</span><span class=o>&amp;</span> <span class=n>birthday</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=k>const</span> <span class=n>Address</span><span class=o>&amp;</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>:</span><span class=n>pImpl</span><span class=p>(</span><span class=k>new</span> <span class=n>PersonImpl</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>birthday</span><span class=p>,</span> <span class=n>addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>Person</span><span class=o>::</span><span class=n>name</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>pImpl</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Now lets consider the alternative. Interface classes. An interface class
for <code>Person</code> might look like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Person</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>birthDate</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>address</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>==Clients of this class must program in terms of Person pointers and
references as it is impossible to instantiate classes containing pure virtual
functions.== It is however, possible to instantiate classes <em>derived</em> from
<code>Person</code>. Like handle classes, clients of the interface class do not have to
recompile unless the interface is modified.</p><p>Clients of interface classes need a way to create new objects. This is
typically done using &lsquo;factory functions&rsquo; that play the role of the
constructor. They return pointers (preferably smart) to dynamically
allocated objects that support the Interface classes interface. Such
functions are often declared static inside the interface class:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Person</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>create</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=k>const</span> <span class=n>Date</span><span class=o>&amp;</span> <span class=n>birthday</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=k>const</span> <span class=n>Address</span><span class=o>&amp;</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// to use the factory function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Date</span> <span class=n>dob</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Address</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Person</span><span class=o>&gt;</span> <span class=n>pp</span><span class=p>(</span><span class=n>Person</span><span class=o>::</span><span class=n>create</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>dob</span><span class=p>,</span> <span class=n>addr</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><p>At some point the Person interface class will need to be &lsquo;implemented&rsquo;.
That might look like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>RealPerson</span><span class=o>:</span> <span class=k>public</span> <span class=n>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>RealPerson</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=n>Date</span><span class=o>&amp;</span> <span class=n>dob</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=k>const</span> <span class=n>Address</span><span class=o>&amp;</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>theName</span><span class=p>(</span><span class=n>name</span><span class=p>),</span> <span class=n>theBirthdate</span><span class=p>(</span><span class=n>dob</span><span class=p>),</span> <span class=n>theAddress</span><span class=p>(</span><span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>RealPerson</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>birthDate</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>address</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>theName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Date</span> <span class=n>theBirthDate</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Address</span> <span class=n>theAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Person</span><span class=o>&gt;</span> <span class=n>Person</span><span class=o>::</span><span class=n>create</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=k>const</span> <span class=n>Date</span><span class=o>&amp;</span> <span class=n>birthday</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>cosnt</span> <span class=n>Address</span><span class=o>&amp;</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Person</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>RealPerson</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=n>dob</span>
</span></span><span class=line><span class=cl>                                                  <span class=n>addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This demonstrates one of two most common mechanisms for implementing
an Interface class: inherit its interface specification, then implement the
function from the interface. A second way is using multiple inheritance
(item 40).</p><p><mark>So what are the costs for all this magic?</mark> Some speed at runtime, plus
some additional memory per object. For handle classes, you have to go
through one layer of indirection to get to the object&rsquo;s data per access.
The space required for this extra implementation pointer increases the
memory required as well. Finally, since the object is dynamically
allocated, there are associated costs with that.</p><p>For interface classes, every function call is virtual, so you pay the cost
of an indirect jump each time you make a function call. All objects derived
from an interface class also requires a virtual table pointer.</p><p>Finally, for both, they don&rsquo;t really benefit from <code>inline</code> functions.</p><p>Do not dismiss <mark>handle classes</mark> and <mark>interface classes</mark> due to these costs
though. Use them evolutionarily. Use them during development and then
replace with concrete classes for production use if you can prove the
speed/size benefit outweighs the coupling.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Main idea to reduce compilation dependencies is to rely on
declarations as much as possible. The two approaches are ==&lsquo;handle
classes&rsquo;<mark> and </mark>&lsquo;interface classes&rsquo;==.</li><li>Library header files should exist in full and declaration-only forms
even if templates are involved.</li></ul></blockquote><a href=#ch6-inheritance-and-object-oriented-design><h2 id=ch6-inheritance-and-object-oriented-design><span class=hanchor arialabel=Anchor># </span>Ch6: Inheritance and Object-Oriented Design</h2></a><a href=#item-32-make-sure-public-inheritance-models-is-a><h3 id=item-32-make-sure-public-inheritance-models-is-a><span class=hanchor arialabel=Anchor># </span><strong>Item 32:</strong> Make sure public inheritance models &ldquo;is-a.&rdquo;</h3></a><p>The most important rule with OOP in C++ is that <em>public inheritance means
&ldquo;is-a&rdquo;</em>. If you write that class D(derived) publicly inherits from class
B(base), you are telling C++ compilers that every object of type D is also
an object of type B. Anywhere an object of type B can be used, you can
also use type D, but not vice versa.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=o>:</span> <span class=k>public</span> <span class=n>Person</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>eat</span><span class=p>(</span><span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>study</span><span class=p>(</span><span class=k>const</span> <span class=n>Student</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Person</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Student</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>eat</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>  <span class=c1>//fine - p is a person
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>eat</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>  <span class=c1>//fine - s is a student. student is-a person
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>study</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=c1>//fine
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>study</span><span class=p>(</span><span class=n>p</span><span class=p>);</span><span class=c1>//error - p is not a student. 
</span></span></span></code></pre></td></tr></table></div></div><p>This is true only for <em>public</em> inheritance. Private inheritance means
something different. Who knows what protected inheritance means.</p><p>However, human intuition can be misleading. If we say penguins are birds
and birds can fly, we could represent it like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Bird</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>();</span>      <span class=c1>//birds can fly
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Penguin</span><span class=o>:</span> <span class=k>public</span> <span class=n>Bird</span> <span class=p>{</span> <span class=c1>// Penguins are birds
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Now, we are in trouble because this hierarchy is claiming that penguins
can fly. We are victims of an imprecise language called english. When we
say birds can fly, we don&rsquo;t mean <em>all</em> birds can fly. There can be non flying
birds. Now that we are clear about this, we could represent it like so:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Bird</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>                      <span class=c1>// no fly function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FlyingBird</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Penguin</span><span class=o>:</span> <span class=k>public</span> <span class=n>Bird</span> <span class=p>{</span> <span class=c1>// Penguins are birds
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This is now more faithful to reality. However, if your application does not
deal with flying, the original two class hierarchy may be sufficient. It
depends on what the system is expected to do.</p><p>There is another school of thought on how to handle the &ldquo;penguins are
birds but they can&rsquo;t fly&rdquo; issue. The approach is to redefine the fly
function for penguins so that it generates a <em>runtime</em> error.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>error</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>msg</span><span class=p>);</span> <span class=c1>//defined elsewhere
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Penguin</span><span class=o>:</span> <span class=k>public</span> <span class=n>Bird</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>()</span> <span class=p>{</span> <span class=n>error</span><span class=p>(</span><span class=s>&#34;Penguins don&#39;t fly!&#34;</span><span class=p>);}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>It is important to recognise that this does <em>NOT</em> say &ldquo;penguins can&rsquo;t fly&rdquo;. It
actually says &ldquo;Penguins can fly, but it&rsquo;s an error when they actually try
to do so&rdquo;. The main way to detect this is that the error is actually only
detected at <em>runtime</em>. The way to correctly, definitively say that penguins
can&rsquo;t fly is to not implement the fly function for penguins so that now the
compiler will detect the error at <em>compile</em> time.</p><p>Lets consider another example. Should square inherit from rectangle? You
might be tempted to think so. But you might run into this issue:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rectangle</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>setHeight</span><span class=p>(</span><span class=kt>int</span> <span class=n>newHeight</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setWidth</span><span class=p>(</span><span class=kt>int</span> <span class=n>newWidth</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>height</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>width</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>makeBigger</span><span class=p>(</span><span class=n>Rectangle</span><span class=o>&amp;</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>oldHeight</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>height</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=p>.</span><span class=n>setWidth</span><span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>width</span><span class=p>()</span> <span class=o>+</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>height</span><span class=p>()</span> <span class=o>==</span> <span class=n>oldHeight</span><span class=p>);</span> <span class=c1>//ensure height unchanged
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Square</span><span class=o>:</span> <span class=k>public</span> <span class=n>Rectangle</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Square</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>width</span><span class=p>()</span> <span class=o>==</span> <span class=n>s</span><span class=p>.</span><span class=n>height</span><span class=p>());</span>  <span class=c1>//true for squares. surely
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>makeBigger</span><span class=p>(</span><span class=n>s</span><span class=p>);</span> <span class=c1>// is a rectangle by inheritance so can call it
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>assert</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>width</span><span class=p>()</span> <span class=o>==</span> <span class=n>s</span><span class=p>.</span><span class=n>height</span><span class=p>());</span>  <span class=c1>//true for squares. surely
</span></span></span></code></pre></td></tr></table></div></div><p>It is clear that the second assertion on the square should remain true as
a square by definition has equal height and width. However, the call to
<code>makeBigger()</code> has changed the width but not height. The fundamental
issue here is that something applicable for rectangles is not applicable for
squares. This property is: <mark>height can be changed independently of width</mark>.
But public inheritance asserts that everything that applies to the base
applies to the derived class too.</p><blockquote class=abstract-callout><p>Summary</p><p>Public inheritance means &ldquo;is-a&rdquo;. Everything that applies to a base
must also apply to a derived class because a derived class is-a base
class.</p></blockquote><a href=#item-33-avoid-hiding-inherited-names><h3 id=item-33-avoid-hiding-inherited-names><span class=hanchor arialabel=Anchor># </span><strong>Item 33:</strong> Avoid hiding inherited names.</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>someFunc</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>From the above code it is easy to recognise that global variable x is hidden
by the <code>x</code> in the inner scope. Inheritance behaves similarly as if the scope
of the derived class is inside a base class.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>mf1</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>mf1</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>mf2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mf3</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>mf3</span><span class=p>(</span><span class=kt>double</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>mf1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>mf3</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>mf4</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>In this example, <code>mf1</code> and <code>mf3</code> hide the base class version. From the
perspective of <em>name lookup</em>, Base::mf1 and Base::mf2 are no longer
inherited at all.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=p>.</span><span class=n>mf1</span><span class=p>();</span> <span class=c1>//fine. calls Derived::mf1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf1</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=c1>//error. Derived::mf1 hides Base::mf1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf2</span><span class=p>();</span> <span class=c1>//fine. calls Derived::mf2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf3</span><span class=p>();</span> <span class=c1>//fine. calls Derived::mf3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf3</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=c1>//error. Derived::mf3 hides Base::mf3
</span></span></span></code></pre></td></tr></table></div></div><p>The surprising behaviour is that the hiding also affects functions in the
base class that take different parameters. The rationale is that it prevents
accidentally inheriting overlods from distant base classes when you create
a new derived class in a library or application framework.</p><p>Unfortunately, you do want to inherit the overloads when using public
inheritance. You don&rsquo;t wan to violate the <em>&ldquo;is-a&rdquo;</em> relationship. You can
override this behaviour with <code>using declarations</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>Base</span><span class=o>::</span><span class=n>mf1</span><span class=p>;</span> <span class=c1>//make things in Base called mf1 and
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>Base</span><span class=o>::</span><span class=n>mf1</span><span class=p>;</span> <span class=c1>//mf1 visible in Derived&#39;s scope
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>mf1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>mf3</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>mf4</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=p>.</span><span class=n>mf1</span><span class=p>();</span> <span class=c1>//fine. calls Derived::mf1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf1</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=c1>//now ok. Calls Base::mf1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf2</span><span class=p>();</span> <span class=c1>//fine. calls Derived::mf2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf3</span><span class=p>();</span> <span class=c1>//fine. calls Derived::mf3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf3</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=c1>//now ok. Calls Base::mf3
</span></span></span></code></pre></td></tr></table></div></div><p>In public inheritance you always want to inherit all the functions from the
Base class. However, with private inheritance, you may not want to
inherit all the functions. Lets say Derived privately inherits from Base, and
it only wants to inherit the <code>mf1</code> that takes on parameters. You can&rsquo;t use
<code>using</code> to do this. For this you have to use a <mark>forwarding function</mark>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>mf1</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>mf1</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>private</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>mf1</span><span class=p>()</span> <span class=p>{</span> <span class=n>Base</span><span class=o>::</span><span class=n>mf1</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=p>.</span><span class=n>mf1</span><span class=p>();</span>  <span class=c1>//works as expected
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf1</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=c1>//hidden as expected
</span></span></span></code></pre></td></tr></table></div></div><blockquote class=abstract-callout><p>Summary</p><ul><li>Names in derived classes hide names in base classes. Under pubilc
inheritance, this is never desirable.</li><li>To make hidden names visible again, employ using declarations or
forwarding functions.</li></ul></blockquote><a href=#item-34-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation><h3 id=item-34-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation><span class=hanchor arialabel=Anchor># </span><strong>Item 34:</strong> Differentiate between inheritance of interface and inheritance of implementation.</h3></a><p>Public inheritance is composed of two separable parts: inheritance of
function interfaces and inheritance of function implementations. This
corresponds exactly to the difference between function declarations
and function definitions.</p><p>As a class designer you may want to (1) allow a derived class to only
inherit the interface of a member function, (2) allow a derived class to
inherit a function&rsquo;s interface and implementation, but with the option to
override the inherited implementation or (3) allow a derived class to
inherit interface and implementation without allowing it to be overriden.</p><a href=#1-interface-only---aka-pure-virtual-functions><h4 id=1-interface-only---aka-pure-virtual-functions><span class=hanchor arialabel=Anchor># </span><strong>1)</strong> Interface only - AKA pure virtual functions</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>draw</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Two most salient features of pure virtual functions:</p><ul><li>Must be redeclared by conrete class that inherits them.</li><li>Typically have no definition in abstract classes.
These two imply that the whole point of pure virtual functions is to have a
derived class inherit the <em>interface only</em>.</li></ul><p>In the shape example, we have no idea how a shape will be drawn. Just
that the designer of a concrete shape derived class has to make provide
an implementation.</p><a href=#2-interface--optional-default-implementation---aka-virtual-functions><h4 id=2-interface--optional-default-implementation---aka-virtual-functions><span class=hanchor arialabel=Anchor># </span><strong>2)</strong> Interface + optional default implementation - AKA virtual functions</h4></a><p>The big risk with virtual functions is that a new derived class is added into
the inheritance hierarchy, <em>BUT</em> this new derived class differs from its
siblings and does <em>NOT</em> want the default implementation of the virtual
function. If the programmers forget to implement the custom overriden
version for this new derived class, then we have issues.</p><p>What we would like to do is offer a default implementation but require it to
be explicitly asked for instead of being given it by default.</p><p>There are two ways to solve this. The first:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Airplane</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>defaultFly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Airplane</span><span class=o>::</span><span class=n>defaultFly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// default code to fly to desination airport
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The key here is to disconnect the interface from the default
implementation. The fly virtual function has been changed into a pure
virtual function which has to be implemented but the implementation can
now just use the <code>defaultFly</code> function provided.</p><p>Now any new derived classes will have to implement <code>fly</code> and will not use
the <code>defaultFly</code> function accidentally.</p><p>An objection to this method of solving the problem is the pollution of the
namespace. You can solve this with something very similar:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Airplane</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Airplane</span><span class=o>::</span><span class=n>fly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// default code to fly to destination
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ModelA</span><span class=o>:</span> <span class=k>public</span> <span class=n>Airplane</span> <span class=p>{</span> <span class=c1>// uses default  fly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>virutal</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=n>Airplane</span><span class=o>::</span><span class=n>fly</span><span class=p>(</span><span class=n>destination</span><span class=p>);}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ModelB</span><span class=o>:</span> <span class=k>public</span> <span class=n>Airplane</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>virutal</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ModelB</span><span class=o>::</span><span class=n>fly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// code for ModelB plane to fly to destination
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The main thing you lose with this method is to have different protection
levels. The code that used to be in <code>defaultFly</code> is now public.</p><a href=#3-interface--mandatory-implementation><h4 id=3-interface--mandatory-implementation><span class=hanchor arialabel=Anchor># </span><strong>3)</strong> Interface + mandatory implementation</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>objectID</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Nothing fancy in terms of implementation. But you should consider the
implication of a mandatory implementation. It&rsquo;s basically saying &ldquo;Every
shape object has a funtion that returns it&rsquo;s ID, and no derived class can
change the implementation&rdquo;. It is an <mark>invariant over specialisation</mark>.</p><p><strong>Common mistakes</strong></p><ul><li>Making everything non-virtual<ul><li>Might happen due to concerns over performance. Just remember the 80-20 rule.</li></ul></li><li>Declaring all member functions virtual<ul><li>Can be sign of a class designer to make a firm stance on what functions really are invariants.</li></ul></li></ul><blockquote class=abstract-callout><p>Summary</p><ul><li>Inheriting interfaces is different from inheriting implementations.
Under public inheritance, derived classes always inherit base class
interfaces.</li><li>Pure virtual functions specify inheritance of interface only.</li><li>Simple (impure) virtual functions specify inheritance of interface
and inheritance of a default implementation.</li><li>Non-virtual functions specify inheritanc of interface and a
mandatory implementation.</li></ul></blockquote><a href=#item-35-consider-alternatives-to-virtual-functions><h3 id=item-35-consider-alternatives-to-virtual-functions><span class=hanchor arialabel=Anchor># </span><strong>Item 35:</strong> Consider alternatives to virtual functions.</h3></a><p>Consider a video game and a hierarchy for characters in the game. You
offer a member function <code>healthValue</code>, that returns an integer indicating
how healthy the character is. However, different characters may calculate
their health differently. Declaring <code>healthValue</code> virtual seems obvious:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=n>healthValue</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The problem is in fact that this design does seem so obvious. However,
there are alternative ways to approach this problem and we should bear
this in mind and consider them.</p><a href=#the-template-method-pattern-via-the-non-virtual-interface-idiom><h4 id=the-template-method-pattern-via-the-non-virtual-interface-idiom><span class=hanchor arialabel=Anchor># </span>The Template Method Pattern via the <code>Non-Virtual Interface Idiom</code></h4></a><p>One school of thought is that virtual functions should always be private.
To adhere to this rule and solve the healthvalue problem you could retain
<code>healthValue</code> but change it to public. Then a different private virtual
function does the actual calculation and is called by the public function:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>healValue</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>  <span class=c1>//do &#34;before&#34; stuff. aka setup
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>retVal</span> <span class=o>=</span> <span class=n>doHealthValue</span><span class=p>();</span> <span class=c1>//do real work
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>...</span>  <span class=c1>//do &#34;after&#34; stuff. aka cleanup(?)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>retVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=n>doHealthValue</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=c1>//default algorithm for health calc
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This design is calle dthe non-virtual interface (NVI) idiom. It is a
minifestation of a more general design pattern called Template Method
(unrelated to C++ templates).</p><p>in the NVI idiom, the non-virtual method becomes the &lsquo;wrapper&rsquo; used to
call the virtual method that does the work. This means that the wrapper
function can ensure that the context is setup before the work is done and
then cleaned up after (e.g. Locking and unlocking a mutex).</p><a href=#the-strategy-pattern-via-function-pointers><h4 id=the-strategy-pattern-via-function-pointers><span class=hanchor arialabel=Anchor># </span>The Strategy pattern via Function Pointers</h4></a><p>The NVI idiom is an interesting alternative to public virtual functions, but
ultimately it&rsquo;s little more than window dressing. After all, the real work
is still being done with virtual functions. A more dramatic design would be
saying that calculating a character&rsquo;s health is independent of the
character&rsquo;s type. For example we could require that each character&rsquo;s
constructor be passed a pointer to a health calculation function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span><span class=p>;</span>  <span class=c1>// forward declaration
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//function for default health calculation algo
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>defaultHealthCalc</span><span class=p>(</span><span class=k>const</span> <span class=n>GameCharacter</span><span class=o>&amp;</span> <span class=n>gc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>HealthCalcFunc</span><span class=p>)(</span><span class=k>const</span> <span class=n>GameCharacter</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=nf>GameCharacter</span><span class=p>(</span><span class=n>HealthCalcFunc</span> <span class=n>hcf</span> <span class=o>=</span> <span class=n>defaultHealthCalc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>healthFunc</span><span class=p>(</span><span class=n>hcf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>healthValue</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=k>return</span> <span class=n>healthFunct</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>HealthCalcFunc</span> <span class=n>healthFunc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This approach is a simple application of another common design pattern -
<mark>strategy</mark>. Compared to approaches based on virutal functions, it offers
some interesting flexibility:</p><ul><li>Different instances of the same character type can have different health
calculation functions.</li><li>Health calculation functions can be changed at runtime.</li></ul><p>However, on the other hand, it means that the health calculation function
no longer has special access to the internal parts of <code>Character</code>. This
is something that you have to bear in mind for all functions outside of the
class. The only way to resolve this is to weaken the encapsulation of the
class i.e. declare non-member function a friend, offer public accessor
functions that would otherwise not be necessary.</p><a href=#the-strategy-pattern-via-stdfunction><h4 id=the-strategy-pattern-via-stdfunction><span class=hanchor arialabel=Anchor># </span>The Strategy Pattern via std::function</h4></a><p>Once you get accustomed to templates though, the function pointer
approach can seem limiting and rigid. Why can&rsquo;t we use something that
<em>acts</em> like a function such as a function object? Why can&rsquo;t it be a member
function? Why must it return an int instead of a type convertible to an int.</p><p>These constraints vanish when we use std::function instead of a function
pointer. Here is the same design but with std::function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>defaultHealthCalc</span><span class=p>(</span><span class=k>const</span> <span class=n>GameCharacter</span><span class=o>&amp;</span> <span class=n>gc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>int</span> <span class=p>(</span><span class=k>const</span> <span class=n>GameCharacter</span><span class=o>&amp;</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>HealthCalcFunc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=nf>GameCharacter</span><span class=p>(</span><span class=n>HealthCalcFunc</span> <span class=n>hcf</span> <span class=o>=</span> <span class=n>defaultHealthCalc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span><span class=n>healthFunc</span><span class=p>(</span><span class=n>hcf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>healthValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>healthFunc</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>HealthCalcFunc</span> <span class=n>healthFunc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Lets take a closer look at what the typedef was for:<br><code>std::function&lt;int (const GameCharacter&)></code><br>The target signature is &ldquo;function taking a const GameCharacter& and
returning an int&rdquo;. An object of this type can hold any callable entity
compatitble with that signature. Compatible means that
<code>const GameCharacter&</code> can be converted to the type of the entity&rsquo;s
parameter and the entity&rsquo;s return type can be converted to int.</p><p>This is similar to using function pointers but with a staggering amount
more flexibility.</p><a href=#the-classic-stretegy-pattern><h4 id=the-classic-stretegy-pattern><span class=hanchor arialabel=Anchor># </span>The &ldquo;Classic&rdquo; Stretegy Pattern</h4></a><p>For a more design pattern friendly approach instead of a &lsquo;C++ coolness&rsquo;
approach you can have <code>GameCharacter</code> be the base class for <code>EvilBadGuy</code>
and <code>EyeCandyCharacter</code>. <code>HealthCalcFunc</code> would then be the root of
another hierarchy with derived classes <code>SlowHealthLoser</code> and
<code>FastHealthLoser</code>. Each <code>GameCharacter</code> would contain a pointer to an
object from the <code>HealthCalcFunc</code> hierarachy.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HealthCalcFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=n>calc</span><span class=p>(</span><span class=k>const</span> <span class=n>GameCharacter</span><span class=o>&amp;</span> <span class=n>gc</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{...}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>HealthCalcFunc</span> <span class=n>defaultHealthCalc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>GameCharacter</span><span class=p>(</span><span class=n>HealthCalcFunc</span><span class=o>*</span> <span class=n>phcf</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>defaulthealthCalc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>pHealthCalc</span><span class=p>(</span><span class=n>phcf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>healthValue</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=k>return</span> <span class=n>pHealthCalc</span><span class=o>-&gt;</span><span class=n>calc</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>HealthCalcFunc</span> <span class=o>*</span><span class=n>pHealthCalc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This approach has the appeal of being quickly recognisable to people
familiar with the &lsquo;standard&rsquo; strategy pattern implementation. It also has
the benefit of allowing the existing health calculation to be tweaked with
the use of derived classes.</p><blockquote class=abstract-callout><p>Summary</p><p>Consider alternatives to virtual functions when searching for a design
to solve your problem. Alternatives include:</p><ul><li><strong>Non-virutal Interface Idiom</strong>. A form of the Template Method design</li><li>Replace virtual functions with <strong>function pointer data members</strong></li><li>Replace virtual functions with <strong>std::function data members</strong></li><li>Replace virtual functions in one hierarchy with <strong>virtual functions from a different hierarchy</strong>.
This is the conventional approach to the strategy pattern.</li></ul></blockquote><a href=#item-36-never-redefine-an-inherited-non-virtual-function><h3 id=item-36-never-redefine-an-inherited-non-virtual-function><span class=hanchor arialabel=Anchor># </span><strong>Item 36:</strong> Never redefine an inherited non-virtual function.</h3></a><p>Lets say you have a base class B and a derived class D that inherits from
B.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>mf</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D</span><span class=o>:</span> <span class=k>public</span> <span class=n>B</span><span class=p>{...}</span>
</span></span></code></pre></td></tr></table></div></div><p>Now if you were to call mf though a pointer to object D&mldr;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>D</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>B</span><span class=o>*</span> <span class=n>pB</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>D</span><span class=o>*</span> <span class=n>pD</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pB</span><span class=o>-&gt;</span><span class=n>mf</span><span class=p>();</span>  <span class=c1>// surely these function calls
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pD</span><span class=o>-&gt;</span><span class=n>mf</span><span class=p>()</span><span class=o>:</span>  <span class=c1>// do the same thing
</span></span></span></code></pre></td></tr></table></div></div><p>You would expect the same result. However, this may not be the case if
class D has redefined <code>mf()</code>. This is because <mark>non-virtual functions are statically bound</mark>.
Virtual functions. on the other hand are dynamically bound, so you would
get the expected result. That&rsquo;s the pragmatic argument.</p><p>Now for a more theoretical argument. If public inheritance means an &ldquo;is-a&rdquo;
relationship and declaring a non virtual function establishes an invariant
over specialisation for that class, then:</p><ul><li>Everything that applies to B objects also apply to D objects</li><li>Classes derived from B must inherit both the interface and
implementation of <code>mf()</code> because mf is non-virtual</li></ul><p>Then what is D do doing by redefining <code>mf()</code>? It makes no sense. It means
that every D is a B is no longer true. It would mean that D should not
inherit from B. If D does really have to inherit from B, then that also
means that the invariant over specialisation is not true. This means that
<code>mf()</code> should be virtual.</p><p>Basically, just don&rsquo;t do it. It&rsquo;s pragmatically bad and theoretically
nonsensical.</p><blockquote class=abstract-callout><p>Summary</p><p>Never redefine an inherited non-virtual function</p></blockquote><a href=#item-37-never-redifine-a-functions-inherited-default-parameter-value><h3 id=item-37-never-redifine-a-functions-inherited-default-parameter-value><span class=hanchor arialabel=Anchor># </span><strong>Item 37:</strong> Never redifine a function&rsquo;s inherited default parameter value.</h3></a><p>The previous item rules out redefining non virtual functions so this item
address redefining the <em>default parameter value</em> of a virtual function.</p><p><mark>Virtual functions are dynamically bound, but default parameter values are statically bound.</mark></p><p>Essentially this means that if you redefine a default parameter value in a
derived function, it will still use the default parameter value from the base
class. So don&rsquo;t do it.</p><p>If you want to supply a default parameter value for both the base and
derived class though, without redefining the same colour in both, resulting
in code duplication and dependencies, you can use NVI.</p><blockquote class=abstract-callout><p>Summary</p><p>Never redefine an inherited default parameter value because default
parameter values are statically bound and virtual functions are
dynamically bound.</p></blockquote><a href=#item-38-model-has-a-or-is-implemented-in-terms-of-throw-composition><h3 id=item-38-model-has-a-or-is-implemented-in-terms-of-throw-composition><span class=hanchor arialabel=Anchor># </span><strong>Item 38:</strong> Model &ldquo;has-a&rdquo; or &ldquo;is-implemented-in-terms-of&rdquo; throw composition.</h3></a><p><em>Composition</em> is the relationship that arises when objects of one type
contain objects of another type. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Address</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PhoneNumber</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>;</span>         <span class=c1>//composed object
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Address</span><span class=p>;</span>                  <span class=c1>// ditto
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PhoneNumber</span> <span class=n>voiceNumber</span><span class=p>;</span>  <span class=c1>// ditto
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PhoneNumber</span> <span class=n>faxNumber</span><span class=p>;</span>    <span class=c1>// ditto
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Item 32 explains that public inheritance means &ldquo;is-a&rdquo;. Composition also
has a meaning. Composition means &ldquo;has-a&rdquo; or
&ldquo;is-implemented-in-terms-of&rdquo;. That&rsquo;s because some objects in your code
correspond to things in the world you are modeling e.g. people, vehicles,
video frames etc. Such objects are part of the <em>application domain</em>. Other
objects are purely implementation artefacts e.g. buffers, mutexes, search
trees etc. Application domain -> &ldquo;has-a&rdquo;. Implementation domain ->
&ldquo;is-implemented-in-terms-of&rdquo;.</p><p>The &ldquo;has-a&rdquo; relationship is relatively simple and people do not struggle
with it. More problematic is the &ldquo;is-implemented-in-terms-of&rdquo;
relationship. Lets say you need a hash set. The STL has such a data
structure. However, the tradeoff made in the STL implementation is
to sacrifice space for speed and requires three pointers per element. So
you decided to implement as set yourself. You decide to implement it as
a linked list and not a search tree. To do this you decide to use the STL
implementation of linked list. You may choose to do the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Set</span><span class=o>:</span> <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This would be wrong. This implies that what&rsquo;s true for list is also true
for your set. It models an &ldquo;is-a&rdquo; relationship. what you should do is:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Set</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>member</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>item</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>remove</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>rep</span><span class=p>;</span>     <span class=c1>// representation of set data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Finally the relationship has been established correctly. Set is &ldquo;implemented
in terms of&rdquo; a linked list.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Composition has meanings completely different from that of public
inheritance.</li><li>In the application domain, composition means &ldquo;has-a&rdquo;</li><li>In the implementation domain, composition means &ldquo;is-implemented-in-terms-of&rdquo;</li></ul></blockquote><a href=#item-39-use-private-inheritance-judiciously><h3 id=item-39-use-private-inheritance-judiciously><span class=hanchor arialabel=Anchor># </span><strong>Item 39:</strong> Use private inheritance judiciously.</h3></a><p>Lets repeast the &lsquo;A Person can eat and a Student can study&rsquo; example from
the public inheritance section, but with private inheritance.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=o>:</span> <span class=k>private</span> <span class=n>Person</span> <span class=p>{...};</span>  <span class=c1>//private inheritance
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>eat</span><span class=p>(</span><span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p</span><span class=p>);</span>            <span class=c1>// any person can eat
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>study</span><span class=p>(</span><span class=k>const</span> <span class=n>Student</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>);</span>         <span class=c1>// only students study
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Person</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Student</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>eat</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>   <span class=c1>//fine, p is a person
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>eat</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>   <span class=c1>//error! a Student isn&#39;t a person
</span></span></span></code></pre></td></tr></table></div></div><p>As you can see compilers will generally <em>NOT</em> convert a derived class into
the base class with private inheritance. This seems to indicate that it is
<em>NOT</em> an &ldquo;is-a&rdquo; relationship. The other thing that happens is that members
inherited from a private base class will all be converted to private
members of the derived base class even if they are public or protected.</p><p>So what is the meaning? Private inheritance means
&ldquo;is-implemented-in-terms-of&rdquo;. If you make class D privately inherit from
class B, you are doing so to take advantage of some features in B, not
because there&rsquo;s any conceptual link between them. If we think of it in
a way similar to item 34, private inheritance means to <em>only</em> inherit the
implementation and not the interface.</p><p>The catch is that this &lsquo;meaning&rsquo; is the exact same as item 38 -
composition. So when should you use one or the other?</p><p><mark>Use composition whenever you can, and use private inheritance when you must.</mark>
And when must you? Primarily when protected members and/or virtual
functions enter the picutre.</p><p>Lets consider a widget class that runs overtime. We want to track how
often member functions are being called in regular time intervals. We
might reuse a Timer class that looks like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Timer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Timer</span><span class=p>(</span><span class=kt>int</span> <span class=n>tickFrequency</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>onTick</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>  <span class=c1>//auto called for each tick
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This class is perfect as we can redefine the virtual function so that it
examines the state of the <code>Widget</code>. In order to redefine a virtual function
though we need to inherit from Timer. However, public inheritance is
not suitable as clients would then be able to call onTick which we do not
want. Therefore we inherit privately:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span><span class=o>:</span> <span class=k>private</span> <span class=n>Timer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>WidgetTimer</span><span class=o>:</span> <span class=k>public</span> <span class=n>Timer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=kt>void</span> <span class=n>onTick</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>WidgetTimer</span> <span class=n>timer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This is a nice design but we need to remember that this can still be done
with composition. It would be a bit more complicated though. We would
have to declare a private nested class inside Widget that would publicly
inherit from Timer, redefine <code>onTick()</code> in there and put an object of that
type into Widget.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>WidgetTimer</span><span class=o>:</span> <span class=k>public</span> <span class=n>Timer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=kt>void</span> <span class=n>onTick</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>WidgetTimer</span> <span class=n>timer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Showing this design is primarily a reminder that there are many ways to do
the same thing and they should be considered. However, there are two
rearsons why public inheritance + composition might be preferrable over
private inheritance.</p><ul><li>You might want to design Widget to allow for derived classes but
prevent derived classes from redefining <code>onTick</code>. Private inheritance would
still allow it as you can still redefine functions that you can&rsquo;t call. If you
want to replicate Java/C# ability to prevent derived classes from
redefining virtual functions this is a way to approximate that behaviour.</li><li>You might want to minimise Widget&rsquo;s compilation dependencies. If
Widget inherits from Timer, Timer&rsquo;s definition must be available when
Widget is compiled so the file defining Widget probably has to
<code>#include "Timer.h"</code>. On the other hand, if WidgetTimer is moved out of
Widget and Widget contains only a pointer to a WidgetTimer, Widget can
get by with a simple declaration for <code>WidgetTimer</code>.</li></ul><p>There is an edge case that private inheritance might be useful for involving
space optimisation. It applies when dealing with classes that have no data
in it: no non-static data members; no virtual functions; and no virtual
base classes. In theory these sort of classes should use no space.
However, they do.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Empty</span> <span class=p>{};</span> <span class=c1>//has no data so objects should use no memory
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HoldsAnInt</span> <span class=p>{</span>  <span class=c1>// should only use space for 1 int
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Empty</span> <span class=n>e</span><span class=p>;</span>    <span class=c1>//should require no memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>You&rsquo;ll find that <code>sizeof(HoldsAnint) > sizeof(int);</code>. This is because
with most compilers, sizeof(Empty) is 1. What makes this even worse is
that alignment requirements can make HoldsAndInt take even more space.
It would take the space of 2 ints, instead of 1 int + 1 char.</p><p>This is because C++ has an edict against zero-size free standing objects.
However, this does mean that if you inherit from Empty instead, the size
will be as expected:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>HoldsAnInt</span><span class=o>:</span> <span class=k>private</span> <span class=n>Empty</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Now <code>sizeof(HoldsAnInt) == sizeof(int)</code>. This is known as the &rsquo;empty
base optimisation&rsquo; (EBO). In practice, most empty classes aren&rsquo;t emtpy,
they contain typedefs, enums, static data members, or non-virtual
members. The STL has many &rsquo;technically&rsquo; empty classes. Thanks to EBO,
these classes rarely increase the size of the inheriting class.</p><p>However, this use case is indeed niche. It&rsquo;s good to be aware of but most
likely rarely used.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Private inheritance means &ldquo;is-implemented-in-terms-of&rdquo;. It is
usually inferior to composition, but makes sense if a derived class
needs access to protected base class members or to redefine virtual
functions.</li><li>Unlike composition, private inheritance can enable the <em>empty base otimisation</em>.
This can be important for library developers who strive to minimise
object sizes.</li></ul></blockquote><a href=#item-40-use-multiple-inheritance-judiciously><h3 id=item-40-use-multiple-inheritance-judiciously><span class=hanchor arialabel=Anchor># </span><strong>Item 40:</strong> Use multiple inheritance judiciously.</h3></a><p>C++ community seems to break up into two camps regarding multiple
inheritance:</p><ul><li>if single inheritance(SI) is good, multiple inheritance(MI) must be better</li><li>single inheritance is good, but multiple inheritance isn&rsquo;t worth the
trouble</li></ul><p>First thing to recognise with multiple inheritance is that it makes it
possible to inherit the same name leading to ambiguity. For example you
might inherit from two classes that both have the <code>checkout()</code> function.
To fix this you would then have to specify which one you are calling:<br><code>BorrowableItem::checkout();</code><br><code>ElectronicGadget::checkout();</code></p><p>MI can also lead to the &lsquo;deadly MI diamond&rsquo;.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>InputFile</span><span class=o>:</span> <span class=k>public</span> <span class=n>File</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>OutputFile</span><span class=o>:</span> <span class=k>public</span> <span class=n>File</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>IOFile</span><span class=o>:</span> <span class=k>public</span> <span class=n>InputFile</span><span class=p>,</span> <span class=k>public</span> <span class=n>OutputFile</span>
</span></span><span class=line><span class=cl><span class=p>{...};</span>
</span></span></code></pre></td></tr></table></div></div><p>Here you have to confront the question whether you want to replicate the
data members of the base class for each &lsquo;path&rsquo;:</p><ul><li>IOFile -> InputFile -> File</li><li>IOFile -> OutputFile -> File
C++ takes no position and happily supports both option. The default is to
perform the replication. If you don&rsquo;t want that, you have to make the
class with the data a virtual base class:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>InputFile</span><span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>File</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>OutputFile</span><span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>File</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>IOFile</span><span class=o>:</span> <span class=k>public</span> <span class=n>InputFile</span><span class=p>,</span> <span class=k>public</span> <span class=n>OutputFile</span>
</span></span><span class=line><span class=cl><span class=p>{...};</span>
</span></span></code></pre></td></tr></table></div></div><p>From the viewpoint of correct behaviour, public inheritance should always
be virtual. However, correctness is not the only perspective. Virtual
inheritance has space and time costs. It also has complexity costs.
<mark>The responsibility of initialising a virtual base is borne by the most derived class in the hierarchy</mark>.
This means that (1) classes derived from virtual base classes must be aware of their virtual bases no matter how distant and (2) when a new
derived class is added to the hierarchy, it must assume direct initialisation
responsibilities for its virtual bases.</p><p>Therefore the advice on virtual base classes is simple. Don&rsquo;t use virtual
bases unless you have to. If you must, then avoid putting data in them so
you don&rsquo;t have to worry about initialisation oddities. Interfaces in Java
are in many ways comparable to virtual base classes in C++ and are also
not allowed to contain any data.</p><p>One legitimate use is to combine public inheritance of an interface with
the private inheritance of an implementation.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>IPerson</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>IPerson</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>birthDate</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// factory function to create Person object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>IPerson</span><span class=o>&gt;</span> <span class=n>makePerson</span><span class=p>(</span><span class=n>DatabaseID</span> <span class=n>personIdentified</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Here we have an interface IPerson and a factory function declaration used
to create Person objects. But there has to be a concrete class for
makePerson to instantiate and return a pointer for.</p><p>Now lets assume we already have a class called PersonInfo that we want
to reuse to fit the IPerson interface.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>PersonInfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>PersonInfo</span><span class=p>(</span><span class=n>DatabaseID</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>PersonInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>theName</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>theBirthDate</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>valueDelimOpen</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>valueDelimClose</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>If we want to create a new class <code>CPerson</code> using the existing <code>PersonInfo</code>
class, the relationship is clearly &ldquo;CPerson is implemented in terms of
PersonInfo&rdquo;. So we could combine private and public inheritance like so:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CPerson</span><span class=o>:</span> <span class=k>public</span> <span class=n>IPerson</span><span class=p>,</span> <span class=k>private</span> <span class=n>PersonInfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>CPerson</span><span class=p>(</span><span class=n>DatabaseID</span> <span class=n>pid</span><span class=p>)</span><span class=o>:</span> <span class=n>PersonInfo</span><span class=p>(</span><span class=n>pid</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=k>return</span> <span class=n>PersonInfo</span><span class=o>::</span><span class=n>theName</span><span class=p>();}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>birthDate</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=k>return</span> <span class=n>PersonInfo</span><span class=o>::</span><span class=n>theBirthDate</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>valueDelimOpen</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>valueDelimClose</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The example should demonstrate that multiple inheritance can be both
useful and sensible. However, single inheritance is typically better. Just
be judicious with the use of MI.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Multiple inheritance is more complex than single inheritance. It can
lead to ambiguity issues.</li><li>Virtual inheritance imposes costs in size, speed, and complexity of
initialisation and assignment. It&rsquo;s most practical when virtual base
classes have no data.</li><li>Multiple inheritance does have legitimate uses. One scenario involves
combining public inheritance from an iterface class with private
inheritance from a class that helps with implementation</li></ul></blockquote><a href=#ch7-templates-and-generic-programming><h2 id=ch7-templates-and-generic-programming><span class=hanchor arialabel=Anchor># </span>Ch7: Templates and generic programming</h2></a><a href=#item-41-understand-implicit-interfaces-and-compile-time-polymorphism><h3 id=item-41-understand-implicit-interfaces-and-compile-time-polymorphism><span class=hanchor arialabel=Anchor># </span><strong>Item 41:</strong> Understand implicit interfaces and compile time polymorphism</h3></a><p>The world of OOP revolved around <em>explicit</em> interfaces and <em>runtime</em>
polymorphism. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Widget</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Widget</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>normalize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// and also this function:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>doProcessing</span><span class=p>(</span><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>10</span> <span class=o>&amp;&amp;</span> <span class=n>w</span> <span class=o>!=</span> <span class=n>someNastyWidget</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Widget</span> <span class=n>temp</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span><span class=p>.</span><span class=n>normalize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>We can say this about <code>w</code> in <code>doProcessing</code>:</p><ul><li>Because <code>w</code> is declared to be of type Widget, <code>w</code> must support the Widget
interface in the source code to see exactly what it looks like. This is an
<em>explicit interface</em> - one explicitly visible in the source code.</li><li>Because <code>w</code> is a reference and some of Widget&rsquo;s member functions are
virtual, <code>w</code>&rsquo;s calls to those functions will exhibit <em>runtime polymorphism</em>.</li></ul><p>Templates and generic programming bring <em>compile-time polymorphism</em> to
the fore. Look what happens when we change <code>doProcessing</code> into a
function template:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doProcessing</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>10</span> <span class=o>&amp;&amp;</span> <span class=n>w</span> <span class=o>!=</span> <span class=n>someNastWidget</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=nf>temp</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span><span class=p>.</span><span class=n>normalise</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Now what can we say about <code>w</code> in doProcessing?</p><ul><li>The interface that <code>w</code> must support is determined by the operations
performed on <code>w</code> in the template. In this example <code>w</code>&rsquo;s type must support the
size, normalise, and swap member functions; copy construction;
comparison for inequality. ==The set of expressions that must be valid in order for the template to compile is the <em>implicit interface</em> that T must support.</li><li>The calls to functions involving <code>w</code> such as <code>operator></code> and <code>operator!=</code>
may involve instantiating templates. Such instantiation takes place during
compilation. Because instantiating function templates with different
template parameters leads to different functions being called, this is
known as <mark>compile-time polymorphism.</mark></li></ul><p>An implicit interface is quite different to explicit interface. Consider the
start of doProcessing:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doProcessing</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>10</span> <span class=o>&amp;&amp;</span> <span class=n>w</span><span class=o>!</span> <span class=n>someNastWidget</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//this exprssn
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span></code></pre></td></tr></table></div></div><p>The implicit interface for <code>w</code> appears to have these constraints:</p><ul><li>must offer a member function names size that returns an integral value</li><li>must support <code>operator!=</code> that compares two objects of type T</li></ul><p>Size need not return an integral type. All it needs is an object of some
type X such that there is an <code>operator></code> that can be called with an object X
and an int. The <code>oeprator></code> need not even take a parameter of type X,
because it could take a parameter of type Y as long as there is available
an implicit conversion between type X to object Y.</p><p>Similarly, there is no requirement that T support <code>operator!=</code>, because it
would be fine to take one object of type X and one object of type Y, as
long as T can be converted to X and someNastyWidget&rsquo;s type can be
converted to Y.</p><p>This can seem confusing but it does not have to be. Implicit interfaces
are <mark>made up of a set of valid expressions.</mark> It&rsquo;s easier to think about the
expression as a whole.</p><p><code>if (w.size() > 10 && w != someNastyWidget)...</code><br>An expression in an if statement must be a boolean expression. This
means that as long as &ldquo;w.size() > 10 && w != someNastyWidget&rdquo; yields
something compatible with a bool, the constraint will be met.</p><p>The implicit interfaces imposed on a template&rsquo;s parameters are just as
real as explicit interfaces imposed on a class&rsquo;s objects and both are
checked during compilation.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Both classes and templates support interfaces and polymorphism</li><li>For classes, interfaces are explicit and centered on function
signatures. Polymorphism occurs at runtime through virtual functions.</li><li>For template parameters, interfaces are implicit and based on valid
expressions. Polymorphism occurs during compilation through template
instantiation and function overloading resolution.</li></ul></blockquote><a href=#item-42-understand-the-two-meanings-of-typename><h3 id=item-42-understand-the-two-meanings-of-typename><span class=hanchor arialabel=Anchor># </span><strong>Item 42:</strong> Understand the two meanings of typename.</h3></a><p>In a template declaration, class and typename is used interchangeably.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// both mean the same
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Widget</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Widget</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>However, class and typename don&rsquo;t always have the same meaning. The
meaning of class should already known. But we also have to know when
to use typename.</p><p>Few definitions:</p><ul><li><em>dependent names</em> - Names in a template that are dependent on a
template parameter</li><li><em>nested dependent name</em> - When a dependent name is nested inside a
class</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>C</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print2nd</span><span class=p>(</span><span class=k>const</span> <span class=n>C</span><span class=o>&amp;</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>C</span><span class=o>::</span><span class=n>const_iterator</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The &lsquo;const_iterator&rsquo; name is nested inside the class C, which is a
template parameter. Thus it is a nested dependent name. In fact it is
actually a &rsquo;nested dependent typename&rsquo; i.e. nested dependent name that
refers to a type.</p><p>However, nested dependent names can lead to parsing difficulties.
In theory, the <code>C::const_iterator * x;</code> could be saying &ldquo;multiply a global
variable x with a static member in C called const_iterator&rdquo;. Until C is
known, we can&rsquo;t tell if it is a type or not. C++ has a rule to resolve
this ambiguity. <mark>It assumes that nested dependent names are not types</mark>
unless told otherwise.</p><p>So what code that involves this would look like to be valid would be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>C</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print2nd</span><span class=p>(</span><span class=k>const</span> <span class=n>C</span><span class=o>&amp;</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>container</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>typename</span> <span class=n>C</span><span class=o>::</span><span class=n>const_iterator</span> <span class=n>iter</span><span class=p>(</span><span class=n>container</span><span class=p>.</span><span class=n>begin</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span></code></pre></td></tr></table></div></div><p>Putting typename in front of C::const_iterator lets the compiler know
it is a type. This needs to be done every time you refer to a nested
dependent name in a template with one exception.</p><p>The exception is that typename must not precede nested dependent type
names in a list of base classes or as a base class identifier in a member
initialisation list. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Nested</span> <span class=p>{</span> <span class=c1>//typname not allowed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Derived</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>Base</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Nested</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=c1>//typename not allowed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>typename</span> <span class=n>Base</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Nested</span> <span class=n>temp</span><span class=p>;</span> <span class=c1>// typename required
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Lets look at another example and how you might make it less tedious
to type out typename followed by a long verbose type.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>workWithIterator</span><span class=p>(</span><span class=n>IterT</span> <span class=n>iter</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>iterator_traits</span><span class=o>&lt;</span><span class=n>IterT</span><span class=o>&gt;::</span><span class=n>value_type</span> <span class=n>value_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>value_type</span> <span class=nf>temp</span><span class=p>(</span><span class=o>*</span><span class=n>iter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>typedef typename</code> juxtaposition may be jarring initially but you&rsquo;ll get
used to using it and seeing it as the alternative is to type it all out in full
every time.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>When declaring template parameters, <code>class</code> and <code>typename</code> are
interchangeable.</li><li>Use <code>typename</code> to identify nested dependent type names, except in
base class lists or as a base class identifier in a member
initialisation list.</li></ul></blockquote><a href=#item-43-know-how-to-access-names-in-templatised-base-classes><h3 id=item-43-know-how-to-access-names-in-templatised-base-classes><span class=hanchor arialabel=Anchor># </span><strong>Item 43:</strong> Know how to access names in templatised base classes.</h3></a><p>Consider an application that can send message to several different
companies in either encrypted or cleartext form. If we have enough
information during compilation to determine which messages will go
to which companies, we can use a template based solution.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CompanyA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>sendCleartext</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>sendEncrypted</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;*</span> <span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CompanyB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>sendCleartext</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>sendEncrypted</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;*</span> <span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MsgInfo</span><span class=p>{...};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Company</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MsgSender</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>sendClear</span><span class=p>(</span><span class=k>const</span> <span class=n>MsgInfo</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>msg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//create msg from info
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Company</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=p>.</span><span class=n>sendCleartext</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>sendSecret</span><span class=p>(</span><span class=k>const</span> <span class=n>MsgInfo</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{...}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Lets say we now want a derived class that adds logging before and after
we send a message:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Company</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LoggingMsgSender</span><span class=o>:</span> <span class=k>public</span> <span class=n>MsgSender</span><span class=o>&lt;</span><span class=n>Company</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>sendClearMsg</span><span class=p>(</span><span class=k>const</span> <span class=n>MsgInfo</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//log before sending
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sendClear</span><span class=p>(</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//log after sending
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Note that message sending function is called <code>sendClearMsg</code> which is
different from the base class to side-step hiding inherited names.
However, the code won&rsquo;t compile as compilers will say <code>sendClear()</code> does
not exist.</p><p>To explore why lets look at template specialisations quickly:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CompanyZ</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>sendEncrypted</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MsgSender</span><span class=o>&lt;</span><span class=n>CompanyZ</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>sendSecret</span><span class=p>(</span><span class=k>const</span> <span class=n>MsgInfo</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>{...}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>template&lt;></code> syntax specifies that this is a specialised version of the
MsgSender template to be used when the template argument is <code>CompanyZ</code>.
This is known as a <em>total template specialisation</em>. Now when we look
back at the <code>LoggingMsgSender</code> template, <code>sendClear(info);</code> no longer
makes sense as it might not exist for certain companies like <code>CompanyZ</code>.</p><p>This is why the compilers generally refuse to look in templatised base
classes for inherited names. In a sense, when we cross from object
oriented C++ to template C++, inheritance stops working.</p><p>So how do we make it work again? Three ways:</p><ul><li><code>this-></code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Company</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LoggingMsgSender</span><span class=o>:</span> <span class=k>public</span> <span class=n>MsgSender</span><span class=o>&lt;</span><span class=n>Company</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>sendClearMsg</span><span class=p>(</span><span class=k>const</span> <span class=n>MsgInfo</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//log before sending
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>sendClear</span><span class=p>(</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//log after sending
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>using MsgSender&lt;Company>sendClear;</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Company</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LoggingMsgSender</span><span class=o>:</span> <span class=k>public</span> <span class=n>MsgSender</span><span class=o>&lt;</span><span class=n>Company</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>MsgSender</span><span class=o>&lt;</span><span class=n>Company</span><span class=o>&gt;::</span><span class=n>sendClear</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>sendClearMsg</span><span class=p>(</span><span class=k>const</span> <span class=n>MsgInfo</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//log before sending
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sendClear</span><span class=p>(</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//log after sending
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>MsgSender&lt;Company>::sendClear(info);</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Company</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LoggingMsgSender</span><span class=o>:</span> <span class=k>public</span> <span class=n>MsgSender</span><span class=o>&lt;</span><span class=n>Company</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>sendClearMsg</span><span class=p>(</span><span class=k>const</span> <span class=n>MsgInfo</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//log before sending
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>MsgSender</span><span class=o>&lt;</span><span class=n>Company</span><span class=o>&gt;::</span><span class=n>sendClear</span><span class=p>(</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//log after sending
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The third way is the least desirable way because if the function being
called is virtual, explicit qualification turns off the virtual binding
behaviour.</p><blockquote class=abstract-callout><p>Summary</p><p>In derived class templates, refer to names in base class templates
via a <code>this-></code> prefix, via using declarations, or via an explicit base
class qualification.</p></blockquote><a href=#item-44-factor-parameter-independent-code-out-of-templates><h3 id=item-44-factor-parameter-independent-code-out-of-templates><span class=hanchor arialabel=Anchor># </span><strong>Item 44:</strong> Factor parameter-independent code out of templates</h3></a><p>Templates are a good way to save time and avoid code replication. Instead
of writing 20 similar classes, each with 15 member functions, you can
write one template. You can also do the same for function templates.</p><p>However, this can lead to <em>code bloat</em>. To counter this you need to do
<em>commonality and variability analysis</em>. This is something you already do
when writing non template code. You factor out common code if you
see that there are similar looking code in different functions.</p><p>The same needs to be done for templates. The catch is that in
non-template code, replication is explicit. Meaning you have to replicate
it by hand. In template code, replication is implicit. The code will be
replicated without additional input from you. You will have to train
yourself to bear this in mind.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SquareMatrix</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>inert</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>SquareMatrix</span><span class=o>&lt;</span><span class=kt>double</span><span class=p>,</span> <span class=mi>5</span><span class=o>&gt;</span> <span class=n>sm1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sm1</span><span class=p>.</span><span class=n>invert</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>SquareMatrix</span><span class=o>&lt;</span><span class=kt>double</span><span class=p>,</span> <span class=mi>10</span><span class=o>&gt;</span> <span class=n>sm1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sm1</span><span class=p>.</span><span class=n>invert</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>In this example, two copies of invert will be instantiated. The functions
will be identical other than the constants 5 and 10.</p><p>One way to solve this is to put the parameterised version of invert into a
base class. SquareMatrixBase is templatised, but only in the type of
objects. This means all matrices holding a given type of object will use
the same <code>invert</code> function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SquareMatrixBase</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>invert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>matrixSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SquareMatrix</span><span class=o>:</span> <span class=k>private</span> <span class=n>SquareMatrixBase</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>SquareMatrixBas</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>invert</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>invert</span><span class=p>()</span> <span class=p>{</span><span class=n>invert</span><span class=p>(</span><span class=n>n</span><span class=p>);}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>However, we still have another issue. SquareMatrixBase::invert needs to
know what data to operate on. It&rsquo;s impractical to provide a pointer
to the data for all functions that SquareMatrix might have. One solution
is to have SquareMatrixBase store a pointer to the memory for the matrix
values. If it stores that, then it might as well also store the size:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SquareMatrixBase</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>SquareMatrixBase</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span><span class=p>,</span> <span class=n>T</span> <span class=o>*</span><span class=n>pMem</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>size</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=n>pData</span><span class=p>(</span><span class=n>pMem</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setDataPtr</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span> <span class=n>pData</span> <span class=o>=</span> <span class=n>ptr</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>*</span><span class=n>pData</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Now the base class can decide how to allocate the memory. The derived
class might choose to allocate the matrix inside the matrix object:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SquareMatrix</span><span class=o>:</span> <span class=k>private</span> <span class=n>SquareMatrixBase</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>SquareMatrix</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>SquareMatrixBase</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>data</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>data</span><span class=p>[</span><span class=n>n</span><span class=o>*</span><span class=n>n</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Objects such as these have no need for dynamic memory allocation but
the objects themselves could be very large. An alternative that puts data
on the heap could be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SquareMatrix</span><span class=o>:</span> <span class=k>private</span> <span class=n>SquareMatrixBase</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>SquareMatrix</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>SquareMatrixBase</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=n>pData</span><span class=p>(</span><span class=k>new</span> <span class=n>T</span><span class=p>[</span><span class=n>n</span><span class=o>*</span><span class=n>n</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>setDataPtr</span><span class=p>(</span><span class=n>pData</span><span class=p>.</span><span class=n>get</span><span class=p>());}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>boost</span><span class=o>::</span><span class=n>scoped_array</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>pData</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Regardless of where the data is stored, the key result from a code bloat
viewpoint is that many, perhaps all, of SquareMatrix&rsquo;s member functions
can be simple inline calls to base class versions. At the same time,
SquareMatrix objects of different sizes are distinct types so there is no
way to accidentally pass an object of <code>SquareMatrix&lt;double,5></code> to a
function expecting <code>SquareMatrix&lt;double,10></code>.</p><p>However, there are some associated costs. The versions of invert with
the matrix sizes hardwired into them are likely to generate better code
than shared version where the size is passed as a function parameter. On
the other hand, one version of invert decreases the size of the executable
which might lead to improved locality of reference in the instruction
cache. Which is better? You will have to try both and measure.</p><p>This item discusses bloat due to non-type template parameters. However,
type parameters can cause bloat too. E.g. int and long can have same
representation on many platforms. Similarly, on most platforms all
pointer types have same binary representation, but each type pointer
can lead to bloat e.g. list&lt;int*>, list&lt;const int*>,
list&lt;SquareMatrix&lt;long,3>*>. This can be avoided using a strongly
typed pointer. This is what the STL does.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Templates generate multiple classes and multiple functions so any
template code not dependent on a template parameter causes bloat.</li><li>Bloat due to non-type template parameters can often be eliminated
by replacing template parameters with function parameters or class
data members.</li><li>Bloat due to type parameters can be reduced by sharing
implementations for instantiation types with identical binary
representations.</li></ul></blockquote><a href=#item-45-use-member-function-templates-to-accept-all-compatible-types><h3 id=item-45-use-member-function-templates-to-accept-all-compatible-types><span class=hanchor arialabel=Anchor># </span><strong>Item 45:</strong> Use member function templates to accept &ldquo;all compatible types.&rdquo;</h3></a><p>One of the things that raw pointers do well is support implicit conversions.
Derived class pointers implicitly convert into base class pointers.
Emulating such conversions in user-defined smart pointer classes is
tricky.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Top</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Middle</span><span class=o>:</span> <span class=k>public</span> <span class=n>Top</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Bottom</span><span class=o>:</span> <span class=k>public</span> <span class=n>Middle</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Top</span> <span class=o>*</span><span class=n>pt1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Middle</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Top</span> <span class=o>*</span><span class=n>pt2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Top</span> <span class=o>*</span><span class=n>pct</span> <span class=o>=</span> <span class=n>pt</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>This example shows some of the implicit conversions that can take place
in a three-level hierarchy.</p><p>With smart pointers the code might look like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>tempalte</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SmartPtr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>SmartPtr</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=n>realPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>Top</span><span class=o>&gt;</span> <span class=n>pt1</span> <span class=o>=</span> <span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>Middle</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>Middle</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>Top</span><span class=o>&gt;</span> <span class=n>pt2</span> <span class=o>=</span> <span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>Bottom</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>Bottom</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>SmartPtr</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>Top</span><span class=o>&gt;</span> <span class=n>pct</span> <span class=o>=</span> <span class=n>pt1</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>However, this does not compile as there is no inherent relationship
among different instantiations of the same template. Compilers view
<code>SmartPtr&lt;Middle></code> and <code>SmawrtPtr&lt;Top></code> as completely different classes.</p><p>In principle, the number of constructors we would need could be unlimited
as the hierarchy can be indefinitely extended. It seems we need a
<em>constructor template</em> not a constructor function:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span>  <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SmartPtr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>SmartPtr</span><span class=p>(</span><span class=k>const</span> <span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;&amp;</span> <span class=n>other</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This says that for every type T and every type U, a <code>SmartPtr&lt;T></code> can be
create from a <code>SmartPtr&lt;U></code>, because <code>SmartPtr&lt;T></code> has a constructor
that takes a <code>Smartptr&lt;U></code> parameter. Constructors like this are sometimes
known as <code>generalised copy constructors</code>. This one is not marked explicit
as as type conversions between built-in pointer types are implicit and
require not cast, so it&rsquo;s reasonable for smart pointers to emulate that
behaviour.</p><p>However, this version now offers more than we want. We don&rsquo;t want to
be able to create a <code>SmartPtr&lt;Top></code> form a <code>SmartPtr&lt;Bottom></code> as that&rsquo;s
contrary to the meaning of public interface. We also don&rsquo;t want to be able
to create a <code>SmartPtr&lt;int></code> from a <code>SmartPtr&lt;double></code> as there is no
corresponding implicit conversion.</p><p>We can use the implementation of the constructor template to restrict the
conversions to those we want.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SmartPtr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>SmartPtr</span><span class=p>(</span><span class=k>const</span> <span class=n>Smartptr</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;&amp;</span> <span class=n>other</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>heldPtr</span><span class=p>(</span><span class=n>ohter</span><span class=p>.</span><span class=n>get</span><span class=p>())</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=nf>get</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>heldPtr</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>*</span><span class=n>heldPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Since we use the member initialisation list to to initialise <code>SmartPtr&lt;T></code>&rsquo;s
data member of type T* with the pointer of type U*, this will only compile
if there is an implicit conversion from a U* pointer to a T*.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Use member function templates to generate functions that accept all
compatible types.</li><li>If you declare member templates for generalised copy construction or
generalised assignment, you&rsquo;ll still need to declare the normal copy
constructor and copy assignment operator too.</li></ul></blockquote><a href=#item-46-define-non-member-functions-inside-templates-when-type-conversions-are-desired><h3 id=item-46-define-non-member-functions-inside-templates-when-type-conversions-are-desired><span class=hanchor arialabel=Anchor># </span><strong>Item 46:</strong> Define non-member functions inside templates when type conversions are desired</h3></a><p>Item 24 explains way only non-member functions are eligible for implicit
type conversions on all arguments.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Rational</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>numberator</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>denominator</span> <span class=o>=</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>T</span> <span class=nf>numberator</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>T</span> <span class=nf>denominator</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>lhs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{...}</span>
</span></span></code></pre></td></tr></table></div></div><p>As in item 24, we want to support mixed-mode arithmetic. So we want
the following code to compile</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Rational</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>oneHalf</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Rational</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>result</span> <span class=o>=</span> <span class=n>oneHalf</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>//error won&#39;t compile
</span></span></span></code></pre></td></tr></table></div></div><p>From item 24, we know that <code>operator*</code> is being called with two
parameters. However, the compiler can&rsquo;t figure out which function to
instantiate. They need to figure out what T is but they can&rsquo;t.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// is T int or Rational&lt;T&gt;?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Rational</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>result</span> <span class=o>=</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=n>onehalf</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>One parameter is a <code>Rational&lt;T></code> and the other is an int.
<mark>Implicit type conversions are never considered during template argument deduction.</mark>
We can relieve compilers of the challenge by taking advantage of the fact
that a friend declaration in a template class can refer to a specific
function. That means the class <code>Rational&lt;T></code> can declare <code>operator*</code> for
<code>Rational&lt;T></code> as a friend function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>friend</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Rational</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>lhs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{...}</span>
</span></span></code></pre></td></tr></table></div></div><p>This wont&rsquo; still link just yet. But first a quick note about the syntax.
<mark>Inside a class template, the name of the template can be used as shorthand for the template and it&rsquo;s parameters</mark>.
So inside <code>Rational&lt;T></code> we can just write <code>Rational</code> instead of
<code>Rational&lt;T></code>.</p><p>Back to the linking problem. If we declare a function ourselves, we&rsquo;re
also responsible for defining that function. In this case we never provide
one and that&rsquo;s why the linker&rsquo;s can&rsquo;t find one. The simplest solution is
to merge the body of <code>operator*</code> in the declaration. This will compile
and link fine.</p><p>The other approach worth mentioning is the &ldquo;have a friend call a helper&rdquo;
method.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Rational</span><span class=p>;</span> <span class=c1>//declare
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>doMultiply</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>lhs</span>
</span></span><span class=line><span class=cl>                             <span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>friend</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>lhs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=k>const</span> <span class=n>Rational</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=k>return</span> <span class=nf>doMultiply</span><span class=p>(</span><span class=n>lhs</span><span class=p>,</span> <span class=n>rhs</span><span class=p>);</span> <span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=abstract-callout><p>Summary</p><p>When writing a class template that offers functions related to the
template that support <mark>implicit conversions</mark> on all parameters, define
those functions as friends inside the class template.</p></blockquote><a href=#item-47-use-traits-classes-for-information-about-types><h3 id=item-47-use-traits-classes-for-information-about-types><span class=hanchor arialabel=Anchor># </span><strong>Item 47:</strong> Use traits classes for information about types.</h3></a><p>There are 5 kinds of iterator categories:</p><ul><li><em>Input iterators</em>. Only move forward. Only move one step at a time. Only
read what they&rsquo;re pointed to and only once.</li><li><em>Output iterators</em>. Only move forward. Only one step at a time. Only
write where they&rsquo;re pointed and only once.</li><li><em>Forward iterators</em>. All of above plus can read or write more than once.</li><li><em>Bidirectional iterators</em>. Similar to forward iterators but also backwards.
e.g. <code>std::list</code></li><li><em>Random access iterators</em>. Adds &lsquo;iterator arithmetic&rsquo; to bidirectional
iterator i.e. jump forward or backward an arbitrary distance in constant
time.</li></ul><p>For each iterator category, C++ has a &ldquo;tag struct&rdquo; in the STL to identify
it.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>input_iterator_tag</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>output_iterator_tag</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>forward_iterator</span><span class=o>:</span> <span class=k>public</span> <span class=n>input_iterator_tag</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>bidrectional_iterator_tag</span><span class=o>:</span> <span class=k>public</span> <span class=n>forward_iterator</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>random_access_iterator_tag</span><span class=o>:</span> <span class=k>public</span> <span class=n>bidirectional_iterator_tag</span> <span class=p>{};</span>
</span></span></code></pre></td></tr></table></div></div><p>To implement <code>std::advance</code> you can use &lsquo;iterator arithmetic&rsquo; to move
a random access iterator a specific distance or you can increment the
iterator a certain amount of times in a loop. This requires being able to
tell what kind of iterator you are working on.
<mark>This is what traits let you do. They allow you to get information about a type during compilation.</mark></p><p>Traits aren&rsquo;t a keyword. They are a technique and convention followed by
C++ programmers. One demand on the technique is that it has to work
for built-in types as well as user defined types. This means you can&rsquo;t
nest information about a type as you can&rsquo;t do this with pointers.</p><p>The standard technique is to put it into a template and one or more
specialisations for that template.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>tempalte</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>iterT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>iterator_traits</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>The way <code>iterator_traits</code> works is that for any iterator type (iterT), a
typedef named iterator_category is declared in the struct of
<code>iterator_traits&lt;iterT></code>. This will be used to identify the iterator
category of <code>iterT</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=p>...</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>deque</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>iterator</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>typedef</span> <span class=n>random_access_iterator_tag</span> <span class=n>iterator_category</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>iterator_traits just parrots back the iterator class&rsquo;s nest typedef:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>iterator_traits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>typename</span> <span class=n>IterT</span><span class=o>::</span><span class=n>iterator_catebory</span> <span class=n>iterator_category</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>This works well for user-defined types, but not at all for pointers. The
second part of implementing iterator_traits is to create a <code>partial template specialisation</code>
for pointer types. Pointers act as random access iterators so that&rsquo;s what
we&rsquo;ll use.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>tempalte</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>iterator_traits</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>random_access_iterator_tag</span> <span class=n>iterator_category</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Given <code>iterator_traits</code> we can now refine our pseudocode for advance:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>advance</span><span class=p>(</span><span class=n>IterT</span><span class=o>&amp;</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>typeid</span><span class=p>(</span><span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>iterator_traits</span><span class=o>&lt;</span><span class=n>IterT</span><span class=o>&gt;::</span><span class=n>iterator_category</span><span class=p>)</span> <span class=o>==</span>
</span></span><span class=line><span class=cl>        <span class=k>typeid</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>random_access_iterator_tag</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>There is one more problem. We know the type during compilation but we
are evaluating it at runtime in the if statement. What we want is
conditional construct for types that is evaluated during compilation. We
can get that behaviour with overloading.</p><p>When you overload a function, compilers will pick the best overload based
on the arguments you&rsquo;re passing. A compile time conditional for types. To
get <code>advance</code> to behave the way we want, we have to create multiple
versions of an overloaded function declaring each to take a different type
of iterator_category object.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doAdvance</span><span class=p>(</span><span class=n>IterT</span><span class=o>&amp;</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>             <span class=n>std</span><span class=o>::</span><span class=n>random_access_iterator_tag</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>iter</span> <span class=o>+=</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doAdvance</span><span class=p>(</span><span class=n>IterT</span><span class=o>&amp;</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=n>std</span><span class=o>::</span><span class=n>bidirectional_iterator_tag</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>d</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=k>while</span> <span class=p>(</span><span class=n>d</span><span class=o>--</span><span class=p>)</span> <span class=o>++</span><span class=n>iter</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span> <span class=k>while</span> <span class=p>(</span><span class=n>d</span><span class=o>++</span><span class=p>)</span> <span class=o>--</span><span class=n>iter</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doAdvance</span><span class=p>(</span><span class=n>IterT</span><span class=o>&amp;</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=n>std</span><span class=o>::</span><span class=n>input_iterator_tag</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>d</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>out_of_range</span><span class=p>(</span><span class=s>&#34;Negative distance&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>d</span><span class=o>--</span><span class=p>)</span> <span class=o>++</span><span class=n>iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>forward_iterator_tag</code> inherits from <code>input_iterator_tag</code> so the version of
doAdvance for <code>input_iterator_tag</code> will also work for it.</p><p>Now, given the overloads for <code>doAdvance</code>, all <code>advance</code> needs to do is call
them.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>advance</span><span class=p>(</span><span class=n>IterT</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>doAdvance</span><span class=p>(</span><span class=n>iter</span><span class=p>,</span> <span class=n>d</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>iterator_traits</span><span class=o>&lt;</span><span class=n>IterT</span><span class=o>&gt;::</span><span class=n>iterator_category</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>How to use traits class</strong></p><ul><li>Create a set of overloaded &ldquo;worker&rdquo; functions or function templates
that differ in a traits parameter. Implement each in accord with the traits
info passed.</li><li>Create a &ldquo;master&rdquo; function or function template that calls the workers
passing information provided by a traits class.</li></ul><blockquote class=abstract-callout><p>Summary</p><ul><li>Traits classes make information about types available during
compilation. They&rsquo;re implemented using templates and template
specialisation.</li><li>In conjunction with overloading, traits make it possible to perform
compile-time <code>if...else</code> tests on types.</li></ul></blockquote><a href=#item-48-be-aware-of-template-metaprogramming><h3 id=item-48-be-aware-of-template-metaprogramming><span class=hanchor arialabel=Anchor># </span><strong>Item 48:</strong> Be aware of template metaprogramming.</h3></a><p>Template metaprogramming (TMP) is the process of writing template based
C++ programs that execute during compilation. It is a program that
executes inside the C++ compiler. That is bizarre.</p><p>TMP has two great strengths:</p><ul><li>Makes some things easy that would otherwise be hard or impossible.</li><li>Can shift work form runtime to compile time. Some consequences of this are:<ul><li>Some errors usually detected at runtime can then be detected at compile time.</li><li>Programs can be more efficient.</li><li>Compilation takes longer.</li></ul></li></ul><p>Consider the typeid based approach of advance from the previous item:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>advance</span><span class=p>(</span><span class=n>IterT</span><span class=o>&amp;</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>typeid</span><span class=p>(</span><span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>iterator_traits</span><span class=o>&lt;</span><span class=n>IterT</span><span class=o>&gt;::</span><span class=n>iterator_category</span><span class=p>)</span> <span class=o>==</span>
</span></span><span class=line><span class=cl>        <span class=k>typeid</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>random_access_iterator_tag</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>iter</span> <span class=o>+=</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>d</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span><span class=k>while</span> <span class=p>(</span><span class=n>d</span><span class=o>--</span><span class=p>)</span> <span class=o>++</span><span class=n>iter</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span><span class=k>while</span> <span class=p>(</span><span class=n>d</span><span class=o>++</span><span class=p>)</span> <span class=o>--</span><span class=n>iter</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>One of the strengths of TMP was that some things that are hard are now
easy with TMP. This is one example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>advance</span><span class=p>(</span><span class=n>iter</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>This will <em>NOT</em> compile. Why? Because <code>iter += d</code> does not work on list
iterators which are bidirectional. We know it will never go in the <code>if</code> block
but compilers are obliged to make sure all source code is valid even if not
executed.</p><p>TMP is turing complete. For a quick glimpse of what is possible lets look
at the &ldquo;hello world&rdquo; of TMP, computing a factorial.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//general case. Factorial n = n times factorial n - 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Factorial</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=p>{</span> <span class=n>value</span> <span class=o>=</span> <span class=n>n</span> <span class=o>*</span> <span class=n>Factorial</span><span class=o>&lt;</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//special case. factorial 0 = 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Factorial</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=p>{</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>1</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This uses the &rsquo;enum hack&rsquo; to store the value. Now to use factorial, you
can do so like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>Factorial</span><span class=o>&lt;</span><span class=mi>5</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>;</span> <span class=c1>//prints 120
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>Factorial</span><span class=o>&lt;</span><span class=mi>10</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>;</span> <span class=c1>//prints 3628800
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Here are 3 examples to describe the power of TMP:</p><ul><li><strong>Ensuring dimensional unit correctness.</strong> in scientific and engineering
applications, it&rsquo;s essential to combine units(e.g mass, distance, time
etc) correctly. Using TMP, it&rsquo;s possible to ensure (during compilation)
that all dimensional unit combinations in a program are correct no matter
how complex the calculations. One interesting aspect of this use of TMP
is that fractional dimensional exponents can be supported. This requires
fractions to be reduced <em>during compilation</em> so that compilers can confirm
that &ldquo;time 1/2&rdquo; is the same as &ldquo;time 4/8&rdquo;.</li><li><strong>Optimising matrix operations.</strong> Item 21 talked about how some functions
must return new objects.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>SquareMatrix</span><span class=o>&lt;</span><span class=kt>double</span><span class=p>,</span> <span class=mi>10000</span><span class=o>&gt;</span> <span class=n>BigMatrix</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Bigmatrix</span> <span class=n>m1</span><span class=p>,</span> <span class=n>m2</span><span class=p>,</span> <span class=n>m3</span><span class=p>,</span> <span class=n>m4</span><span class=p>,</span> <span class=n>m5</span><span class=p>;</span> <span class=c1>//create matrices
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>                           <span class=c1>//give them values
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BIgMatrix</span> <span class=n>result</span> <span class=o>=</span> <span class=n>m1</span> <span class=o>*</span> <span class=n>m2</span> <span class=o>*</span> <span class=n>m3</span> <span class=o>*</span> <span class=n>m4</span> <span class=o>*</span> <span class=n>m5</span><span class=p>;</span> <span class=c1>//compute product
</span></span></span></code></pre></td></tr></table></div></div><p>Calculating the normal way requires the creation of 4 temporary matrices.
Furthermore, the independent multiplications generate a sequence of four
loops over the matrix elements. Using advance template technology related
to TMP called <em>expression templates</em>, it&rsquo;s possible to eliminate the
temporaries and merge the loops, all without changing the syntax of the
client code above.</p><ul><li><strong>Generating custom design pattern implementations.</strong> Design patterns like
Strategy, Observer, Visitor, etc can be implemented in many ways. Using
TMP based technology called <em>policy-based design</em>, it&rsquo;s possible to create
templates representing independent design choices (&ldquo;policies&rdquo;) that can
be combined in arbitrary ways to yield pattern implementations with
custom behaviour. For example, this technique has been used for a few
templates implementing smart pointer behavioral policies to generate
(during compilation) any of hundreds of different smart pointer types.
This is a basis for what is known as generative programming.</li></ul><blockquote class=abstract-callout><p>Summary</p><ul><li>TMP can shift work from runtime to compile time, enabling earlier
detection and higher runtime performance.</li><li>TMP can generate custom code based on combination of policy
choices, and also be used to avoid generating code inappropriate for
particular types.</li></ul></blockquote><a href=#ch8-customising-new-and-delete><h2 id=ch8-customising-new-and-delete><span class=hanchor arialabel=Anchor># </span>Ch8: Customising <code>new</code> and <code>delete</code></h2></a><a href=#item-49-understand-the-behaviour-of-the-new-handler><h3 id=item-49-understand-the-behaviour-of-the-new-handler><span class=hanchor arialabel=Anchor># </span><strong>Item 49:</strong> Understand the behaviour of the new-handler</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>std</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>new_handler</span><span class=p>)();</span>
</span></span><span class=line><span class=cl>    <span class=n>new_handler</span> <span class=nf>set_new_handler</span><span class=p>(</span><span class=n>new_handler</span> <span class=n>p</span><span class=p>)</span> <span class=k>throw</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>set_new_handler</code>&rsquo;s parameter is a pointer to the function operator <code>new</code>
should call if it can&rsquo;t allocate the requested memory. The return value of
<code>set_new_handler</code> is a pointer to the previous function that would have
been called.</p><p>You can use <code>set_new_handler</code> like so:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>outOfMem</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Unable to satisfy requeset for memory</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>abort</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=n>outOfMem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>pBigDataArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=mi>100000000L</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>When operator <code>new</code> is unable to fulfill a memory request, it calls the
new_handler repeatedly until it <em>can</em> find enough memory. A new_handler
must do one of the following:</p><ul><li><strong>Make more memory available</strong></li><li><strong>Install a different new-handler</strong></li><li><strong>Deinstall the new-handler</strong><ul><li>Pass <code>nullptr</code> to <code>set_new_handler</code> which will cause operator <code>new</code> to throw an exception next time memory allocation is unsuccessful.</li></ul></li><li><strong>Throw an exception</strong></li><li><strong>Not return</strong><ul><li>Usually by aborting</li></ul></li></ul><p>To implement &lsquo;class-specific new-handler&rsquo; like behaviour:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>set_new_handler</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>p</span><span class=p>)</span> <span class=k>throw</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=k>throw</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>currentHandler</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>Widget</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>p</span><span class=p>)</span> <span class=k>throw</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>oldHandler</span> <span class=o>=</span> <span class=n>currentHandler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>currentHandler</span> <span class=o>=</span> <span class=n>p</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>oldHandler</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>Widget</code>s operator <code>new</code> will do the following:</p><ul><li>Call the standard <code>set_new_handler</code> with Widget&rsquo;s error handling
function. This installs widgets new_handler as the global new_handler.</li><li>Call global operator <code>new</code> to perform memory allocation.</li><li>If allocation fails, call Widgets new_handler. If it still can&rsquo;t allocate
the memory, restore the original new_handler, then propagate exception.
You can use a RAII object for this.</li><li>if allocation succeeds, the destructor for the object managing the global
new_handler restores the global new_handler to what it was.</li></ul><p>e.g.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NewHandlerHolder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>NewHandlerHolder</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>nh</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>handler</span><span class=p>(</span><span class=n>nh</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>NewHandlerHolder</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=n>handler</span><span class=p>);}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>handler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NewHandlerHolder</span><span class=p>(</span><span class=k>const</span> <span class=n>NewHandlerHolder</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>NewHandlerHolder</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>NewHandlerHolder</span><span class=o>&amp;</span><span class=p>)</span><span class=err>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// WIdget&#39;s operator new
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span><span class=o>*</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=k>throw</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NewHandlerHolder</span>
</span></span><span class=line><span class=cl>      <span class=nf>h</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=n>currentHandler</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>::</span><span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Client&rsquo;s of Widget would use it like so:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>outOfMem</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//set outOfMem as widget&#39;s new-handling func
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Widget</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=n>outOfMem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// calls outOfMem if allocation fails
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Widget</span><span class=o>*</span> <span class=n>pw1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Widget</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// calls global new-handling function if allocation fails
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>ps</span> <span class=o>=</span> <span class=k>new</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// set new-handling func to nothing
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Widget</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//if mem. alloc fails, throw exception immediately
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Widget</span><span class=o>*</span> <span class=n>pw2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Widget</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>The above NewHandlerHolder can be adapted very easily to be used as a
&ldquo;mixin-style&rdquo; base class using templates. Then Widget could just inherit
from that class:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>NewHandlerHolderSupport</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>set_new_handler</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>p</span><span class=p>)</span> <span class=k>throw</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=k>throw</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>currentHandler</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// implement functions from interface
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span><span class=o>:</span> <span class=k>public</span> <span class=n>NewHandlerSupport</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Widget inheriting from a templatised base class that takes <code>Widget</code> as a
type parameter might look strange but it is a useful technique. It even
has a name. <mark>Curiously recurring template pattern (CRTP)</mark>.</p><p>Until 1993, C++ required that <code>new</code> return null when it was unable to allocate
the requested memory. Now it throws <code>bad_alloc</code>. To support the old style
new C++ offers a nothrow form of <code>new</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Widget</span><span class=o>*</span> <span class=n>pw2</span> <span class=o>=</span> <span class=k>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>nothrow</span><span class=p>)</span> <span class=n>Widget</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>Unfortunately, this is not very useful as it is only nothrow for the
allocation part. Constructing the object can still throw.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>set_new_handler allows you to specify a function to be called when
memory allocation requests cannot be satisfied.</li><li>Nothrow new is of limited utility, because it applies only to memory
allocation; associated constructor calls may still throw exceptions.</li></ul></blockquote><a href=#item-50-understand-when-it-makes-sense-to-replace-new-and-delete><h3 id=item-50-understand-when-it-makes-sense-to-replace-new-and-delete><span class=hanchor arialabel=Anchor># </span><strong>Item 50:</strong> Understand when it makes sense to replace new and delete</h3></a><p>Three most common reasons to replace compiler version of operator <code>new</code>
or <code>delete</code>.</p><ul><li><strong>To detect usage errors</strong><ul><li>A custom operator new can keep list of allocated addresses and operator delete can remove from the list. This can easily detect usage errors such as failure to delete.</li><li>Custom operator new can allocate blocks alongside signatures. Then operator delete can check if the signatures are intact. This can detect an overrun or underrun.</li></ul></li><li><strong>To improve efficiency</strong><ul><li>Compiler versions of new and delete are general purpose. They have to work well with programs that run for less than a second as well as something like web servers. By using a more specialised version, it can often be easy to increase the performance of your program.</li></ul></li><li><strong>To collect usage statistics</strong><ul><li>Before optimising, you can gather data on how your program uses and allocates memory. What is the distribution of allocated block sizes, their lifetimes, pattern the blocks are allocated and de-allocated (FIFO or LIFO or random), maximum amount of allocated memory used at a given time etc.</li></ul></li></ul><p>Simple (with problems) operator <code>new</code> that facilitates under and overruns.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>signature</span> <span class=o>=</span> <span class=mh>0xDEADBEEF</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>Byte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=k>throw</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// increase size of request to fit signature
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>realSize</span> <span class=o>=</span> <span class=n>size</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// call malloc to get memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span><span class=o>*</span> <span class=n>pMem</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=n>realSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>pMem</span><span class=p>)</span> <span class=k>throw</span> <span class=n>bad_alloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>//write signature into first and last parts of memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>pMem</span><span class=p>))</span> <span class=o>=</span> <span class=n>signature</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>reinterpre_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Byte</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>pMem</span><span class=p>)</span> <span class=o>+</span> <span class=n>realSize</span><span class=o>-</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)))</span> <span class=o>=</span> <span class=n>signature</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// return pointer to the memory just past first sig
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Byte</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>pMem</span><span class=p>)</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Most of the shortcomings of this have to do with failure to adhere to
the C++ conventions for operator <code>new</code>. However, one more subtle
issue is <strong>alignment</strong>.</p><p>Many computer architectures require that data of particular types be
placed in memory at particular kinds of addresses. E.g. a requirement
might be that pointers occur at addresses that are a multiple of 4
(i.e. be <em>four-byte aligned</em>) or that doubles must occur at addresses
that are multiples of 8 (<em>eight-byte aligned</em>). Failure could result in
hardware exceptions for some architectures. More forgiving ones
might just result in degraded performance.</p><p>Details like this make writing professional-quality memory managers
difficult. Don&rsquo;t try it unless you have to. An option is to use open
source memory managers. One example is the Pool library from Boost.
It optimises for allocation of a large number of small objects.</p><p>We can now add more bullet points to why we might want to use custom
version of <code>new</code> and <code>delete</code></p><ul><li>To detect usage errors</li><li>To collect statistics about the use of dynamically allocated memory</li><li>To increase the speed of allocation and deallocation.</li><li>To reduce space overhead of default memory management.</li><li>To compensate for suboptimal alignment in default allocator.</li><li>To cluster related objects near one another.</li><li>To obtain unconventional behaviour - e.g. Deallocate blocks in shared memory via a C API.</li></ul><blockquote class=abstract-callout><p>Summary</p><p>There are many valid reasons for writing custom versions of <code>new</code>
and <code>delete</code>. Some include improving performance, debugging heap
usage errors, and collecting heap usage information.</p></blockquote><a href=#item-51-adhere-to-convention-when-writing-new-and-delete><h3 id=item-51-adhere-to-convention-when-writing-new-and-delete><span class=hanchor arialabel=Anchor># </span><strong>Item 51:</strong> Adhere to convention when writing <code>new</code> and <code>delete</code></h3></a><p>Implementing a conformant operator <code>new</code> requires:</p><ul><li>have right return value</li><li>call new-handling function when insufficient memory available</li><li>cope with requests for no memory</li><li>avoid hiding the &ldquo;normal&rdquo; <code>new</code></li></ul><p>Here is a simple implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=k>throw</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//attempt to allocate size bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=cm>/*allocation was successful*/</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=cm>/*pointer to memory*/</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// allocation unsuccessful. Get current new_handler
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>new_handler</span> <span class=n>globalHandler</span> <span class=o>=</span> <span class=n>set_new_handler</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>globaHandler</span><span class=p>)(</span><span class=o>*</span><span class=n>globalHandler</span><span class=p>)();</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>For operator <code>new[]</code>, remember you can&rsquo;t figure out how many objects will
be in the array or even how big an object is. This is because a base
class&rsquo;s <code>new[]</code> might be used, through inheritance, to allocate memory for
an array of derived class objects. All you can do is allocate a chunk of
memory. All you need to remember is to make sure it is safe to delete a
null pointer.</p><p><code>size_t</code> values passed to operator <code>delete</code> may be incorrect if the object
being deleted was derived from a base class lacking a virtual destructor.
Make sure you&rsquo;re base classes have virtual destructors.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Operator <code>new</code> should contain an infinite loop trying to allocate
memory, should call new-handler if it can&rsquo;t satisfy a memory request,
and should handle requests for zero bytes. Class specific versions
should handle requests for larger blocks than expected.</li><li>Operator <code>delete</code> should do nothing if passed a pointer that is null.
Class specific versions should handle blocks that are larger than
expected.</li></ul></blockquote><a href=#item-52-write-placement-delete-if-you-write-placement-new><h3 id=item-52-write-placement-delete-if-you-write-placement-new><span class=hanchor arialabel=Anchor># </span><strong>Item 52:</strong> Write placement <code>delete</code> if you write placement <code>new</code></h3></a><p>For a line such as this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Widget</span> <span class=o>*</span><span class=n>pW</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Widget</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>Two function calls are made, one to operator new to allocate memory and
another to the constructor of Widget. If the first call succeeds but the
second one does not, the memory allocation has to be undone. However,
client code is unable to do this as <code>*pW</code> was never assigned.</p><p>The C++ runtime must handle this responsibility. With normal forms of <code>new</code>
and <code>delete</code> it is not a problem. However, if you have a class specific one
with extra parameters it is known as a <mark>placement</mark> version of <code>new</code>.</p><p>There is an &lsquo;original&rsquo; version of placement new in the STL:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>pMemory</span><span class=p>)</span> <span class=k>throw</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>Sometimes when people talk about &lsquo;placement new&rsquo; they are talking about
this specific original version. Be mindful what one they are talking about.</p><p>Now, if you use a placement version of new and the constructor call fails,
the runtime system will look for a version of new with the same number
of parameters and types. If it finds it, it calls it. If it does not, then no
delete will be called.</p><p>To eliminate memory leaks, you need to specify a matching version of
placement <code>delete</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// class specific placement new
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>logStream</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// class specific delete - when no exception throw
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>void</span> <span class=k>operator</span> <span class=nf>delete</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>pMemory</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// class specific placement delete - when exceptions thrown
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>void</span> <span class=k>operator</span> <span class=nf>delete</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>pMemory</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>logStream</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>One thing to bear in mind that when you declare class specific <code>new</code> and
<code>delete</code>, this will hide the global versions. Be sure to make them
available in addition to any custom operator <code>new</code> forms you create. This
can be done by creating a base class containing the normal global
versions and inheriting from it.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>When you write a placement version of operator <code>new</code>, be sure to
write the corresponding placement version of operator <code>delete</code>. If you
don&rsquo;t, there may be subtle, intermittent memory leaks.</li><li>When you declare placement versions of <code>new</code> and <code>delete</code>, be sure not
to unintentionally hide the normal versions of those functions.</li></ul></blockquote><a href=#ch9-miscellany><h2 id=ch9-miscellany><span class=hanchor arialabel=Anchor># </span>Ch9: Miscellany</h2></a><a href=#item-53-pay-attention-to-compiler-warnings><h3 id=item-53-pay-attention-to-compiler-warnings><span class=hanchor arialabel=Anchor># </span><strong>Item 53:</strong> Pay attention to compiler warnings</h3></a><p>Compiler warnings should not be ignored in C++ with the thought that &ldquo;if
it was really a big problem, it would be an error&rdquo;. Here is one example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>f</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D</span><span class=o>:</span> <span class=k>public</span> <span class=n>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>f</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The intent is for <code>D::f</code> to redefine <code>B::f</code> but the mistake is that the version
in D is not const. The compiler might warn you by saying something like
&ldquo;Warning: D::f() hides virtual B::f()&rdquo;. It is a mistake to think,
&ldquo;of course it does. That&rsquo;s what i&rsquo;m trying to do&rdquo;. Anyhow, if this is
ignored, it will almost certainly lead to erroneous behaviour which will
require a lot of debugging to later discover.</p><p>After you gain experience with warning messages from a particular
compiler, you&rsquo;ll learn to understand the different messages. At that point
you can then opt to ignore certain classes if warnings, although it is
better practice to strive for warning free code.</p><p>Relying on warnings is also not a good idea as there will be differences
across different compilers. You should strive to write warning free code
without relying on the compilers warning to catch mistakes. A different
compiler might not provide the warning message that you have become
reliant on getting.</p><blockquote class=abstract-callout><p>Summary</p><ul><li>Take compiler warnings seriously and strive to compile warning-free
at the maximum warning level supported by your compiler.</li><li>Don&rsquo;t become dependent on compiler warnings because different
compilers will warn you about different things. Moving compilers may
eliminate a warning that you have become reliant on.</li></ul></blockquote><a href=#item-54-familiarise-yourself-with-the-standard-library-including-tr1><h3 id=item-54-familiarise-yourself-with-the-standard-library-including-tr1><span class=hanchor arialabel=Anchor># </span><strong>Item 54:</strong> Familiarise yourself with the standard library, including TR1</h3></a><p>Initial standard for C++ was ratified in 1998. in 2003, a minor &lsquo;bug-fix&rsquo;
update was issued. The standardisation committee continued it&rsquo;s work,
however, and a &ldquo;Version 2.0&rdquo; C++ standard was adopted in 2011.</p><p>C++11 includes a number of interesting new language features, but most
come in the form of additions to the standard library. Before we look at
C++11, lets look at what was included in the standard library by C++98:</p><ul><li><strong>The standard template library (STL)</strong>, including containers;
iterators; algorithms; function objects; and various container and function
object adapters.</li><li><strong>Iostreams</strong>, including support for user-defined buffering, internalised IO
and predefined objects <code>cin</code>, <code>cout</code>, <code>cerr</code> and <code>clog</code>.</li><li><strong>Support for internationalisation</strong>. Multiple active locales. <code>wchar_t</code>.
<code>wstring</code>.</li><li><strong>Support for numerical processing</strong>, including templates for complex
numbers and arrays of pure values.</li><li><strong>An exception hierarchy</strong></li><li><strong>C89&rsquo;s standard library</strong></li></ul><p>Technical Report 1 (TR1) specifies 14 new components. All are in the std
namespace (used to be nested within std in the tr1 namespace).</p><ul><li><strong>Smart pointers</strong></li><li><strong>tr1::function</strong>. Makes it possible to represent <em>any</em> callable entity.</li><li><strong>tr1::bind</strong></li><li><strong>Hash tables</strong></li><li><strong>Regular expressions</strong></li><li><strong>Tuples</strong></li><li><strong>tr1::array</strong></li><li><strong>tr1::mem_fn</strong>. Syntactically uniform way of adapting member function pointers</li><li><strong>tr1::reference_wrapper</strong>. facility to make references act a bit more like objects.</li><li><strong>Random number generation</strong></li><li><strong>Mathematical special functions</strong>, including Laguerre polynomial, Bessel functions etc.</li><li><strong>C99 compatibility extensions</strong>, collection of functions and templates
designed to bring many new C99 features to C++.</li><li><strong>Type traits</strong></li><li><strong>tr1::result_of</strong>, a template to deduce return type of function calls.</li></ul><blockquote class=abstract-callout><p>Summary</p><ul><li>The primary C++ library functionality consists of the STL, iostreams,
and locales.</li><li>TR1 added support for smart_pointers, generalised function pointers
, hash-based containers, regular expressions and 10 more components.</li></ul></blockquote><a href=#item-55-familiarise-yourself-with-boost><h3 id=item-55-familiarise-yourself-with-boost><span class=hanchor arialabel=Anchor># </span><strong>Item 55:</strong> Familiarise yourself with Boost.</h3></a><p>Look to boost for the following:</p><ul><li>High quality, open source, platform and compiler-independent libraries</li><li>Community of ambitious, talented C++ developers working on
state-of-the-art library design and implementation</li><li>Glimpse of what C++ might look like in the future</li></ul><p>Boost was founded by committee members and there is strong overlap between Boost and committee memberships.</p><p>It&rsquo;s process for accepting libraries is based on peer review. This keeps
poorly written libraries out of Boost, but also helps to educate library
authors in the considerations that go into design, implementation, and
documentation of industrial-strength cross-platform libraries.</p><p>Boost covers a large cornucopia of topics. These categories include:</p><ul><li><strong>String and text manipulation</strong></li><li><strong>Containers</strong></li><li><strong>Function objects and higher-order programming</strong></li><li><strong>Generic programming</strong></li><li><strong>Template metaprogramming</strong></li><li><strong>Math and numerics</strong></li><li><strong>Correctness and testing</strong></li><li><strong>Data structures</strong></li><li><strong>Inter-language support</strong>, including a library to allow seamless
interoperability between C++ and python.</li><li><strong>Memory</strong>, including pool library for high-performance fixed-size allocators.</li><li><strong>Miscellaneous</strong>: CRC checking, date and time manipulations, traversing
file systems.</li></ul><blockquote class=abstract-callout><p>Summary</p><ul><li>Boost is a community and web site for the development of free,
open source, peer-reviewed C++ libraries. Boost plays an influential
role in C++ standardisation.</li><li>Boost offers implementations of many TR1 components, but it also
offers many other libraries.</li></ul></blockquote></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://diwashrai.github.io/digital-garden/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Diwash Rai using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2023</p><ul><li><a href=https://diwashrai.github.io/digital-garden/>Home</a></li><li><a href=https://github.com/DiwashRai>GitHub</a></li></ul></footer></div></div></body></html>